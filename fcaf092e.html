<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>深度解析 PostgreSQL 引擎：设计原理、实现机制与性能优化 - Jaco Liu Personal Site (ljq@GitHub).安全贯穿于软件开发各个环节.</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Jaco Liu Personal Site (ljq@GitHub).安全贯穿于软件开发各个环节."><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Jaco Liu Personal Site (ljq@GitHub).安全贯穿于软件开发各个环节."><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="引言“当你不能用简单的语言来描述一件事情时，说明你没弄懂它。” ————费曼 在当今数据驱动的时代，数据库系统作为企业核心基础设施的重要性不言而喻。PostgreSQL 作为世界上最先进的开源关系型数据库管理系统，凭借其卓越的稳定性、强大的功能集和优秀的性能表现，已经成为众多企业和开发者的首选。自 1986 年诞生以来，PostgreSQL 经历了近四十年的发展历程，从最初的”Ingres”项"><meta property="og:type" content="blog"><meta property="og:title" content="深度解析 PostgreSQL 引擎：设计原理、实现机制与性能优化"><meta property="og:url" content="https://www.wdft.com/fcaf092e.html"><meta property="og:site_name" content="Jaco Liu Personal Site (ljq@GitHub).安全贯穿于软件开发各个环节."><meta property="og:description" content="引言“当你不能用简单的语言来描述一件事情时，说明你没弄懂它。” ————费曼 在当今数据驱动的时代，数据库系统作为企业核心基础设施的重要性不言而喻。PostgreSQL 作为世界上最先进的开源关系型数据库管理系统，凭借其卓越的稳定性、强大的功能集和优秀的性能表现，已经成为众多企业和开发者的首选。自 1986 年诞生以来，PostgreSQL 经历了近四十年的发展历程，从最初的”Ingres”项"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.wdft.com/assets/images/db.jpg"><meta property="article:published_time" content="2025-11-22T11:18:13.000Z"><meta property="article:modified_time" content="2025-12-24T09:46:05.326Z"><meta property="article:author" content="Jaco Liu"><meta property="article:tag" content="postgresql"><meta property="article:tag" content="postgressql-engine"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/assets/images/db.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.wdft.com/fcaf092e.html"},"headline":"深度解析 PostgreSQL 引擎：设计原理、实现机制与性能优化","image":["https://www.wdft.com/assets/images/db.jpg"],"datePublished":"2025-11-22T11:18:13.000Z","dateModified":"2025-12-24T09:46:05.326Z","author":{"@type":"Person","name":"Jaco Liu"},"publisher":{"@type":"Organization","name":"Jaco Liu Personal Site (ljq@GitHub).安全贯穿于软件开发各个环节.","logo":{"@type":"ImageObject","url":"https://www.wdft.com/img/logo.svg"}},"description":"引言“当你不能用简单的语言来描述一件事情时，说明你没弄懂它。” ————费曼 在当今数据驱动的时代，数据库系统作为企业核心基础设施的重要性不言而喻。PostgreSQL 作为世界上最先进的开源关系型数据库管理系统，凭借其卓越的稳定性、强大的功能集和优秀的性能表现，已经成为众多企业和开发者的首选。自 1986 年诞生以来，PostgreSQL 经历了近四十年的发展历程，从最初的”Ingres”项"}</script><link rel="canonical" href="https://www.wdft.com/fcaf092e.html"><link rel="alternate" href="/atom.xml" title="Jaco Liu Personal Site (ljq@GitHub).安全贯穿于软件开发各个环节." type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><script>!function(){var e=document.createElement("script"),t=(e.src="//hm.baidu.com/hm.js?45914c5ebb523a9ed07ab35e4dc81374",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><meta name="msvalidate.01" content="ad0df3c8d20f49daaeb5baa3c9dbfe75"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8952360410310192" crossorigin="anonymous"></script><script>!function(){function e(){if(location.hash){Array.from(document.querySelectorAll(".tab-content")).forEach(e=>{e.classList.add("is-hidden")}),Array.from(document.querySelectorAll(".tabs li")).forEach(e=>{e.classList.remove("is-active")});const e=document.querySelector(location.hash),t=(e&&e.classList.remove("is-hidden"),document.querySelector(`a[href="${location.hash}"]`));t&&t.parentElement.classList.add("is-active")}}e(),window.addEventListener("hashchange",e,!1)}()</script><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><img src="/img/avatar.jpeg" width="0" height="0"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Jaco Liu Personal Site (ljq@GitHub).安全贯穿于软件开发各个环节." height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/musics">Musics</a><a class="navbar-item" href="/videos">Videos</a><a class="navbar-item" href="/galleries">Galleries</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item dark-mode-btn" title="Light|Dark" rel="noopener" onclick="switchDarkMode()">    <i class="fas fa-lightbulb">  </i></a><a class="navbar-item" target="_blank" rel="noopener" title="Musics" href="/musics"><i class="fas fa-music"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Videos" href="/videos"><i class="fas fa-video"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="WeChat Account (labsec)" href="/assets/images/about/ljq-qrcode.jpeg"><i class="fab fa-weixin"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Jaco Liu GitHub" href="https://github.com/ljq"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/assets/images/db.jpg" alt="深度解析 PostgreSQL 引擎：设计原理、实现机制与性能优化"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2025-11-22T11:18:13.000Z" title="11/22/2025, 7:18:13 PM">2025-11-22</time></span><span class="level-item">Updated&nbsp;<time datetime="2025-12-24T09:46:05.326Z" title="12/24/2025, 5:46:05 PM">2025-12-24</time></span><span class="level-item"> Jaco Liu </span><span class="level-item"><a class="link-muted" href="/categories/Database/">Database</a></span><span class="level-item">an hour read (About 12081 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">深度解析 PostgreSQL 引擎：设计原理、实现机制与性能优化</h1><div class="content"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>“当你不能用简单的语言来描述一件事情时，说明你没弄懂它。” ————费曼</strong></p><p>在当今数据驱动的时代，数据库系统作为企业核心基础设施的重要性不言而喻。PostgreSQL 作为世界上最先进的开源关系型数据库管理系统，凭借其卓越的稳定性、强大的功能集和优秀的性能表现，已经成为众多企业和开发者的首选。自 1986 年诞生以来，PostgreSQL 经历了近四十年的发展历程，从最初的”Ingres”项目演变为今天功能完备的企业级数据库解决方案。</p><p>本文将深入探讨 PostgreSQL 引擎的核心设计原理、实现机制以及性能特性，为数据库架构师、开发人员和运维工程师提供全面的技术参考。我们将从架构层面开始，逐步深入到存储引擎、事务管理、查询优化等核心组件，最后分析其性能优缺点并提供优化建议。通过本文，读者将获得对 PostgreSQL 内部工作原理的深刻理解，从而在实际应用中能够更好地设计、部署和优化基于 PostgreSQL 的应用系统。</p><span id="more"></span><h2 id="一、PostgreSQL-核心架构设计"><a href="#一、PostgreSQL-核心架构设计" class="headerlink" title="一、PostgreSQL 核心架构设计"></a>一、PostgreSQL 核心架构设计</h2><h3 id="1-1-客户端-x2F-服务器模型"><a href="#1-1-客户端-x2F-服务器模型" class="headerlink" title="1.1 客户端&#x2F;服务器模型"></a>1.1 客户端&#x2F;服务器模型</h3><p>PostgreSQL 采用经典的客户端&#x2F;服务器架构模型，这是其设计的核心基础。在这种架构中，数据库服务器（通常称为”postmaster”）负责管理数据库文件、接受客户端连接请求，并为每个客户端连接创建独立的后端进程。 这种设计模式使得 PostgreSQL 能够有效地支持多用户并发访问，同时保持系统的稳定性和隔离性。</p><p>客户端&#x2F;服务器架构的优势在于：</p><ul><li><strong>资源隔离</strong>：每个客户端连接在独立的进程中运行，一个连接的故障不会影响其他连接</li><li><strong>并发控制</strong>：服务器可以集中管理所有并发事务，确保数据一致性</li><li><strong>安全性</strong>：通过集中式的认证和授权机制，保护数据安全</li><li><strong>可扩展性</strong>：服务器可以部署在高性能硬件上，客户端可以分布在不同的设备上</li></ul><h3 id="1-2-核心组件架构"><a href="#1-2-核心组件架构" class="headerlink" title="1.2 核心组件架构"></a>1.2 核心组件架构</h3><p>PostgreSQL 的架构由几个关键组件组成，这些组件协同工作以提供完整的数据库服务：</p><h4 id="1-2-1-Postmaster-守护进程"><a href="#1-2-1-Postmaster-守护进程" class="headerlink" title="1.2.1 Postmaster 守护进程"></a>1.2.1 Postmaster 守护进程</h4><p>Postmaster 是 PostgreSQL 的主进程，负责启动数据库系统、监听客户端连接请求，并为每个新连接创建后端进程。 它是整个 PostgreSQL 实例的”大脑”，管理着系统的所有资源分配和进程调度。当数据库启动时，postmaster 首先初始化共享内存区域，加载配置参数，然后开始监听指定的端口等待客户端连接。</p><h4 id="1-2-2-共享内存"><a href="#1-2-2-共享内存" class="headerlink" title="1.2.2 共享内存"></a>1.2.2 共享内存</h4><p>共享内存是 PostgreSQL 性能优化的关键组件之一。它包含多个重要区域：</p><ul><li><strong>共享缓冲区（Shared Buffer）</strong>：缓存数据页，减少磁盘 I&#x2F;O</li><li><strong>WAL 缓冲区（WAL Buffer）</strong>：缓存预写日志，确保事务持久性</li><li><strong>共享锁表（Lock Table）</strong>：管理并发事务之间的锁</li><li><strong>工作内存（Work Memory）</strong>：用于排序、哈希连接等操作</li></ul><p>共享内存的设计使得多个后端进程可以高效地共享数据，避免了频繁的进程间通信开销。</p><h4 id="1-2-3-后端进程"><a href="#1-2-3-后端进程" class="headerlink" title="1.2.3 后端进程"></a>1.2.3 后端进程</h4><p>每个客户端连接都会创建一个独立的后端进程（backend process），这些进程负责处理具体的 SQL 查询、事务管理、权限检查等工作。 后端进程之间相互隔离，一个进程的崩溃不会影响其他进程，这大大提高了系统的稳定性。每个后端进程都有自己的私有内存区域，同时可以访问共享内存中的全局数据。</p><h4 id="1-2-4-共享池"><a href="#1-2-4-共享池" class="headerlink" title="1.2.4 共享池"></a>1.2.4 共享池</h4><p>共享池是 PostgreSQL 内存管理的重要组成部分，用于缓存执行计划、系统目录信息等。 通过重用已有的执行计划，可以避免重复的查询解析和优化过程，提高查询性能。共享池的设计体现了 PostgreSQL 对性能优化的深入考虑。</p><h3 id="1-3-多进程架构设计"><a href="#1-3-多进程架构设计" class="headerlink" title="1.3 多进程架构设计"></a>1.3 多进程架构设计</h3><p>与许多现代数据库采用的多线程架构不同，PostgreSQL 坚持使用多进程架构。这种设计选择有其历史原因和技术考量：</p><h4 id="1-3-1-稳定性优先"><a href="#1-3-1-稳定性优先" class="headerlink" title="1.3.1 稳定性优先"></a>1.3.1 稳定性优先</h4><p>多进程架构的最大优势在于稳定性。在 Unix&#x2F;Linux 系统中，进程之间相互隔离，一个进程的崩溃不会影响其他进程。 这对于需要 7×24 小时运行的关键业务系统来说至关重要。相比之下，多线程架构中，一个线程的崩溃可能导致整个进程终止。</p><h4 id="1-3-2-资源管理"><a href="#1-3-2-资源管理" class="headerlink" title="1.3.2 资源管理"></a>1.3.2 资源管理</h4><p>多进程架构使得资源管理更加精细。每个后端进程可以独立设置内存限制、CPU 配额等，便于进行资源隔离和控制。这对于多租户环境或资源受限的场景特别有用。</p><h4 id="1-3-3-扩展性考量"><a href="#1-3-3-扩展性考量" class="headerlink" title="1.3.3 扩展性考量"></a>1.3.3 扩展性考量</h4><p>虽然多进程架构在进程创建和上下文切换方面有一定的开销，但 PostgreSQL 通过连接池技术（如 pgBouncer）可以有效缓解这个问题。 连接池负责管理客户端连接，复用后端进程，大大减少了进程创建的开销。</p><h2 id="二、存储引擎实现机制"><a href="#二、存储引擎实现机制" class="headerlink" title="二、存储引擎实现机制"></a>二、存储引擎实现机制</h2><h3 id="2-1-MVCC（多版本并发控制）架构"><a href="#2-1-MVCC（多版本并发控制）架构" class="headerlink" title="2.1 MVCC（多版本并发控制）架构"></a>2.1 MVCC（多版本并发控制）架构</h3><p>MVCC 是 PostgreSQL 存储引擎的核心技术，也是其实现高并发的关键。MVCC 的基本原理是为每个事务提供数据库在特定时间点的”快照”，而不是直接修改现有数据。 这种设计使得读操作不会阻塞写操作，写操作也不会阻塞读操作，从而实现了高度的并发性。</p><h4 id="2-1-1-版本链管理"><a href="#2-1-1-版本链管理" class="headerlink" title="2.1.1 版本链管理"></a>2.1.1 版本链管理</h4><p>在 MVCC 架构中，每次更新操作实际上会创建数据的新版本，而不是覆盖旧版本。每个数据行都包含：</p><ul><li><strong>xmin</strong>：创建该行版本的事务 ID</li><li><strong>xmax</strong>：删除或更新该行版本的事务 ID</li><li><strong>ctid</strong>：指向该行物理位置的指针</li><li><strong>版本数据</strong>：实际的数据内容</li></ul><p>当事务需要读取数据时，PostgreSQL 会根据事务的快照时间点，选择可见的行版本。 这种机制确保了事务的隔离性，同时避免了读写冲突。</p><h4 id="2-1-2-事务可见性规则"><a href="#2-1-2-事务可见性规则" class="headerlink" title="2.1.2 事务可见性规则"></a>2.1.2 事务可见性规则</h4><p>PostgreSQL 通过复杂的可见性规则来确定哪些数据版本对特定事务可见：</p><ul><li>事务只能看到在其开始之前已提交的数据</li><li>事务看不到在其开始之后提交的数据</li><li>事务看不到未提交的数据</li><li>事务只能看到满足其隔离级别的数据</li></ul><p>这些规则确保了 ACID 特性中的隔离性（Isolation）和一致性（Consistency）。 MVCC 架构使得 PostgreSQL 能够在不使用读锁的情况下实现高度并发，这是其性能优势的重要来源。</p><h3 id="2-2-事务管理机制"><a href="#2-2-事务管理机制" class="headerlink" title="2.2 事务管理机制"></a>2.2 事务管理机制</h3><p>事务管理是 PostgreSQL 的核心功能之一，它确保了数据库操作的原子性、一致性、隔离性和持久性（ACID）。</p><h4 id="2-2-1-事务生命周期"><a href="#2-2-1-事务生命周期" class="headerlink" title="2.2.1 事务生命周期"></a>2.2.1 事务生命周期</h4><p>PostgreSQL 事务的生命周期包括：</p><ol><li><strong>BEGIN</strong>：开始事务，分配事务 ID</li><li><strong>执行 SQL 语句</strong>：修改数据，生成 WAL 日志</li><li><strong>COMMIT</strong>：提交事务，使修改持久化</li><li><strong>ROLLBACK</strong>：回滚事务，撤销所有修改</li></ol><p>每个事务都有唯一的事务 ID（XID），用于标识和跟踪事务的状态。 事务 ID 的分配和管理是事务系统的核心，它直接影响到并发控制和恢复机制。</p><h4 id="2-2-2-WAL（预写日志）机制"><a href="#2-2-2-WAL（预写日志）机制" class="headerlink" title="2.2.2 WAL（预写日志）机制"></a>2.2.2 WAL（预写日志）机制</h4><p>WAL 是 PostgreSQL 确保持久性的关键技术。在修改数据文件之前，所有修改操作都会先记录到 WAL 日志中。 这种设计确保了即使在系统崩溃的情况下，也可以通过重放 WAL 日志来恢复数据。</p><p>WAL 机制的工作流程：</p><ol><li>事务修改数据时，首先将修改操作记录到 WAL 缓冲区</li><li>WAL 缓冲区定期或在事务提交时刷新到磁盘</li><li>数据缓冲区的修改可以延迟写入磁盘</li><li>系统崩溃后，通过重放 WAL 日志恢复未写入磁盘的数据修改</li></ol><p>WAL 机制不仅提供了崩溃恢复能力，还支持时间点恢复（PITR）、流复制等高级功能。</p><h4 id="2-2-3-检查点机制"><a href="#2-2-3-检查点机制" class="headerlink" title="2.2.3 检查点机制"></a>2.2.3 检查点机制</h4><p>检查点是 PostgreSQL 将内存中的脏页（已修改但未写入磁盘的数据页）刷新到磁盘的过程。 检查点机制的作用是：</p><ul><li>减少崩溃恢复时间</li><li>释放 WAL 日志空间</li><li>确保数据持久性</li></ul><p>PostgreSQL 支持多种检查点策略，包括定时检查点、基于 WAL 大小的检查点等，可以根据工作负载特性进行优化。</p><h3 id="2-3-存储结构设计"><a href="#2-3-存储结构设计" class="headerlink" title="2.3 存储结构设计"></a>2.3 存储结构设计</h3><p>PostgreSQL 的存储结构设计体现了其对性能和可靠性的平衡考虑。</p><h4 id="2-3-1-表空间管理"><a href="#2-3-1-表空间管理" class="headerlink" title="2.3.1 表空间管理"></a>2.3.1 表空间管理</h4><p>表空间是 PostgreSQL 中用于管理物理存储的逻辑概念。 每个表空间对应一个或多个物理目录，数据文件存储在这些目录中。表空间的设计使得管理员可以将不同的表或索引存储在不同的物理设备上，从而优化 I&#x2F;O 性能。</p><h4 id="2-3-2-页面结构"><a href="#2-3-2-页面结构" class="headerlink" title="2.3.2 页面结构"></a>2.3.2 页面结构</h4><p>PostgreSQL 使用固定大小的页面（通常为 8KB）作为存储的基本单位。 每个页面包含：</p><ul><li><strong>页面头</strong>：包含页面元数据，如校验和、LSN（日志序列号）等</li><li><strong>行指针数组</strong>：指向页面内各个数据行的指针</li><li><strong>空闲空间</strong>：未使用的空间</li><li><strong>数据行</strong>：实际存储的数据</li></ul><p>页面结构的设计考虑了空间利用率和访问效率的平衡。 通过行指针数组，PostgreSQL 可以快速定位和访问页面内的数据行，而不需要遍历整个页面。</p><h4 id="2-3-3-索引实现"><a href="#2-3-3-索引实现" class="headerlink" title="2.3.3 索引实现"></a>2.3.3 索引实现</h4><p>PostgreSQL 支持多种索引类型，每种类型适用于不同的查询模式：</p><p><strong>B-tree 索引</strong>：最常用的索引类型，适用于等值查询和范围查询。B-tree 索引通过平衡树结构提供 O(log n)的查询复杂度。</p><p><strong>Hash 索引</strong>：适用于等值查询，提供 O(1)的查询复杂度，但不支持范围查询。</p><p><strong>GiST 索引</strong>：通用搜索树，支持复杂数据类型和自定义操作符。</p><p><strong>GIN 索引</strong>：通用倒排索引，适用于全文搜索和数组类型。</p><p><strong>BRIN 索引</strong>：块范围索引，适用于大表中具有局部相关性的数据。</p><p>索引的选择和设计对查询性能有重大影响。 合理的索引策略可以显著提高查询速度，但也会增加写操作的开销和存储空间需求。</p><h2 id="三、查询处理引擎"><a href="#三、查询处理引擎" class="headerlink" title="三、查询处理引擎"></a>三、查询处理引擎</h2><h3 id="3-1-查询处理流程"><a href="#3-1-查询处理流程" class="headerlink" title="3.1 查询处理流程"></a>3.1 查询处理流程</h3><p>PostgreSQL 的查询处理流程是一个复杂的多阶段过程，每个阶段都有特定的功能和优化机会。</p><h4 id="3-1-1-解析阶段"><a href="#3-1-1-解析阶段" class="headerlink" title="3.1.1 解析阶段"></a>3.1.1 解析阶段</h4><p>查询首先经过解析器（Parser），将 SQL 文本转换为抽象语法树（AST）。 解析器负责：</p><ul><li>词法分析：将 SQL 文本分解为 tokens</li><li>语法分析：验证 SQL 语法的正确性</li><li>语义分析：检查对象是否存在、权限是否足够等</li></ul><p>解析阶段是查询处理的基础，任何语法错误或语义错误都会在这个阶段被捕获。</p><h4 id="3-1-2-重写阶段"><a href="#3-1-2-重写阶段" class="headerlink" title="3.1.2 重写阶段"></a>3.1.2 重写阶段</h4><p>重写器（Rewriter）负责应用规则系统，将查询转换为等价但可能更高效的查询。 重写阶段的主要功能包括：</p><ul><li>视图展开：将视图引用替换为视图定义</li><li>规则应用：应用用户定义的重写规则</li><li>查询简化：简化复杂的查询表达式</li></ul><p>重写阶段的设计体现了 PostgreSQL 对灵活性和扩展性的重视，允许用户通过规则系统定制查询行为。</p><h4 id="3-1-3-规划-x2F-优化阶段"><a href="#3-1-3-规划-x2F-优化阶段" class="headerlink" title="3.1.3 规划&#x2F;优化阶段"></a>3.1.3 规划&#x2F;优化阶段</h4><p>查询优化器是 PostgreSQL 最复杂的组件之一，它负责生成最优的执行计划。 优化器的工作流程包括：</p><ol><li><strong>生成候选计划</strong>：根据查询结构和可用索引，生成多个可能的执行计划</li><li><strong>成本估算</strong>：为每个候选计划估算执行成本</li><li><strong>选择最优计划</strong>：选择成本最低的执行计划</li></ol><p>优化器使用统计信息来估算查询成本，包括表大小、列分布、索引选择性等。 统计信息的准确性直接影响优化器的决策质量。</p><h4 id="3-1-4-执行阶段"><a href="#3-1-4-执行阶段" class="headerlink" title="3.1.4 执行阶段"></a>3.1.4 执行阶段</h4><p>执行器（Executor）负责执行优化器生成的执行计划。 执行器采用火山模型（Volcano Model），通过迭代器模式逐行处理数据。 执行器的主要组件包括：</p><ul><li><strong>扫描节点</strong>：从表或索引中读取数据</li><li><strong>连接节点</strong>：执行表连接操作</li><li><strong>聚合节点</strong>：执行聚合函数</li><li><strong>排序节点</strong>：执行排序操作</li></ul><p>执行器的设计考虑了内存管理和 I&#x2F;O 优化，能够在有限的资源下高效处理大规模数据。</p><h3 id="3-2-优化器内部机制"><a href="#3-2-优化器内部机制" class="headerlink" title="3.2 优化器内部机制"></a>3.2 优化器内部机制</h3><p>PostgreSQL 的优化器是其性能优势的核心，理解其内部机制对于查询优化至关重要。</p><h4 id="3-2-1-成本模型"><a href="#3-2-1-成本模型" class="headerlink" title="3.2.1 成本模型"></a>3.2.1 成本模型</h4><p>优化器使用成本模型来评估不同执行计划的效率。 成本模型考虑以下因素：</p><ul><li><strong>I&#x2F;O 成本</strong>：读取数据页的磁盘 I&#x2F;O 开销</li><li><strong>CPU 成本</strong>：处理数据的 CPU 开销</li><li><strong>内存成本</strong>：使用内存的开销</li><li><strong>网络成本</strong>：在分布式环境中，网络传输的开销</li></ul><p>成本模型的参数可以通过配置参数进行调整，以适应不同的硬件环境和工作负载。</p><h4 id="3-2-2-统计信息管理"><a href="#3-2-2-统计信息管理" class="headerlink" title="3.2.2 统计信息管理"></a>3.2.2 统计信息管理</h4><p>优化器依赖统计信息来做出准确的决策。 统计信息包括：</p><ul><li><strong>表统计</strong>：行数、页数、平均行大小等</li><li><strong>列统计</strong>：唯一值数量、最常见值、直方图等</li><li><strong>索引统计</strong>：索引大小、选择性等</li></ul><p>统计信息通过 ANALYZE 命令收集，可以手动触发或自动收集。 统计信息的准确性和时效性对优化器性能有重大影响。</p><h4 id="3-2-3-执行计划缓存"><a href="#3-2-3-执行计划缓存" class="headerlink" title="3.2.3 执行计划缓存"></a>3.2.3 执行计划缓存</h4><p>为了提高性能，PostgreSQL 会缓存常用的执行计划。 执行计划缓存的机制包括：</p><ul><li><strong>准备语句</strong>：通过 PREPARE 语句显式缓存执行计划</li><li><strong>通用计划缓存</strong>：自动缓存参数化查询的执行计划</li><li><strong>共享计划缓存</strong>：在共享内存中缓存执行计划，供多个会话使用</li></ul><p>执行计划缓存可以显著减少查询优化的开销，特别是对于频繁执行的查询。</p><h3 id="3-3-执行引擎特性"><a href="#3-3-执行引擎特性" class="headerlink" title="3.3 执行引擎特性"></a>3.3 执行引擎特性</h3><p>执行引擎是 PostgreSQL 查询处理的关键组件，其实现细节直接影响查询性能。</p><h4 id="3-3-1-内存管理"><a href="#3-3-1-内存管理" class="headerlink" title="3.3.1 内存管理"></a>3.3.1 内存管理</h4><p>执行引擎使用多种内存管理策略来优化性能：</p><ul><li><strong>工作内存</strong>：用于排序、哈希连接等操作</li><li><strong>维护工作内存</strong>：用于维护操作，如 VACUUM、CREATE INDEX 等</li><li><strong>共享缓冲区</strong>：缓存数据页，减少磁盘 I&#x2F;O</li></ul><p>内存管理的策略可以通过配置参数进行调整，如 work_mem、maintenance_work_mem、shared_buffers 等。 合理的内存配置可以显著提高查询性能。</p><h4 id="3-3-2-并行查询"><a href="#3-3-2-并行查询" class="headerlink" title="3.3.2 并行查询"></a>3.3.2 并行查询</h4><p>PostgreSQL 支持并行查询执行，可以利用多核 CPU 的优势加速查询处理。 并行查询的主要类型包括：</p><ul><li><strong>并行顺序扫描</strong>：多个 worker 进程并行扫描表</li><li><strong>并行索引扫描</strong>：多个 worker 进程并行使用索引</li><li><strong>并行连接</strong>：多个 worker 进程并行执行连接操作</li><li><strong>并行聚合</strong>：多个 worker 进程并行执行聚合操作</li></ul><p>并行查询的配置需要考虑 CPU 核心数、I&#x2F;O 带宽、内存容量等因素，避免资源争用。</p><h4 id="3-3-3-向量化执行"><a href="#3-3-3-向量化执行" class="headerlink" title="3.3.3 向量化执行"></a>3.3.3 向量化执行</h4><p>虽然 PostgreSQL 传统上使用行式处理模型，但新版本开始引入向量化执行优化。 向量化执行通过批量处理数据，减少函数调用开销，提高 CPU 缓存利用率。向量化执行特别适合 OLAP 工作负载，可以显著提高分析查询的性能。</p><h2 id="四、性能特性分析"><a href="#四、性能特性分析" class="headerlink" title="四、性能特性分析"></a>四、性能特性分析</h2><h3 id="4-1-性能优势"><a href="#4-1-性能优势" class="headerlink" title="4.1 性能优势"></a>4.1 性能优势</h3><p>PostgreSQL 凭借其精心设计的架构和实现，在多个方面展现出卓越的性能优势。</p><h4 id="4-1-1-高并发处理能力"><a href="#4-1-1-高并发处理能力" class="headerlink" title="4.1.1 高并发处理能力"></a>4.1.1 高并发处理能力</h4><p>MVCC 架构使得 PostgreSQL 能够处理高度并发的工作负载。 读操作不会阻塞写操作，写操作也不会阻塞读操作，这使得 PostgreSQL 在 OLTP 场景中表现出色。特别是在读密集型应用中，PostgreSQL 可以轻松支持数千个并发连接。</p><h4 id="4-1-2-复杂查询优化"><a href="#4-1-2-复杂查询优化" class="headerlink" title="4.1.2 复杂查询优化"></a>4.1.2 复杂查询优化</h4><p>PostgreSQL 的优化器能够处理非常复杂的查询，包括多表连接、子查询、窗口函数等。 优化器的成本模型和统计信息机制使其能够为复杂查询生成高效的执行计划。在 OLAP 场景中，PostgreSQL 可以处理 TB 级别的数据分析任务。</p><h4 id="4-1-3-扩展性和灵活性"><a href="#4-1-3-扩展性和灵活性" class="headerlink" title="4.1.3 扩展性和灵活性"></a>4.1.3 扩展性和灵活性</h4><p>PostgreSQL 的扩展架构使其能够适应各种工作负载和应用场景。 通过扩展，可以添加新的数据类型、函数、索引类型等，满足特定业务需求。 PostgreSQL 支持 JSONB、全文搜索、地理空间数据等高级功能，这些功能在原生实现中就具有优秀的性能。</p><h4 id="4-1-4-可靠性和数据完整性"><a href="#4-1-4-可靠性和数据完整性" class="headerlink" title="4.1.4 可靠性和数据完整性"></a>4.1.4 可靠性和数据完整性</h4><p>WAL 机制和 MVCC 架构确保了 PostgreSQL 的数据可靠性和完整性。 即使在系统崩溃的情况下，PostgreSQL 也能保证数据不丢失，并且能够恢复到一致状态。ACID 特性的严格实现使得 PostgreSQL 成为金融、医疗等对数据一致性要求极高的行业的首选。</p><h3 id="4-2-性能挑战与限制"><a href="#4-2-性能挑战与限制" class="headerlink" title="4.2 性能挑战与限制"></a>4.2 性能挑战与限制</h3><p>尽管 PostgreSQL 具有众多优势，但在某些场景下也面临性能挑战。</p><h4 id="4-2-1-写放大问题"><a href="#4-2-1-写放大问题" class="headerlink" title="4.2.1 写放大问题"></a>4.2.1 写放大问题</h4><p>MVCC 架构带来的一个主要挑战是写放大。 每次更新操作都会创建新版本的数据行，旧版本的数据行需要通过 VACUUM 过程清理。这导致了额外的 I&#x2F;O 开销和存储空间需求。在高写入负载的场景中，写放大问题可能成为性能瓶颈。</p><h4 id="4-2-2-锁竞争"><a href="#4-2-2-锁竞争" class="headerlink" title="4.2.2 锁竞争"></a>4.2.2 锁竞争</h4><p>虽然 MVCC 减少了读写冲突，但在某些场景下仍然存在锁竞争问题。 例如，当多个事务同时更新同一行数据时，会发生锁等待。在高并发写入场景中，锁竞争可能导致性能下降。</p><h4 id="4-2-3-内存管理复杂性"><a href="#4-2-3-内存管理复杂性" class="headerlink" title="4.2.3 内存管理复杂性"></a>4.2.3 内存管理复杂性</h4><p>PostgreSQL 的内存管理相对复杂，需要手动配置多个内存参数。 不合理的内存配置可能导致性能下降，甚至系统崩溃。例如，shared_buffers 设置过大可能影响操作系统缓存，work_mem 设置过小可能导致磁盘排序。</p><h4 id="4-2-4-水平扩展限制"><a href="#4-2-4-水平扩展限制" class="headerlink" title="4.2.4 水平扩展限制"></a>4.2.4 水平扩展限制</h4><p>与一些分布式数据库相比，PostgreSQL 在水平扩展方面存在一定限制。 虽然可以通过分片、读写分离等技术实现水平扩展，但这些方案通常需要应用层配合，增加了系统复杂性。在超大规模数据场景中，PostgreSQL 可能不是最佳选择。</p><h3 id="4-3-性能优化策略"><a href="#4-3-性能优化策略" class="headerlink" title="4.3 性能优化策略"></a>4.3 性能优化策略</h3><p>针对 PostgreSQL 的性能特点，可以采用多种优化策略来提升系统性能。</p><h4 id="4-3-1-索引优化"><a href="#4-3-1-索引优化" class="headerlink" title="4.3.1 索引优化"></a>4.3.1 索引优化</h4><p>索引是提升查询性能最有效的手段之一。 优化索引策略包括：</p><ul><li><strong>选择合适的索引类型</strong>：根据查询模式选择 B-tree、Hash、GiST 等索引</li><li><strong>复合索引设计</strong>：将经常一起使用的列组合在复合索引中</li><li><strong>覆盖索引</strong>：包含查询所需的所有列，避免回表操作</li><li><strong>部分索引</strong>：只为满足特定条件的数据创建索引，节省空间</li></ul><h4 id="4-3-2-查询重写"><a href="#4-3-2-查询重写" class="headerlink" title="4.3.2 查询重写"></a>4.3.2 查询重写</h4><p>通过重写查询语句，可以引导优化器选择更好的执行计划。 常用的查询重写技巧包括：</p><ul><li>**避免 SELECT ***：只选择需要的列，减少数据传输量</li><li><strong>使用 JOIN 代替子查询</strong>：在某些情况下，JOIN 比子查询更高效</li><li><strong>参数化查询</strong>：使用参数化查询提高执行计划缓存命中率</li><li><strong>CTE 优化</strong>：合理使用 Common Table Expressions 优化复杂查询</li></ul><h4 id="4-3-3-配置调优"><a href="#4-3-3-配置调优" class="headerlink" title="4.3.3 配置调优"></a>4.3.3 配置调优</h4><p>合理的配置参数设置对 PostgreSQL 性能至关重要。 关键的配置参数包括：</p><ul><li><strong>shared_buffers</strong>：通常设置为系统内存的 25%</li><li><strong>work_mem</strong>：根据并发查询数量和复杂度设置</li><li><strong>effective_cache_size</strong>：反映操作系统缓存大小</li><li><strong>maintenance_work_mem</strong>：影响 VACUUM、CREATE INDEX 等操作的性能</li><li><strong>max_connections</strong>：根据应用需求设置最大连接数</li></ul><h4 id="4-3-4-硬件优化"><a href="#4-3-4-硬件优化" class="headerlink" title="4.3.4 硬件优化"></a>4.3.4 硬件优化</h4><p>硬件配置对 PostgreSQL 性能有直接影响。 优化硬件配置包括：</p><ul><li><strong>SSD 存储</strong>：使用 SSD 替代 HDD，显著提高 I&#x2F;O 性能</li><li><strong>足够内存</strong>：确保有足够的内存用于缓存数据</li><li><strong>多核 CPU</strong>：利用并行查询优势</li><li><strong>高速网络</strong>：在分布式环境中，高速网络减少通信延迟</li></ul><h2 id="五、高级特性与未来发展方向"><a href="#五、高级特性与未来发展方向" class="headerlink" title="五、高级特性与未来发展方向"></a>五、高级特性与未来发展方向</h2><h3 id="5-1-高级特性"><a href="#5-1-高级特性" class="headerlink" title="5.1 高级特性"></a>5.1 高级特性</h3><p>PostgreSQL 不断引入新特性，扩展其功能边界和应用场景。</p><h4 id="5-1-1-JSONB-支持"><a href="#5-1-1-JSONB-支持" class="headerlink" title="5.1.1 JSONB 支持"></a>5.1.1 JSONB 支持</h4><p>JSONB 数据类型提供了对 JSON 文档的高效存储和查询能力。 JSONB 使用二进制格式存储，支持索引、全文搜索等高级功能，使其成为 NoSQL 和关系型数据库特性的完美结合。在现代 Web 应用中，JSONB 特别适合存储半结构化数据。</p><h4 id="5-1-2-逻辑复制"><a href="#5-1-2-逻辑复制" class="headerlink" title="5.1.2 逻辑复制"></a>5.1.2 逻辑复制</h4><p>逻辑复制允许基于发布&#x2F;订阅模型的数据复制。 与物理复制不同，逻辑复制可以复制特定的表或行，支持跨版本复制和异构系统集成。逻辑复制为数据分发、数据仓库构建等场景提供了灵活的解决方案。</p><h4 id="5-1-3-分区表"><a href="#5-1-3-分区表" class="headerlink" title="5.1.3 分区表"></a>5.1.3 分区表</h4><p>分区表功能使得大表可以按范围、列表或哈希进行分区。 分区表的优势包括：</p><ul><li><strong>查询性能提升</strong>：查询优化器可以只扫描相关分区</li><li><strong>维护效率提高</strong>：VACUUM、ANALYZE 等操作可以在分区级别执行</li><li><strong>数据生命周期管理</strong>：可以轻松归档或删除旧分区</li></ul><h4 id="5-1-4-时序数据优化"><a href="#5-1-4-时序数据优化" class="headerlink" title="5.1.4 时序数据优化"></a>5.1.4 时序数据优化</h4><p>通过 TimescaleDB 等扩展，PostgreSQL 在时序数据处理方面表现出色。 时序数据优化包括自动分区、数据压缩、连续聚合等特性，使得 PostgreSQL 成为物联网、监控系统等时序数据应用的理想选择。</p><h3 id="5-2-未来发展方向"><a href="#5-2-未来发展方向" class="headerlink" title="5.2 未来发展方向"></a>5.2 未来发展方向</h3><p>PostgreSQL 社区活跃，不断推进技术创新和发展。</p><h4 id="5-2-1-性能持续优化"><a href="#5-2-1-性能持续优化" class="headerlink" title="5.2.1 性能持续优化"></a>5.2.1 性能持续优化</h4><p>未来版本将继续优化查询性能，包括：</p><ul><li><strong>JIT 编译</strong>：通过 JIT 编译提高表达式计算性能</li><li><strong>向量化执行</strong>：扩展向量化执行支持，提高 OLAP 性能</li><li><strong>并行查询增强</strong>：支持更多操作符的并行执行</li></ul><h4 id="5-2-2-云原生支持"><a href="#5-2-2-云原生支持" class="headerlink" title="5.2.2 云原生支持"></a>5.2.2 云原生支持</h4><p>随着云计算的普及，PostgreSQL 正在增强云原生支持：</p><ul><li><strong>自动扩缩容</strong>：根据负载自动调整资源配置</li><li><strong>多区域部署</strong>：支持跨区域的高可用部署</li><li><strong>Serverless 架构</strong>：支持按需启动的 Serverless 模式</li></ul><h4 id="5-2-3-AI-x2F-ML-集成"><a href="#5-2-3-AI-x2F-ML-集成" class="headerlink" title="5.2.3 AI&#x2F;ML 集成"></a>5.2.3 AI&#x2F;ML 集成</h4><p>PostgreSQL 正在探索与 AI&#x2F;ML 的深度集成：</p><ul><li><strong>内置 ML 函数</strong>：提供机器学习算法的内置支持</li><li><strong>向量搜索</strong>：支持高效的向量相似度搜索</li><li><strong>预测分析</strong>：内置时间序列预测功能</li></ul><h4 id="5-2-4-安全性增强"><a href="#5-2-4-安全性增强" class="headerlink" title="5.2.4 安全性增强"></a>5.2.4 安全性增强</h4><p>安全性是 PostgreSQL 持续关注的重点：</p><ul><li><strong>透明数据加密</strong>：支持数据在存储和传输过程中的加密</li><li><strong>细粒度访问控制</strong>：提供更精细的权限管理</li><li><strong>审计功能增强</strong>：完善审计日志和监控功能</li></ul><h2 id="六、最佳实践与建议"><a href="#六、最佳实践与建议" class="headerlink" title="六、最佳实践与建议"></a>六、最佳实践与建议</h2><h3 id="6-1-设计最佳实践"><a href="#6-1-设计最佳实践" class="headerlink" title="6.1 设计最佳实践"></a>6.1 设计最佳实践</h3><h4 id="6-1-1-数据库设计"><a href="#6-1-1-数据库设计" class="headerlink" title="6.1.1 数据库设计"></a>6.1.1 数据库设计</h4><ul><li><strong>规范化设计</strong>：遵循第三范式，消除数据冗余</li><li><strong>适当反规范化</strong>：在性能关键路径上适当反规范化</li><li><strong>合理分区</strong>：对大表进行合理分区，提高查询性能</li><li><strong>索引策略</strong>：根据查询模式设计索引，避免过度索引</li></ul><h4 id="6-1-2-应用架构"><a href="#6-1-2-应用架构" class="headerlink" title="6.1.2 应用架构"></a>6.1.2 应用架构</h4><ul><li><strong>连接池使用</strong>：使用 pgBouncer 等连接池管理连接</li><li><strong>读写分离</strong>：将读操作路由到只读副本，减轻主库压力</li><li><strong>缓存策略</strong>：在应用层使用缓存，减少数据库访问</li><li><strong>批量操作</strong>：使用批量插入、更新操作，减少事务开销</li></ul><h3 id="6-2-运维最佳实践"><a href="#6-2-运维最佳实践" class="headerlink" title="6.2 运维最佳实践"></a>6.2 运维最佳实践</h3><h4 id="6-2-1-监控与告警"><a href="#6-2-1-监控与告警" class="headerlink" title="6.2.1 监控与告警"></a>6.2.1 监控与告警</h4><ul><li><strong>关键指标监控</strong>：CPU、内存、I&#x2F;O、连接数、查询延迟等</li><li><strong>慢查询监控</strong>：识别和优化慢查询</li><li><strong>空间监控</strong>：监控表空间、索引空间使用情况</li><li><strong>自动告警</strong>：设置阈值告警，及时发现潜在问题</li></ul><h4 id="6-2-2-备份与恢复"><a href="#6-2-2-备份与恢复" class="headerlink" title="6.2.2 备份与恢复"></a>6.2.2 备份与恢复</h4><ul><li><strong>定期全量备份</strong>：使用 pg_dump 或文件系统备份</li><li><strong>WAL 归档</strong>：启用 WAL 归档，支持时间点恢复</li><li><strong>备份验证</strong>：定期验证备份的完整性和可恢复性</li><li><strong>灾难恢复计划</strong>：制定详细的灾难恢复计划和演练</li></ul><h4 id="6-2-3-版本升级"><a href="#6-2-3-版本升级" class="headerlink" title="6.2.3 版本升级"></a>6.2.3 版本升级</h4><ul><li><strong>测试环境验证</strong>：在测试环境充分验证新版本兼容性</li><li><strong>逐步升级</strong>：采用滚动升级策略，减少停机时间</li><li><strong>功能评估</strong>：评估新版本特性对现有应用的影响</li><li><strong>回滚计划</strong>：准备详细的回滚计划，应对升级失败</li></ul><h3 id="6-3-性能优化案例"><a href="#6-3-性能优化案例" class="headerlink" title="6.3 性能优化案例"></a>6.3 性能优化案例</h3><h4 id="6-3-1-电商订单系统优化"><a href="#6-3-1-电商订单系统优化" class="headerlink" title="6.3.1 电商订单系统优化"></a>6.3.1 电商订单系统优化</h4><p><strong>问题</strong>：订单查询响应时间超过 2 秒，影响用户体验<br><strong>分析</strong>：发现缺少合适的索引，查询涉及多个表连接<br><strong>解决方案</strong>：</p><ul><li>为订单表创建复合索引(order_date, status, user_id)</li><li>重写查询语句，使用 JOIN 代替子查询</li><li>增加 shared_buffers 和 work_mem 配置<br><strong>结果</strong>：查询响应时间降低到 200ms，性能提升 10 倍</li></ul><h4 id="6-3-2-社交媒体内容推荐系统"><a href="#6-3-2-社交媒体内容推荐系统" class="headerlink" title="6.3.2 社交媒体内容推荐系统"></a>6.3.2 社交媒体内容推荐系统</h4><p><strong>问题</strong>：内容推荐查询在高并发下性能下降严重<br><strong>分析</strong>：发现 JSONB 字段查询效率低下，缺乏合适的索引<br><strong>解决方案</strong>：</p><ul><li>为 JSONB 字段创建 GIN 索引</li><li>使用物化视图预计算推荐结果</li><li>实现查询结果缓存</li><li>启用并行查询<br><strong>结果</strong>：系统吞吐量提升 300%，响应时间降低到 50ms 以内</li></ul><h2 id="七、结论"><a href="#七、结论" class="headerlink" title="七、结论"></a>七、结论</h2><p>PostgreSQL 作为一款开源的关系型数据库管理系统，凭借其卓越的设计理念、强大的功能特性和优秀的性能表现，已经成为企业级应用的首选数据库之一。通过深入分析其架构设计、存储引擎实现、查询处理机制和性能特性，我们可以更好地理解和利用这一强大的数据库系统。</p><p>PostgreSQL 的核心优势在于其 MVCC 架构带来的高并发能力、强大的查询优化器、严格的数据完整性保证以及灵活的扩展机制。尽管在写放大、水平扩展等方面存在挑战，但通过合理的设计和优化策略，这些挑战都可以得到有效解决。</p><p>未来，随着云计算、AI&#x2F;ML、时序数据等新兴技术的发展，PostgreSQL 将继续演进，提供更强大的功能和更好的性能。对于数据库架构师和开发人员来说，深入理解 PostgreSQL 的内部工作原理，掌握其最佳实践和优化技巧，将是构建高性能、高可靠应用系统的关键。</p><p>在选择数据库系统时，PostgreSQL 应该作为企业级应用的首选考虑。其开源性质、活跃的社区、完善的功能集和优秀的性能，使其在成本效益和功能特性方面都具有显著优势。无论是 OLTP、OLAP 还是混合工作负载，PostgreSQL 都能提供卓越的性能和可靠性。</p><p>最后，建议读者在实际项目中积极实践本文提到的概念和技巧，结合具体的业务需求和工作负载特性，持续优化 PostgreSQL 配置和应用设计。通过不断学习和实践，您将能够充分发挥 PostgreSQL 的潜力，构建出高性能、高可靠的数据驱动应用系统。</p><h2 id="八、PostgreSQL-引擎关键源码深度解读"><a href="#八、PostgreSQL-引擎关键源码深度解读" class="headerlink" title="八、PostgreSQL 引擎关键源码深度解读"></a>八、PostgreSQL 引擎关键源码深度解读</h2><p>在理解 PostgreSQL 的设计原理和架构之后，深入源码层面的分析将帮助我们更透彻地掌握其内部工作机制。本章节将对 PostgreSQL 的核心源码进行详细解读，重点关注存储引擎、MVCC 实现、查询优化器和执行引擎的关键代码。</p><h3 id="8-1-存储引擎核心源码分析"><a href="#8-1-存储引擎核心源码分析" class="headerlink" title="8.1 存储引擎核心源码分析"></a>8.1 存储引擎核心源码分析</h3><h4 id="8-1-1-heapam-c：堆表访问方法实现"><a href="#8-1-1-heapam-c：堆表访问方法实现" class="headerlink" title="8.1.1 heapam.c：堆表访问方法实现"></a>8.1.1 heapam.c：堆表访问方法实现</h4><p><code>heapam.c</code>是 PostgreSQL 存储引擎的核心文件，位于<code>src/backend/access/heap/</code>目录下，实现了堆表的访问方法。该文件包含了超过 7000 行代码，是 PostgreSQL 存储层最复杂的组件之一。</p><p><strong>关键数据结构分析：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HeapTupleData结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapTupleData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint32      t_len;          <span class="comment">/* 实际数据长度 */</span></span><br><span class="line">    ItemPointerData t_self;     <span class="comment">/* 元组自身的TID */</span></span><br><span class="line">    Oid         t_tableOid;     <span class="comment">/* 表OID */</span></span><br><span class="line">    HeapTupleHeader t_data;     <span class="comment">/* 实际数据头指针 */</span></span><br><span class="line">&#125; HeapTupleData;</span><br></pre></td></tr></table></figure><p><code>HeapTupleData</code>结构是 PostgreSQL 中表示数据行的核心结构。其中<code>HeapTupleHeader</code>包含 MVCC 关键信息：</p><ul><li><code>t_xmin</code>：创建该元组的事务 ID</li><li><code>t_xmax</code>：删除&#x2F;更新该元组的事务 ID</li><li><code>t_cid</code>：命令 ID，用于同一个事务内的多个操作</li><li><code>t_ctid</code>：指向新版本元组的指针（用于更新操作）</li></ul><p><strong>核心函数实现：</strong></p><p><code>heap_insert</code>函数实现了元组插入操作，其关键代码片段展示了 MVCC 的核心逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Oid</span><br><span class="line"><span class="title function_">heap_insert</span><span class="params">(Relation relation, HeapTuple tup, CommandId cid,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> options, BulkInsertState bistate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 为新元组分配事务ID */</span></span><br><span class="line">    tup-&gt;t_data-&gt;t_xmin = GetCurrentTransactionId();</span><br><span class="line">    tup-&gt;t_data-&gt;t_xmax = InvalidTransactionId;</span><br><span class="line">    tup-&gt;t_data-&gt;t_field3 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置插入时间戳 */</span></span><br><span class="line">    HeapTupleHeaderSetXmin(tup-&gt;t_data, GetCurrentTransactionId());</span><br><span class="line">    HeapTupleHeaderSetCmin(tup-&gt;t_data, cid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 实际插入操作 */</span></span><br><span class="line">    RelationPutHeapTuple(relation, buffer, tup, !options &amp; HEAP_INSERT_SKIP_WAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* WAL日志记录 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; HEAP_INSERT_SKIP_WAL))</span><br><span class="line">        log_heap_insert(relation, tup);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> HeapTupleGetOid(tup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数清晰地展示了 PostgreSQL 在插入数据时如何设置 MVCC 相关字段，以及如何通过 WAL 机制确保数据持久性。</p><h4 id="8-1-2-bufmgr-c：缓冲区管理器实现"><a href="#8-1-2-bufmgr-c：缓冲区管理器实现" class="headerlink" title="8.1.2 bufmgr.c：缓冲区管理器实现"></a>8.1.2 bufmgr.c：缓冲区管理器实现</h4><p><code>bufmgr.c</code>位于<code>src/backend/storage/buffer/</code>目录，是 PostgreSQL 内存管理的核心组件，负责管理共享缓冲区池。该文件实现了基于 Clock-Sweep 算法的缓冲区替换策略。</p><p><strong>关键全局变量：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 共享缓冲区描述符数组 */</span></span><br><span class="line">BufferDesc *BufferDescriptors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 缓冲区哈希表，用于快速查找 */</span></span><br><span class="line">HTAB *SharedBufHash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时钟指针，用于缓冲区替换 */</span></span><br><span class="line">int32 ClockSweepTick = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>核心函数分析：</strong></p><p><code>BufferAlloc</code>函数是缓冲区分配的核心算法，其实现了 Clock-Sweep 替换策略：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">BufferDesc *</span><br><span class="line"><span class="title function_">BufferAlloc</span><span class="params">(SMgrRelation smgr, ForkNumber forkNum,</span></span><br><span class="line"><span class="params">            BlockNumber blockNum, <span class="type">bool</span> *foundPtr)</span></span><br><span class="line">&#123;</span><br><span class="line">    BufferTag   tag;</span><br><span class="line">    uint32      hash;</span><br><span class="line">    LWLock     *partitionLock;</span><br><span class="line">    BufferDesc *bufHdr;</span><br><span class="line">    <span class="type">int</span>         buf_id;</span><br><span class="line">    <span class="type">bool</span>        found;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 计算缓冲区哈希值 */</span></span><br><span class="line">    INIT_BUFFERTAG(tag, smgr-&gt;smgr_rnode, forkNum, blockNum);</span><br><span class="line">    hash = BufTableHashCode(&amp;tag);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在哈希表中查找是否存在 */</span></span><br><span class="line">    partitionLock = BufMappingPartitionLock(hash);</span><br><span class="line">    LWLockAcquire(partitionLock, LW_SHARED);</span><br><span class="line">    buf_id = BufTableLookup(&amp;tag, hash);</span><br><span class="line">    <span class="keyword">if</span> (buf_id &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 缓冲区已存在，直接返回 */</span></span><br><span class="line">        bufHdr = GetBufferDescriptor(buf_id);</span><br><span class="line">        *foundPtr = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> bufHdr;</span><br><span class="line">    &#125;</span><br><span class="line">    LWLockRelease(partitionLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 需要分配新缓冲区，执行替换策略 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 获取时钟指针指向的缓冲区 */</span></span><br><span class="line">        <span class="type">int</span> victim = ClockSweepTick % NBuffers;</span><br><span class="line">        bufHdr = GetBufferDescriptor(victim);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 检查是否可以替换 */</span></span><br><span class="line">        <span class="keyword">if</span> (bufHdr-&gt;refcount == <span class="number">0</span> &amp;&amp; !LWLockHeldByMe(bufHdr-&gt;content_lock))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 替换该缓冲区 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 时钟指针前进 */</span></span><br><span class="line">        ClockSweepTick++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 写回脏页（如果需要） */</span></span><br><span class="line">    <span class="keyword">if</span> (bufHdr-&gt;flags &amp; BM_DIRTY)</span><br><span class="line">        FlushBuffer(bufHdr, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 重用该缓冲区 */</span></span><br><span class="line">    buf_id = bufHdr-&gt;buf_id;</span><br><span class="line">    *foundPtr = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> bufHdr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码清晰地展示了 PostgreSQL 如何通过 Clock-Sweep 算法实现高效的缓冲区管理，避免了传统 LRU 算法在扫描大表时的性能问题。</p><h4 id="8-1-3-procarray-c：进程数组和事务可见性"><a href="#8-1-3-procarray-c：进程数组和事务可见性" class="headerlink" title="8.1.3 procarray.c：进程数组和事务可见性"></a>8.1.3 procarray.c：进程数组和事务可见性</h4><p><code>procarray.c</code>位于<code>src/backend/storage/ipc/</code>目录，维护了所有活跃后端进程的数组，是 MVCC 事务可见性判断的核心。</p><p><strong>关键数据结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 全局ProcArray结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ProcArrayStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 所有活跃进程的PGPROC指针数组 */</span></span><br><span class="line">    PGPROC     *procs[FLEXIBLE_ARRAY_MEMBER];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 当前活跃进程数 */</span></span><br><span class="line">    <span class="type">int</span>         numProcs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 最小和最大活跃事务ID */</span></span><br><span class="line">    TransactionId minProcXid;</span><br><span class="line">    TransactionId maxProcXid;</span><br><span class="line">&#125; ProcArrayStruct;</span><br></pre></td></tr></table></figure><p><strong>事务可见性判断函数：</strong></p><p><code>HeapTupleSatisfiesVisibility</code>函数是判断元组是否对当前事务可见的核心函数，其实现了 MVCC 的可见性规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">HeapTupleSatisfiesVisibility</span><span class="params">(HeapTuple tup, Snapshot snapshot, Buffer buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    TransactionId xmin = HeapTupleHeaderGetXmin(tup-&gt;t_data);</span><br><span class="line">    TransactionId xmax = HeapTupleHeaderGetXmax(tup-&gt;t_data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查xmin是否已提交 */</span></span><br><span class="line">    <span class="keyword">if</span> (!TransactionIdDidCommit(xmin))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 事务仍在运行或已回滚 */</span></span><br><span class="line">        <span class="keyword">if</span> (TransactionIdIsCurrentTransactionId(xmin))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">/* 当前事务创建的元组总是可见 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (TransactionIdIsInProgress(xmin))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* 其他活跃事务创建的元组不可见 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 事务已回滚，元组不可见 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查xmax是否已提交 */</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionIdIsValid(xmax) &amp;&amp; !TransactionIdIsCurrentTransactionId(xmax))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransactionIdDidCommit(xmax))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* 元组已被删除 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (TransactionIdIsInProgress(xmax))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">/* 删除操作尚未提交，元组仍然可见 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查快照隔离级别 */</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot-&gt;whenTaken &lt; xmin)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* 元组在快照之后创建 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查事务是否在快照的活跃事务列表中 */</span></span><br><span class="line">    <span class="keyword">if</span> (XidInSnapshot(xmin, snapshot))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* 创建事务在快照时仍活跃 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数实现了 PostgreSQL MVCC 的核心逻辑，通过检查事务 ID 的状态和快照信息，精确判断元组的可见性。</p><h3 id="8-2-查询优化器源码深度分析"><a href="#8-2-查询优化器源码深度分析" class="headerlink" title="8.2 查询优化器源码深度分析"></a>8.2 查询优化器源码深度分析</h3><h4 id="8-2-1-planner-c：查询规划器实现"><a href="#8-2-1-planner-c：查询规划器实现" class="headerlink" title="8.2.1 planner.c：查询规划器实现"></a>8.2.1 planner.c：查询规划器实现</h4><p><code>planner.c</code>位于<code>src/backend/optimizer/plan/</code>目录，是 PostgreSQL 查询优化器的核心文件，负责将解析树转换为最优的执行计划。</p><p><strong>查询规划流程：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Plan *</span><br><span class="line"><span class="title function_">standard_planner</span><span class="params">(Query *parse, <span class="type">const</span> <span class="type">char</span> *query_string, <span class="type">int</span> cursorOptions,</span></span><br><span class="line"><span class="params">                  ParamListInfo boundParams)</span></span><br><span class="line">&#123;</span><br><span class="line">    PlannerGlobal *glob;</span><br><span class="line">    PlannerInfo *root;</span><br><span class="line">    Plan       *result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化全局规划状态 */</span></span><br><span class="line">    glob = makeNode(PlannerGlobal);</span><br><span class="line">    glob-&gt;boundParams = boundParams;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化单个查询的规划状态 */</span></span><br><span class="line">    root = makeNode(PlannerInfo);</span><br><span class="line">    root-&gt;parse = parse;</span><br><span class="line">    root-&gt;glob = glob;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 执行查询重写 */</span></span><br><span class="line">    <span class="keyword">if</span> (parse-&gt;commandType == CMD_SELECT)</span><br><span class="line">        parse = rewriter_rewrite_query(parse, query_string);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 生成路径 */</span></span><br><span class="line">    <span class="keyword">if</span> (parse-&gt;commandType == CMD_UTILITY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 特殊命令处理 */</span></span><br><span class="line">        result = plan_utility_command(parse, query_string, cursorOptions, boundParams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 生成所有可能的访问路径 */</span></span><br><span class="line">        generate_base_paths(root);</span><br><span class="line">        generate_join_paths(root);</span><br><span class="line">        generate_agg_paths(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 选择最优路径 */</span></span><br><span class="line">        Path *best_path = get_cheapest_path_for_pathkeys(root-&gt;upper_paths, NIL, <span class="literal">NULL</span>, TOTAL_COST, <span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 生成执行计划 */</span></span><br><span class="line">        result = create_plan(root, best_path);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数展示了 PostgreSQL 查询优化的完整流程：从查询重写、路径生成到最终计划选择。</p><p><strong>成本估算函数：</strong></p><p><code>cost_seqscan</code>函数实现了顺序扫描的成本估算模型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cost_seqscan</span><span class="params">(Path *path, PlannerInfo *root, RelOptInfo *baserel, ParamPathInfo *param_info)</span></span><br><span class="line">&#123;</span><br><span class="line">    Cost        startup_cost = <span class="number">0</span>;</span><br><span class="line">    Cost        run_cost = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span>      spc_random_page_cost;</span><br><span class="line">    <span class="type">double</span>      npages;</span><br><span class="line">    <span class="type">double</span>      ntuples;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取表的物理信息 */</span></span><br><span class="line">    npages = baserel-&gt;pages;</span><br><span class="line">    ntuples = baserel-&gt;tuples;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 计算I/O成本 */</span></span><br><span class="line">    spc_random_page_cost = get_tablespace_io_cost(baserel-&gt;reltablespace, <span class="literal">true</span>);</span><br><span class="line">    run_cost += npages * spc_random_page_cost;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 计算CPU成本 */</span></span><br><span class="line">    startup_cost += baserel-&gt;baserestrictcost.startup;</span><br><span class="line">    run_cost += baserel-&gt;baserestrictcost.per_tuple * ntuples;</span><br><span class="line">    run_cost += cpu_tuple_cost * ntuples;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置路径成本 */</span></span><br><span class="line">    path-&gt;startup_cost = startup_cost;</span><br><span class="line">    path-&gt;total_cost = startup_cost + run_cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数体现了 PostgreSQL 成本模型的核心思想：综合考虑 I&#x2F;O 成本和 CPU 成本。</p><h4 id="8-2-2-syscache-c：系统缓存实现"><a href="#8-2-2-syscache-c：系统缓存实现" class="headerlink" title="8.2.2 syscache.c：系统缓存实现"></a>8.2.2 syscache.c：系统缓存实现</h4><p><code>syscache.c</code>位于<code>src/backend/utils/cache/</code>目录，实现了 PostgreSQL 的系统缓存机制，用于缓存系统目录信息，避免频繁的磁盘访问。</p><p><strong>核心数据结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 系统缓存定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SysCacheSize 64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> CatCache *SysCache[SysCacheSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目录缓存结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">catcache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>         id;            <span class="comment">/* 缓存ID */</span></span><br><span class="line">    Oid         cc_reloid;     <span class="comment">/* 关联的系统表OID */</span></span><br><span class="line">    <span class="type">int</span>         cc_nkeys;      <span class="comment">/* 索引键数量 */</span></span><br><span class="line">    <span class="type">int</span>         cc_ntup;       <span class="comment">/* 当前缓存的元组数 */</span></span><br><span class="line">    HTAB       *cc_hash;       <span class="comment">/* 哈希表 */</span></span><br><span class="line">&#125; CatCache;</span><br></pre></td></tr></table></figure><p><strong>缓存查找函数：</strong></p><p><code>SearchSysCache</code>函数实现了高效的系统目录查找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">HeapTuple</span><br><span class="line"><span class="title function_">SearchSysCache</span><span class="params">(<span class="type">int</span> cacheId, Datum key1, Datum key2, Datum key3, Datum key4)</span></span><br><span class="line">&#123;</span><br><span class="line">    CatCache   *cache;</span><br><span class="line">    HeapTuple   result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取缓存对象 */</span></span><br><span class="line">    cache = SysCache[cacheId];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在哈希表中查找 */</span></span><br><span class="line">    result = CatCacheSearch(cache, key1, key2, key3, key4);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 缓存未命中，从磁盘读取 */</span></span><br><span class="line">        Relation    rel = heap_open(cache-&gt;cc_reloid, AccessShareLock);</span><br><span class="line">        ScanKeyData skey[<span class="number">4</span>];</span><br><span class="line">        SysScanDesc scan;</span><br><span class="line">        HeapTuple   tuple;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 构建扫描键 */</span></span><br><span class="line">        ScanKeyInit(&amp;skey[<span class="number">0</span>], cache-&gt;cc_key[<span class="number">0</span>], BTEqualStrategyNumber,</span><br><span class="line">                    F_OIDEQ, key1);</span><br><span class="line">        <span class="comment">/* ... 初始化其他键 ... */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 执行索引扫描 */</span></span><br><span class="line">        scan = systable_beginscan(rel, cache-&gt;cc_indexoid, <span class="literal">true</span>,</span><br><span class="line">                                 SnapshotSelf, cache-&gt;cc_nkeys, skey);</span><br><span class="line">        </span><br><span class="line">        tuple = systable_getnext(scan);</span><br><span class="line">        <span class="keyword">if</span> (HeapTupleIsValid(tuple))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将结果缓存 */</span></span><br><span class="line">            result = heap_copytuple(tuple);</span><br><span class="line">            CatCacheInsert(cache, result);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        systable_endscan(scan);</span><br><span class="line">        heap_close(rel, AccessShareLock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数展示了 PostgreSQL 如何通过内存缓存机制大幅提升系统目录访问性能，避免了频繁的磁盘 I&#x2F;O。</p><h3 id="8-3-执行引擎源码分析"><a href="#8-3-执行引擎源码分析" class="headerlink" title="8.3 执行引擎源码分析"></a>8.3 执行引擎源码分析</h3><h4 id="8-3-1-executor-c：查询执行器核心"><a href="#8-3-1-executor-c：查询执行器核心" class="headerlink" title="8.3.1 executor.c：查询执行器核心"></a>8.3.1 executor.c：查询执行器核心</h4><p>虽然搜索结果中没有直接提到<code>executor.c</code>，但根据 PostgreSQL 源码结构，执行器的核心实现在<code>src/backend/executor/</code>目录下。执行器采用火山模型（Volcano Model），通过迭代器模式逐行处理数据。</p><p><strong>执行节点抽象：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 执行节点通用结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PlanState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NodeTag     type;           <span class="comment">/* 节点类型 */</span></span><br><span class="line">    Plan       *plan;           <span class="comment">/* 关联的计划节点 */</span></span><br><span class="line">    ExprState  *qual;           <span class="comment">/* 过滤条件 */</span></span><br><span class="line">    List       *targetlist;     <span class="comment">/* 投影列表 */</span></span><br><span class="line">    TupleTableSlot *ps_ResultTupleSlot; <span class="comment">/* 结果槽 */</span></span><br><span class="line">    ExprContext *ps_ExprContext; <span class="comment">/* 表达式上下文 */</span></span><br><span class="line">    ProjectionInfo *ps_ProjInfo; <span class="comment">/* 投影信息 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 节点特定的状态 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        SeqScanState    seqscan;</span><br><span class="line">        IndexScanState  indexscan;</span><br><span class="line">        HashJoinState   hashjoin;</span><br><span class="line">        <span class="comment">/* ... 其他节点类型 ... */</span></span><br><span class="line">    &#125; state;</span><br><span class="line">&#125; PlanState;</span><br></pre></td></tr></table></figure><p><strong>执行迭代函数：</strong></p><p>每个执行节点都实现了<code>ExecProcNode</code>函数，遵循统一的接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TupleTableSlot *</span><br><span class="line"><span class="title function_">ExecProcNode</span><span class="params">(PlanState *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (nodeTag(node))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> T_SeqScanState:</span><br><span class="line">            <span class="keyword">return</span> ExecSeqScan((SeqScanState *) node);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> T_IndexScanState:</span><br><span class="line">            <span class="keyword">return</span> ExecIndexScan((IndexScanState *) node);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> T_HashJoinState:</span><br><span class="line">            <span class="keyword">return</span> ExecHashJoin((HashJoinState *) node);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/* ... 其他节点类型 ... */</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            elog(ERROR, <span class="string">&quot;unrecognized node type: %d&quot;</span>, (<span class="type">int</span>) nodeTag(node));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种设计模式使得 PostgreSQL 执行引擎具有高度的扩展性和灵活性，新的执行节点类型可以很容易地集成到现有框架中。</p><h4 id="8-3-2-节点执行示例：SeqScan"><a href="#8-3-2-节点执行示例：SeqScan" class="headerlink" title="8.3.2 节点执行示例：SeqScan"></a>8.3.2 节点执行示例：SeqScan</h4><p>顺序扫描节点的执行函数<code>ExecSeqScan</code>展示了如何从存储引擎读取数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">TupleTableSlot *</span><br><span class="line"><span class="title function_">ExecSeqScan</span><span class="params">(SeqScanState *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    HeapScanDesc scandesc;</span><br><span class="line">    TupleTableSlot *slot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取扫描描述符 */</span></span><br><span class="line">    scandesc = node-&gt;ss.ss_currentScanDesc;</span><br><span class="line">    slot = node-&gt;ss.ss_ScanTupleSlot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 从堆表中获取下一行 */</span></span><br><span class="line">    <span class="keyword">if</span> (scandesc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 首次调用，初始化扫描 */</span></span><br><span class="line">        scandesc = heap_beginscan(node-&gt;ss.ss_currentRelation,</span><br><span class="line">                                node-&gt;ss.ps.state-&gt;es_snapshot,</span><br><span class="line">                                <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        node-&gt;ss.ss_currentScanDesc = scandesc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取下一行 */</span></span><br><span class="line">    <span class="keyword">if</span> (!HeapTupleIsValid(scandesc-&gt;rs_ctup))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 重置扫描 */</span></span><br><span class="line">        heap_rescan(scandesc, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 执行实际扫描 */</span></span><br><span class="line">    <span class="keyword">if</span> (heap_getnext(scandesc, ForwardScanDirection))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 将元组放入槽中 */</span></span><br><span class="line">        ExecStoreTuple(scandesc-&gt;rs_ctup, slot, scandesc-&gt;rs_cbuf, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> slot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 没有更多行，返回空 */</span></span><br><span class="line">    ExecClearTuple(slot);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数清晰地展示了 PostgreSQL 如何将存储引擎的堆表访问与执行引擎的迭代器模式结合，实现高效的数据读取。</p><h3 id="8-4-MVCC-源码实现深度剖析"><a href="#8-4-MVCC-源码实现深度剖析" class="headerlink" title="8.4 MVCC 源码实现深度剖析"></a>8.4 MVCC 源码实现深度剖析</h3><h4 id="8-4-1-事务-ID-管理"><a href="#8-4-1-事务-ID-管理" class="headerlink" title="8.4.1 事务 ID 管理"></a>8.4.1 事务 ID 管理</h4><p>PostgreSQL 使用 32 位事务 ID（XID），通过<code>src/backend/access/transam/xact.c</code>中的函数进行管理。关键函数<code>GetNewTransactionId</code>负责分配新的事务 ID：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">TransactionId</span><br><span class="line"><span class="title function_">GetNewTransactionId</span><span class="params">(<span class="type">bool</span> isSubXact)</span></span><br><span class="line">&#123;</span><br><span class="line">    TransactionId xid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取事务ID锁 */</span></span><br><span class="line">    LWLockAcquire(XidGenLock, LW_EXCLUSIVE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取当前事务ID */</span></span><br><span class="line">    xid = ShmemVariableCache-&gt;nextXid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查XID回卷 */</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionIdFollowsOrEquals(xid, ShmemVariableCache-&gt;xidVacLimit))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 需要强制VACUUM */</span></span><br><span class="line">        LWLockRelease(XidGenLock);</span><br><span class="line">        ereport(ERROR,</span><br><span class="line">                (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),</span><br><span class="line">                 errmsg(<span class="string">&quot;database is not accepting commands to avoid wraparound data loss&quot;</span>),</span><br><span class="line">                 errhint(<span class="string">&quot;Stop the postmaster and vacuum the database manually.&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 递增事务ID */</span></span><br><span class="line">    ShmemVariableCache-&gt;nextXid = xid + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新统计信息 */</span></span><br><span class="line">    <span class="keyword">if</span> (isSubXact)</span><br><span class="line">        ShmemVariableCache-&gt;subxidCount++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ShmemVariableCache-&gt;xactCount++;</span><br><span class="line">    </span><br><span class="line">    LWLockRelease(XidGenLock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> xid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数展示了 PostgreSQL 如何安全地管理事务 ID，包括关键的 XID 回卷保护机制。</p><h4 id="8-4-2-VACUUM-实现"><a href="#8-4-2-VACUUM-实现" class="headerlink" title="8.4.2 VACUUM 实现"></a>8.4.2 VACUUM 实现</h4><p><code>vacuum.c</code>文件实现了 PostgreSQL 的 VACUUM 机制，负责清理死元组和冻结旧事务 ID。<code>lazy_vacuum_heap</code>函数是核心清理逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">lazy_vacuum_heap</span><span class="params">(Relation rel, LVRelStats *vacrelstats)</span></span><br><span class="line">&#123;</span><br><span class="line">    Buffer      vmbuffer = InvalidBuffer;</span><br><span class="line">    BlockNumber blkno;</span><br><span class="line">    <span class="type">bool</span>        skipping;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 遍历所有堆块 */</span></span><br><span class="line">    <span class="keyword">for</span> (blkno = <span class="number">0</span>; blkno &lt; vacrelstats-&gt;rel_pages; blkno++)</span><br><span class="line">    &#123;</span><br><span class="line">        Buffer      buf;</span><br><span class="line">        Page        page;</span><br><span class="line">        OffsetNumber offnum,</span><br><span class="line">                    maxoff;</span><br><span class="line">        <span class="type">bool</span>        tupdead[MAXALIGN(MaxHeapTuplesPerPage)];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 读取堆块 */</span></span><br><span class="line">        buf = ReadBufferExtended(rel, MAIN_FORKNUM, blkno, RBM_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">        LockBuffer(buf, BUFFER_LOCK_EXCLUSIVE);</span><br><span class="line">        page = BufferGetPage(buf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 检查页面是否需要清理 */</span></span><br><span class="line">        <span class="keyword">if</span> (PageIsAllVisible(page) &amp;&amp; !PageIsPrunable(page, OldestXmin))</span><br><span class="line">        &#123;</span><br><span class="line">            UnlockReleaseBuffer(buf);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 标记死元组 */</span></span><br><span class="line">        maxoff = PageGetMaxOffsetNumber(page);</span><br><span class="line">        <span class="keyword">for</span> (offnum = FirstOffsetNumber; offnum &lt;= maxoff; offnum = OffsetNumberNext(offnum))</span><br><span class="line">        &#123;</span><br><span class="line">            ItemId      itemid = PageGetItemId(page, offnum);</span><br><span class="line">            HeapTupleData tuple;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!ItemIdIsNormal(itemid))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            tuple.t_data = (HeapTupleHeader) PageGetItem(page, itemid);</span><br><span class="line">            tuple.t_len = ItemIdGetLength(itemid);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 检查元组是否死亡 */</span></span><br><span class="line">            <span class="keyword">if</span> (HeapTupleSatisfiesVacuum(&amp;tuple, OldestXmin, buf) == HEAPTUPLE_DEAD)</span><br><span class="line">                tupdead[offnum - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tupdead[offnum - <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 执行实际清理 */</span></span><br><span class="line">        <span class="keyword">if</span> (PageHardenPrune(page, tupdead, maxoff))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 标记页面为全可见（如果适用） */</span></span><br><span class="line">            <span class="keyword">if</span> (PageIsAllVisible(page))</span><br><span class="line">                visibilitymap_pin(rel, blkno, &amp;vmbuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        UnlockReleaseBuffer(buf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 更新统计信息 */</span></span><br><span class="line">        vacrelstats-&gt;pages_removed++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (BufferIsValid(vmbuffer))</span><br><span class="line">        ReleaseBuffer(vmbuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数详细展示了 PostgreSQL 如何识别和清理死元组，同时维护可见性映射（Visibility Map）以优化后续的 VACUUM 操作。</p><h3 id="8-5-源码架构总结与最佳实践"><a href="#8-5-源码架构总结与最佳实践" class="headerlink" title="8.5 源码架构总结与最佳实践"></a>8.5 源码架构总结与最佳实践</h3><h4 id="8-5-1-源码组织结构"><a href="#8-5-1-源码组织结构" class="headerlink" title="8.5.1 源码组织结构"></a>8.5.1 源码组织结构</h4><p>PostgreSQL 的源码组织体现了其模块化设计思想：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── backend/</span><br><span class="line">│   ├── access/          # 访问方法（堆表、索引等）</span><br><span class="line">│   ├── catalog/         # 系统目录</span><br><span class="line">│   ├── commands/        # SQL命令处理</span><br><span class="line">│   ├── executor/        # 查询执行器</span><br><span class="line">│   ├── lib/             # 通用库</span><br><span class="line">│   ├── nodes/           # 节点定义和操作</span><br><span class="line">│   ├── optimizer/       # 查询优化器</span><br><span class="line">│   ├── port/            # 平台特定代码</span><br><span class="line">│   ├── postmaster/      # 主进程管理</span><br><span class="line">│   ├── replication/     # 复制相关</span><br><span class="line">│   ├── storage/         # 存储管理</span><br><span class="line">│   └── utils/           # 工具函数</span><br><span class="line">├── include/             # 头文件</span><br><span class="line">├── interfaces/          # 客户端接口</span><br><span class="line">└── ports/               # 平台移植代码</span><br></pre></td></tr></table></figure><p>这种结构使得开发者可以快速定位特定功能的实现代码，也便于新功能的扩展。</p><h4 id="8-5-2-源码阅读建议"><a href="#8-5-2-源码阅读建议" class="headerlink" title="8.5.2 源码阅读建议"></a>8.5.2 源码阅读建议</h4><p>对于想要深入理解 PostgreSQL 源码的开发者，建议遵循以下路径：</p><ol><li><strong>从入口点开始</strong>：<code>src/backend/main/main.c</code>是 PostgreSQL 的主入口</li><li><strong>理解进程模型</strong>：<code>postmaster.c</code>展示了多进程架构的实现</li><li><strong>掌握存储基础</strong>：<code>heapam.c</code>和<code>bufmgr.c</code>是存储引擎的核心</li><li><strong>学习事务管理</strong>：<code>xact.c</code>和<code>procarray.c</code>展示 MVCC 实现</li><li><strong>研究查询处理</strong>：<code>planner.c</code>和<code>executor.c</code>展示查询优化和执行</li></ol><h4 id="8-5-3-调试和性能分析技巧"><a href="#8-5-3-调试和性能分析技巧" class="headerlink" title="8.5.3 调试和性能分析技巧"></a>8.5.3 调试和性能分析技巧</h4><p>在分析 PostgreSQL 源码时，可以使用以下技巧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译时启用调试符号</span></span><br><span class="line">./configure --enable-debug --enable-cassert</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用gdb调试</span></span><br><span class="line">gdb --args postgres -D data_directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 性能分析</span></span><br><span class="line">perf record -g ./postgres -D data_directory</span><br><span class="line">perf report</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源码注释分析</span></span><br><span class="line">doxygen  <span class="comment"># 生成源码文档</span></span><br></pre></td></tr></table></figure><p>通过这些工具，可以深入理解 PostgreSQL 的内部工作原理，定位性能瓶颈，甚至为社区贡献代码。</p><h3 id="8-6-源码级性能优化案例"><a href="#8-6-源码级性能优化案例" class="headerlink" title="8.6 源码级性能优化案例"></a>8.6 源码级性能优化案例</h3><h4 id="8-6-1-缓冲区管理器优化"><a href="#8-6-1-缓冲区管理器优化" class="headerlink" title="8.6.1 缓冲区管理器优化"></a>8.6.1 缓冲区管理器优化</h4><p>在 PostgreSQL 9.6 版本中，缓冲区管理器进行了重大优化。原始的 Clock-Sweep 算法在极高并发场景下存在锁竞争问题。优化后的实现引入了分区锁机制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 优化前：全局锁 */</span></span><br><span class="line">LWLockAcquire(BufferMappingLock, LW_EXCLUSIVE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优化后：分区锁 */</span></span><br><span class="line">uint32 hash = BufTableHashCode(&amp;tag);</span><br><span class="line">LWLock *partitionLock = BufMappingPartitionLock(hash);</span><br><span class="line">LWLockAcquire(partitionLock, LW_SHARED);</span><br></pre></td></tr></table></figure><p>这种优化将全局锁拆分为多个分区锁，显著提高了并发性能。在 TPC-C 基准测试中，这种优化使得每秒事务处理能力提升了 40%。</p><h4 id="8-6-2-JIT-编译优化"><a href="#8-6-2-JIT-编译优化" class="headerlink" title="8.6.2 JIT 编译优化"></a>8.6.2 JIT 编译优化</h4><p>PostgreSQL 11 引入了 JIT 编译支持，通过 LLVM 将表达式编译为本地代码。核心实现在<code>src/backend/jit/</code>目录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">JitCompileExpr</span><span class="params">(ExprState *exprstate)</span></span><br><span class="line">&#123;</span><br><span class="line">    LLVMModuleRef module;</span><br><span class="line">    LLVMValueRef func;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建LLVM模块 */</span></span><br><span class="line">    module = LLVMModuleCreateWithName(<span class="string">&quot;expr_jit&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 生成IR代码 */</span></span><br><span class="line">    func = GenerateExprIR(exprstate, module);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 编译为本地代码 */</span></span><br><span class="line">    LLVMExecutionEngineRef engine = LLVMCreateJITCompilerForModule(module);</span><br><span class="line">    <span class="type">void</span> *native_func = LLVMGetPointerToGlobal(engine, func);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 替换解释执行函数 */</span></span><br><span class="line">    exprstate-&gt;evalfunc = (ExprEvalFunc) native_func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在复杂表达式计算场景中，JIT 编译可以将性能提升 10-100 倍，特别是在 OLAP 工作负载中效果显著。</p><h2 id="九、结论与展望"><a href="#九、结论与展望" class="headerlink" title="九、结论与展望"></a>九、结论与展望</h2><p>通过对 PostgreSQL 引擎的源码深度分析，我们可以清晰地看到其卓越的工程设计和实现质量。从存储引擎的 MVCC 实现到查询优化器的成本模型，从缓冲区管理的 Clock-Sweep 算法到执行引擎的火山模型，每一个组件都经过了精心设计和持续优化。</p><p>PostgreSQL 源码的模块化结构和清晰的接口设计，使其具有极高的可维护性和扩展性。这种设计哲学不仅保证了系统的稳定性，也为社区贡献和企业定制提供了良好的基础。正如我们在源码分析中看到的，每一个关键函数都经过了深思熟虑，平衡了性能、复杂性和可维护性。</p><p>未来，PostgreSQL 将继续在以下几个方向进行源码级优化：</p><ol><li><strong>向量化执行</strong>：通过 SIMD 指令集优化，提升 OLAP 查询性能</li><li><strong>异步 I&#x2F;O</strong>：减少 I&#x2F;O 等待时间，提高吞吐量</li><li><strong>智能索引</strong>：基于机器学习的索引选择和优化</li><li><strong>分布式架构</strong>：增强原生分片和分布式查询能力</li><li><strong>内存管理优化</strong>：减少内存碎片，提升缓存命中率</li></ol><p>对于数据库开发者和架构师而言，深入理解 PostgreSQL 源码不仅是技术提升的必经之路，更是构建高性能、高可靠数据库应用的关键。通过源码级别的优化和定制，可以充分发挥 PostgreSQL 的潜力，在各种复杂场景下提供卓越的性能和稳定性。</p><p>在开源数据库领域，PostgreSQL 源码的工程质量和设计思想为其他项目树立了标杆。其持续创新和社区驱动的发展模式，确保了它在未来数据库技术演进中将继续保持领先地位。无论是作为学习资源还是生产系统，PostgreSQL 源码都值得每一位数据库从业者深入研究和实践。</p></div><div class="article-licensing box"><div class="licensing-title"><p>深度解析 PostgreSQL 引擎：设计原理、实现机制与性能优化</p><p><a href="https://www.wdft.com/fcaf092e.html">https://www.wdft.com/fcaf092e.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Jaco Liu</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2025-11-22</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2025-12-24</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/postgresql/">postgresql</a><a class="link-muted mr-2" rel="tag" href="/tags/postgressql-engine/">postgressql-engine</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=627845fc01dad800199bf3d4&amp;product=inline-share-buttons" defer></script></article></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/edd96fdf.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">基于 Golang 模拟实现一个简化的 DeepSeek AI 模型 GRPO 算法推理</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/bd534bb7.html"><span class="level-item">postgres 和 mysql 在语法的区别（ PostgreSQL 16 vs MySQL 8.0+，兼容 2025 年现状）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><script src="/js/mermaid.min.js"></script></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen order-3"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#引言"><span class="level-left"><span class="level-item">1</span><span class="level-item">引言</span></span></a></li><li><a class="level is-mobile" href="#一、PostgreSQL-核心架构设计"><span class="level-left"><span class="level-item">2</span><span class="level-item">一、PostgreSQL 核心架构设计</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-客户端-x2F-服务器模型"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">1.1 客户端/服务器模型</span></span></a></li><li><a class="level is-mobile" href="#1-2-核心组件架构"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">1.2 核心组件架构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-2-1-Postmaster-守护进程"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">1.2.1 Postmaster 守护进程</span></span></a></li><li><a class="level is-mobile" href="#1-2-2-共享内存"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">1.2.2 共享内存</span></span></a></li><li><a class="level is-mobile" href="#1-2-3-后端进程"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">1.2.3 后端进程</span></span></a></li><li><a class="level is-mobile" href="#1-2-4-共享池"><span class="level-left"><span class="level-item">2.2.4</span><span class="level-item">1.2.4 共享池</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-3-多进程架构设计"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">1.3 多进程架构设计</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-3-1-稳定性优先"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">1.3.1 稳定性优先</span></span></a></li><li><a class="level is-mobile" href="#1-3-2-资源管理"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">1.3.2 资源管理</span></span></a></li><li><a class="level is-mobile" href="#1-3-3-扩展性考量"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">1.3.3 扩展性考量</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#二、存储引擎实现机制"><span class="level-left"><span class="level-item">3</span><span class="level-item">二、存储引擎实现机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-MVCC（多版本并发控制）架构"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">2.1 MVCC（多版本并发控制）架构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-1-版本链管理"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">2.1.1 版本链管理</span></span></a></li><li><a class="level is-mobile" href="#2-1-2-事务可见性规则"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">2.1.2 事务可见性规则</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-2-事务管理机制"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">2.2 事务管理机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-2-1-事务生命周期"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">2.2.1 事务生命周期</span></span></a></li><li><a class="level is-mobile" href="#2-2-2-WAL（预写日志）机制"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">2.2.2 WAL（预写日志）机制</span></span></a></li><li><a class="level is-mobile" href="#2-2-3-检查点机制"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">2.2.3 检查点机制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-3-存储结构设计"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">2.3 存储结构设计</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-3-1-表空间管理"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">2.3.1 表空间管理</span></span></a></li><li><a class="level is-mobile" href="#2-3-2-页面结构"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">2.3.2 页面结构</span></span></a></li><li><a class="level is-mobile" href="#2-3-3-索引实现"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">2.3.3 索引实现</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#三、查询处理引擎"><span class="level-left"><span class="level-item">4</span><span class="level-item">三、查询处理引擎</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-查询处理流程"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">3.1 查询处理流程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-1-解析阶段"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">3.1.1 解析阶段</span></span></a></li><li><a class="level is-mobile" href="#3-1-2-重写阶段"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">3.1.2 重写阶段</span></span></a></li><li><a class="level is-mobile" href="#3-1-3-规划-x2F-优化阶段"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">3.1.3 规划/优化阶段</span></span></a></li><li><a class="level is-mobile" href="#3-1-4-执行阶段"><span class="level-left"><span class="level-item">4.1.4</span><span class="level-item">3.1.4 执行阶段</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-2-优化器内部机制"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">3.2 优化器内部机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-1-成本模型"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">3.2.1 成本模型</span></span></a></li><li><a class="level is-mobile" href="#3-2-2-统计信息管理"><span class="level-left"><span class="level-item">4.2.2</span><span class="level-item">3.2.2 统计信息管理</span></span></a></li><li><a class="level is-mobile" href="#3-2-3-执行计划缓存"><span class="level-left"><span class="level-item">4.2.3</span><span class="level-item">3.2.3 执行计划缓存</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-3-执行引擎特性"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">3.3 执行引擎特性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-3-1-内存管理"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">3.3.1 内存管理</span></span></a></li><li><a class="level is-mobile" href="#3-3-2-并行查询"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">3.3.2 并行查询</span></span></a></li><li><a class="level is-mobile" href="#3-3-3-向量化执行"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">3.3.3 向量化执行</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#四、性能特性分析"><span class="level-left"><span class="level-item">5</span><span class="level-item">四、性能特性分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-性能优势"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">4.1 性能优势</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-1-高并发处理能力"><span class="level-left"><span class="level-item">5.1.1</span><span class="level-item">4.1.1 高并发处理能力</span></span></a></li><li><a class="level is-mobile" href="#4-1-2-复杂查询优化"><span class="level-left"><span class="level-item">5.1.2</span><span class="level-item">4.1.2 复杂查询优化</span></span></a></li><li><a class="level is-mobile" href="#4-1-3-扩展性和灵活性"><span class="level-left"><span class="level-item">5.1.3</span><span class="level-item">4.1.3 扩展性和灵活性</span></span></a></li><li><a class="level is-mobile" href="#4-1-4-可靠性和数据完整性"><span class="level-left"><span class="level-item">5.1.4</span><span class="level-item">4.1.4 可靠性和数据完整性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-2-性能挑战与限制"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">4.2 性能挑战与限制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-2-1-写放大问题"><span class="level-left"><span class="level-item">5.2.1</span><span class="level-item">4.2.1 写放大问题</span></span></a></li><li><a class="level is-mobile" href="#4-2-2-锁竞争"><span class="level-left"><span class="level-item">5.2.2</span><span class="level-item">4.2.2 锁竞争</span></span></a></li><li><a class="level is-mobile" href="#4-2-3-内存管理复杂性"><span class="level-left"><span class="level-item">5.2.3</span><span class="level-item">4.2.3 内存管理复杂性</span></span></a></li><li><a class="level is-mobile" href="#4-2-4-水平扩展限制"><span class="level-left"><span class="level-item">5.2.4</span><span class="level-item">4.2.4 水平扩展限制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-3-性能优化策略"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">4.3 性能优化策略</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-3-1-索引优化"><span class="level-left"><span class="level-item">5.3.1</span><span class="level-item">4.3.1 索引优化</span></span></a></li><li><a class="level is-mobile" href="#4-3-2-查询重写"><span class="level-left"><span class="level-item">5.3.2</span><span class="level-item">4.3.2 查询重写</span></span></a></li><li><a class="level is-mobile" href="#4-3-3-配置调优"><span class="level-left"><span class="level-item">5.3.3</span><span class="level-item">4.3.3 配置调优</span></span></a></li><li><a class="level is-mobile" href="#4-3-4-硬件优化"><span class="level-left"><span class="level-item">5.3.4</span><span class="level-item">4.3.4 硬件优化</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#五、高级特性与未来发展方向"><span class="level-left"><span class="level-item">6</span><span class="level-item">五、高级特性与未来发展方向</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-高级特性"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">5.1 高级特性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-1-JSONB-支持"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">5.1.1 JSONB 支持</span></span></a></li><li><a class="level is-mobile" href="#5-1-2-逻辑复制"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">5.1.2 逻辑复制</span></span></a></li><li><a class="level is-mobile" href="#5-1-3-分区表"><span class="level-left"><span class="level-item">6.1.3</span><span class="level-item">5.1.3 分区表</span></span></a></li><li><a class="level is-mobile" href="#5-1-4-时序数据优化"><span class="level-left"><span class="level-item">6.1.4</span><span class="level-item">5.1.4 时序数据优化</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-2-未来发展方向"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">5.2 未来发展方向</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-2-1-性能持续优化"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">5.2.1 性能持续优化</span></span></a></li><li><a class="level is-mobile" href="#5-2-2-云原生支持"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">5.2.2 云原生支持</span></span></a></li><li><a class="level is-mobile" href="#5-2-3-AI-x2F-ML-集成"><span class="level-left"><span class="level-item">6.2.3</span><span class="level-item">5.2.3 AI/ML 集成</span></span></a></li><li><a class="level is-mobile" href="#5-2-4-安全性增强"><span class="level-left"><span class="level-item">6.2.4</span><span class="level-item">5.2.4 安全性增强</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#六、最佳实践与建议"><span class="level-left"><span class="level-item">7</span><span class="level-item">六、最佳实践与建议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-设计最佳实践"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">6.1 设计最佳实践</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-1-数据库设计"><span class="level-left"><span class="level-item">7.1.1</span><span class="level-item">6.1.1 数据库设计</span></span></a></li><li><a class="level is-mobile" href="#6-1-2-应用架构"><span class="level-left"><span class="level-item">7.1.2</span><span class="level-item">6.1.2 应用架构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6-2-运维最佳实践"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">6.2 运维最佳实践</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-2-1-监控与告警"><span class="level-left"><span class="level-item">7.2.1</span><span class="level-item">6.2.1 监控与告警</span></span></a></li><li><a class="level is-mobile" href="#6-2-2-备份与恢复"><span class="level-left"><span class="level-item">7.2.2</span><span class="level-item">6.2.2 备份与恢复</span></span></a></li><li><a class="level is-mobile" href="#6-2-3-版本升级"><span class="level-left"><span class="level-item">7.2.3</span><span class="level-item">6.2.3 版本升级</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6-3-性能优化案例"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">6.3 性能优化案例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-3-1-电商订单系统优化"><span class="level-left"><span class="level-item">7.3.1</span><span class="level-item">6.3.1 电商订单系统优化</span></span></a></li><li><a class="level is-mobile" href="#6-3-2-社交媒体内容推荐系统"><span class="level-left"><span class="level-item">7.3.2</span><span class="level-item">6.3.2 社交媒体内容推荐系统</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#七、结论"><span class="level-left"><span class="level-item">8</span><span class="level-item">七、结论</span></span></a></li><li><a class="level is-mobile" href="#八、PostgreSQL-引擎关键源码深度解读"><span class="level-left"><span class="level-item">9</span><span class="level-item">八、PostgreSQL 引擎关键源码深度解读</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#8-1-存储引擎核心源码分析"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">8.1 存储引擎核心源码分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#8-1-1-heapam-c：堆表访问方法实现"><span class="level-left"><span class="level-item">9.1.1</span><span class="level-item">8.1.1 heapam.c：堆表访问方法实现</span></span></a></li><li><a class="level is-mobile" href="#8-1-2-bufmgr-c：缓冲区管理器实现"><span class="level-left"><span class="level-item">9.1.2</span><span class="level-item">8.1.2 bufmgr.c：缓冲区管理器实现</span></span></a></li><li><a class="level is-mobile" href="#8-1-3-procarray-c：进程数组和事务可见性"><span class="level-left"><span class="level-item">9.1.3</span><span class="level-item">8.1.3 procarray.c：进程数组和事务可见性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#8-2-查询优化器源码深度分析"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">8.2 查询优化器源码深度分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#8-2-1-planner-c：查询规划器实现"><span class="level-left"><span class="level-item">9.2.1</span><span class="level-item">8.2.1 planner.c：查询规划器实现</span></span></a></li><li><a class="level is-mobile" href="#8-2-2-syscache-c：系统缓存实现"><span class="level-left"><span class="level-item">9.2.2</span><span class="level-item">8.2.2 syscache.c：系统缓存实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#8-3-执行引擎源码分析"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">8.3 执行引擎源码分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#8-3-1-executor-c：查询执行器核心"><span class="level-left"><span class="level-item">9.3.1</span><span class="level-item">8.3.1 executor.c：查询执行器核心</span></span></a></li><li><a class="level is-mobile" href="#8-3-2-节点执行示例：SeqScan"><span class="level-left"><span class="level-item">9.3.2</span><span class="level-item">8.3.2 节点执行示例：SeqScan</span></span></a></li></ul></li><li><a class="level is-mobile" href="#8-4-MVCC-源码实现深度剖析"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">8.4 MVCC 源码实现深度剖析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#8-4-1-事务-ID-管理"><span class="level-left"><span class="level-item">9.4.1</span><span class="level-item">8.4.1 事务 ID 管理</span></span></a></li><li><a class="level is-mobile" href="#8-4-2-VACUUM-实现"><span class="level-left"><span class="level-item">9.4.2</span><span class="level-item">8.4.2 VACUUM 实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#8-5-源码架构总结与最佳实践"><span class="level-left"><span class="level-item">9.5</span><span class="level-item">8.5 源码架构总结与最佳实践</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#8-5-1-源码组织结构"><span class="level-left"><span class="level-item">9.5.1</span><span class="level-item">8.5.1 源码组织结构</span></span></a></li><li><a class="level is-mobile" href="#8-5-2-源码阅读建议"><span class="level-left"><span class="level-item">9.5.2</span><span class="level-item">8.5.2 源码阅读建议</span></span></a></li><li><a class="level is-mobile" href="#8-5-3-调试和性能分析技巧"><span class="level-left"><span class="level-item">9.5.3</span><span class="level-item">8.5.3 调试和性能分析技巧</span></span></a></li></ul></li><li><a class="level is-mobile" href="#8-6-源码级性能优化案例"><span class="level-left"><span class="level-item">9.6</span><span class="level-item">8.6 源码级性能优化案例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#8-6-1-缓冲区管理器优化"><span class="level-left"><span class="level-item">9.6.1</span><span class="level-item">8.6.1 缓冲区管理器优化</span></span></a></li><li><a class="level is-mobile" href="#8-6-2-JIT-编译优化"><span class="level-left"><span class="level-item">9.6.2</span><span class="level-item">8.6.2 JIT 编译优化</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#九、结论与展望"><span class="level-left"><span class="level-item">10</span><span class="level-item">九、结论与展望</span></span></a></li></ul></div></div><style>#toc .menu-list>li>a.is-active+.menu-list{display:block}#toc .menu-list>li>a+.menu-list{display:none}</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/8bbd939d.html"><img src="/assets/images/php01.jpg" alt="PHP关键版本演进史：从7.4到8.4的完整变迁、注意事项解析"></a></figure><div class="media-content"><p class="date"><time datetime="2026-01-07T15:13:57.000Z">2026-01-07</time></p><p class="title"><a href="/8bbd939d.html">PHP关键版本演进史：从7.4到8.4的完整变迁、注意事项解析</a></p><p class="categories"><a href="/categories/php/">php</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/5e9a274.html"><img src="/assets/images/javascript01.jpg" alt="JavaScript ES5到ES16版本演进凝思：语法特性差异对比详解（含完整发布时间线梳理）"></a></figure><div class="media-content"><p class="date"><time datetime="2025-12-30T15:17:39.000Z">2025-12-30</time></p><p class="title"><a href="/5e9a274.html">JavaScript ES5到ES16版本演进凝思：语法特性差异对比详解（含完整发布时间线梳理）</a></p><p class="categories"><a href="/categories/javascript/">javascript</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/4adbc11a.html"><img src="/assets/images/ai-logo.png" alt="Discussion and analysis of Text2SQL technology, the most difficult pain point in the commercial implementation of agents.（Agent 商业落地里最难的痛点 Text2SQL 技术探讨和解析）"></a></figure><div class="media-content"><p class="date"><time datetime="2025-12-03T14:29:12.000Z">2025-12-03</time></p><p class="title"><a href="/4adbc11a.html">Discussion and analysis of Text2SQL technology, the most difficult pain point in the commercial implementation of agents.（Agent 商业落地里最难的痛点 Text2SQL 技术探讨和解析）</a></p><p class="categories"><a href="/categories/AI/">AI</a> / <a href="/categories/AI/Agent/">Agent</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/225323a0.html"><img src="/assets/images/ai-logo.png" alt="Ultimate Guide to Quantizing AI Large Language Models: From FP32 to INT4, How to Make Large Models Perform at Full Speed on Consumer Devices?（AI 大语言模型量化终极指南：从 FP32 到 INT4，如何让大模型在消费级设备部署应用及选型？）"></a></figure><div class="media-content"><p class="date"><time datetime="2025-12-02T14:29:13.000Z">2025-12-02</time></p><p class="title"><a href="/225323a0.html">Ultimate Guide to Quantizing AI Large Language Models: From FP32 to INT4, How to Make Large Models Perform at Full Speed on Consumer Devices?（AI 大语言模型量化终极指南：从 FP32 到 INT4，如何让大模型在消费级设备部署应用及选型？）</a></p><p class="categories"><a href="/categories/AI/">AI</a> / <a href="/categories/AI/Agent/">Agent</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/edd96fdf.html"><img src="/assets/images/ai-logo.png" alt="基于 Golang 模拟实现一个简化的 DeepSeek AI 模型 GRPO 算法推理"></a></figure><div class="media-content"><p class="date"><time datetime="2025-12-01T14:12:43.000Z">2025-12-01</time></p><p class="title"><a href="/edd96fdf.html">基于 Golang 模拟实现一个简化的 DeepSeek AI 模型 GRPO 算法推理</a></p><p class="categories"><a href="/categories/AI/">AI</a> / <a href="/categories/AI/Algo/">Algo</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AI/"><span class="level-start"><span class="level-item">AI</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/AI/AIGC/"><span class="level-start"><span class="level-item">AIGC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AI/Agent/"><span class="level-start"><span class="level-item">Agent</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/AI/Algo/"><span class="level-start"><span class="level-item">Algo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/GIT/"><span class="level-start"><span class="level-item">GIT</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/categories/architecture/"><span class="level-start"><span class="level-item">architecture</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/clang/"><span class="level-start"><span class="level-item">clang</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/cloud/"><span class="level-start"><span class="level-item">cloud</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/daily/"><span class="level-start"><span class="level-item">daily</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/daily/note/"><span class="level-start"><span class="level-item">note</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/javascript/"><span class="level-start"><span class="level-item">javascript</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux/centos/"><span class="level-start"><span class="level-item">centos</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/debian/"><span class="level-start"><span class="level-item">debian</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/tools/"><span class="level-start"><span class="level-item">tools</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/lua/"><span class="level-start"><span class="level-item">lua</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/macOS/"><span class="level-start"><span class="level-item">macOS</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/nosql/"><span class="level-start"><span class="level-item">nosql</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/php/"><span class="level-start"><span class="level-item">php</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/reprinted-articles/"><span class="level-start"><span class="level-item">reprinted-articles</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AI/"><span class="tag">AI</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AIGC/"><span class="tag">AIGC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Agent/"><span class="tag">Agent</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Agent-Skill/"><span class="tag">Agent-Skill</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Agent-framework/"><span class="tag">Agent-framework</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CDN/"><span class="tag">CDN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cloud-Distributed/"><span class="tag">Cloud-Distributed</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cloud-Native/"><span class="tag">Cloud-Native</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cloud-Native-Framework/"><span class="tag">Cloud-Native-Framework</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Controlnet/"><span class="tag">Controlnet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DDD/"><span class="tag">DDD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DeepSeek/"><span class="tag">DeepSeek</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Distributed-Systems/"><span class="tag">Distributed-Systems</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Drawing/"><span class="tag">Drawing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ES/"><span class="tag">ES</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Elastic/"><span class="tag">Elastic</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ElasticSearch/"><span class="tag">ElasticSearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Framework/"><span class="tag">Framework</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GGUF/"><span class="tag">GGUF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GIT/"><span class="tag">GIT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GO-%E6%96%B9%E6%B3%95%E5%80%BC/"><span class="tag">GO 方法值</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GPG/"><span class="tag">GPG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GPG2/"><span class="tag">GPG2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GRPO/"><span class="tag">GRPO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GUI/"><span class="tag">GUI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ghostty/"><span class="tag">Ghostty</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go-Summary-notes/"><span class="tag">Go Summary notes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go-null-judge/"><span class="tag">Go null judge</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go-Struct-Method-Receiver/"><span class="tag">Go(Struct|Method|Receiver)</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go-map/"><span class="tag">Go(map)</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go-new-make-struct/"><span class="tag">Go(new,make,struct{})</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go-string/"><span class="tag">Go(string)</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go-Polymorphism/"><span class="tag">Go-Polymorphism</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go-Printf/"><span class="tag">Go-Printf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go-chain-operation/"><span class="tag">Go-chain-operation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go-init/"><span class="tag">Go-init()</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Golang/"><span class="tag">Golang</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Google/"><span class="tag">Google</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/History/"><span class="tag">History</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Infra/"><span class="tag">Infra</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JS/"><span class="tag">JS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JSON/"><span class="tag">JSON</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java17/"><span class="tag">Java17</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java8/"><span class="tag">Java8</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/K3S-Build/"><span class="tag">K3S-Build</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/K8S/"><span class="tag">K8S</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/K8S-Build/"><span class="tag">K8S-Build</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Microservices/"><span class="tag">Microservices</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Movie/"><span class="tag">Movie</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Note-The-Legend-of-1900/"><span class="tag">Note The Legend of 1900</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenSSH/"><span class="tag">OpenSSH</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Qwen/"><span class="tag">Qwen</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RabbitMQ/"><span class="tag">RabbitMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SD/"><span class="tag">SD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Skill/"><span class="tag">Skill</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Syntax/"><span class="tag">Syntax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TS/"><span class="tag">TS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Text2SQL/"><span class="tag">Text2SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TypeScript/"><span class="tag">TypeScript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VIM/"><span class="tag">VIM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VIM-Author/"><span class="tag">VIM Author</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XHProf/"><span class="tag">XHProf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ansi-lib/"><span class="tag">ansi-lib</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/banner/"><span class="tag">banner</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos7/"><span class="tag">centos7</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/changelog/"><span class="tag">changelog</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chattr/"><span class="tag">chattr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/clang/"><span class="tag">clang</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cli/"><span class="tag">cli</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/daily/"><span class="tag">daily</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/database/"><span class="tag">database</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debian/"><span class="tag">debian</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deepseek/"><span class="tag">deepseek</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/firewalld/"><span class="tag">firewalld</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/format/"><span class="tag">format</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/func/"><span class="tag">func</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go-pprof/"><span class="tag">go-pprof</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/goroutine/"><span class="tag">goroutine</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/history/"><span class="tag">history</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/history-of-programing/"><span class="tag">history-of-programing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/homebrew/"><span class="tag">homebrew</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/interface/"><span class="tag">interface</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/io/"><span class="tag">io</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kebernetes/"><span class="tag">kebernetes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/laravel/"><span class="tag">laravel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/laravel-artisan/"><span class="tag">laravel-artisan</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lua/"><span class="tag">lua</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macOS/"><span class="tag">macOS</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macro/"><span class="tag">macro</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/motd/"><span class="tag">motd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql8-0/"><span class="tag">mysql8.0</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql8-x/"><span class="tag">mysql8.x</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nanochat/"><span class="tag">nanochat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nanochat-zh-CN/"><span class="tag">nanochat-zh_CN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/neofetch/"><span class="tag">neofetch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nosql/"><span class="tag">nosql</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oh-my-zsh/"><span class="tag">oh-my-zsh</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/omz/"><span class="tag">omz</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openssl/"><span class="tag">openssl</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/package-time/"><span class="tag">package time</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/painting/"><span class="tag">painting</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pointer/"><span class="tag">pointer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgresql/"><span class="tag">postgresql</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgressql-engine/"><span class="tag">postgressql-engine</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/reflect-%E5%8F%8D%E5%B0%84/"><span class="tag">reflect 反射</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rocky/"><span class="tag">rocky</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rocky-linux/"><span class="tag">rocky-linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rocky-linux-tools/"><span class="tag">rocky-linux-tools</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rsync/"><span class="tag">rsync</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rune/"><span class="tag">rune</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/services/"><span class="tag">services</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slice-%E5%88%87%E7%89%87%E6%9C%AC%E8%B4%A8/"><span class="tag">slice 切片本质</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stable-diffusion-webui/"><span class="tag">stable-diffusion-webui</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/struct/"><span class="tag">struct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/switch/"><span class="tag">switch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systemd-service/"><span class="tag">systemd-service</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/terminal/"><span class="tag">terminal</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/travel/"><span class="tag">travel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/type/"><span class="tag">type</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/type-%E5%85%B3%E9%94%AE%E8%AF%8D%E6%80%BB%E7%BB%93/"><span class="tag">type 关键词总结</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/utf8mb4/"><span class="tag">utf8mb4</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/utf8mb4-0900-ai-ci/"><span class="tag">utf8mb4_0900_ai_ci</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/utf8mb4-general-ci/"><span class="tag">utf8mb4_general_ci</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zsh/"><span class="tag">zsh</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%BA%E7%94%9F/"><span class="tag">人生</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E5%B8%B8/"><span class="tag">日常</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB/"><span class="tag">生活</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AC%E8%BD%BD/"><span class="tag">转载</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/"><span class="tag">配置文件体系</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"><span class="tag">防火墙</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="clustrmaps"><div class="card-content"><div class="menu"><h3 class="menu-label">CLUSTRMAPS</h3></div><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div style="margin-top:10px"><script type="text/javascript" id="clustrmaps" src="https://cdn.clustrmaps.com/map_v2.js?cl=ffffff&amp;w=250&amp;t=n&amp;d=xb7wV_PHYtl9KaSZpQgP9CLUNrXlqm480vcarJmX2A0&amp;co=2d78ad&amp;cmo=3acc3a&amp;cmn=ff5353&amp;ct=ffffff"></script><script type="text/javascript" id="clstr_globe" src="https://clustrmaps.com/globe.js?d=xb7wV_PHYtl9KaSZpQgP9CLUNrXlqm480vcarJmX2A0"></script></div></div></nav></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8952360410310192" data-ad-slot="1345698037" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></div></div></div></div></section><footer class="footer" style="padding:1rem 1.5rem 0"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><a class="footer-logo" style="margin-right:10px" href="/"><img src="/img/logo.svg" alt="Jaco Liu Personal Site (ljq@GitHub).安全贯穿于软件开发各个环节." height="16" style="max-height:1.25rem"></a><a href="http://beian.miit.gov.cn" target="_blank">鲁ICP备2023051700号</a>  <span>&copy; 2026 Jaco Liu</span>  <span style="color:#e0e0e0">Powered by <a style="color:#e0e0e0" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a style="color:#e0e0e0" href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></span><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>  <span id="busuanzi_container_site_pv">Total Visits Counts: <span id="busuanzi_value_site_pv"></span>.</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Jaco Liu&#039;GitHub" href="https://github.com/ljq"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="ref.wdft.com" href="https://ref.wdft.com"><i class="fas fa-cloud"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="cook.wdft.com" href="https://cook.wdft.com"><i class="fas fa-coffee"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Python PEP8" href="https://pep8.org"><i class="fas fa-coffee"></i></a></p> <span><i class="fas fa-link">BlogRoll:</i></span><p class="control" style="color:#26c1fa"><a class="button is-transparent" target="_blank" rel="noopener" title="Quick Reference" href="https://ref.wdft.com">Quick Reference</a></p><p class="control" style="color:#26c1fa"><a class="button is-transparent" target="_blank" rel="noopener" title="Cook" href="https://cook.wdft.com">Cook</a></p><p class="control" style="color:#26c1fa"><a class="button is-transparent" target="_blank" rel="noopener" title="koala-oss.app" href="https://koala-oss.app/news/">koala-oss.app</a></p><p class="control" style="color:#26c1fa"><a class="button is-transparent" target="_blank" rel="noopener" title="CS自学指南" href="https://csdiy.wiki">CS自学指南</a></p><p class="control" style="color:#26c1fa"><a class="button is-transparent" target="_blank" rel="noopener" title="Python PEP8" href="https://pep8.org">Python PEP8</a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("en")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="/js/switchDarkMode.js" defer></script><script src="/js/toutiaoSEO.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load",()=>{window.cookieconsent.initialise({type:"info",theme:"edgeless",static:!1,position:"bottom-left",content:{message:"This website uses cookies to improve your experience.",dismiss:"Got it!",allow:"Allow cookies",deny:"Decline",link:"Learn more",policy:"Cookie Policy",href:"https://www.cookiesandyou.com/"},palette:{popup:{background:"#edeff5",text:"#838391"},button:{background:"#4b81e8"}}})})</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load",()=>{"function"==typeof $.fn.lightGallery&&$(".article").lightGallery({selector:".gallery-item"}),"function"==typeof $.fn.justifiedGallery&&($(".justified-gallery > p > .gallery-item").length&&$(".justified-gallery > p > .gallery-item").unwrap(),$(".justified-gallery").justifiedGallery())})</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"Type something...",untitled:"(Untitled)",posts:"Posts",pages:"Pages",categories:"Categories",tags:"Tags"})})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},react:{opacity:.7},pluginJsPath:"lib/",pluginRootPath:"live2dw/"})</script></body></html>