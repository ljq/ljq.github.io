{"pages":[{"title":"","text":"740b15a2b2c879749fd692289c40d881","link":"/baidu_verify_code-JvY8hn2f9j.html"},{"title":"","text":"{\"name\":\"wdft.com\",\"short_name\":\"wdft.com\",\"theme_color\":\"#2196f3\",\"background_color\":\"#2196f3\",\"display\":\"fullscreen\",\"orientation\":\"portrait\",\"Scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/img/icon-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"}],\"splash_pages\":null}","link":"/manifest.json"},{"title":"404","text":"","link":"/404.html"},{"title":"About 安全贯穿于软件开发各个环节 - 404 页面","text":"Security accompanies every aspect of software development.安全贯穿于软件开发各个环节。GitHub Stats About MeHi! I’m Jaco Liu (Jianqiu Liu). 👋 In me the tiger🐯 sniffs the rose🌹. Jaco Liu GitHub profile trophy: WeChat QRcode Personal WeChat Subscriptions","link":"/about/index.html"},{"title":"Gallerys Random List","text":"","link":"/galleries/index.html"},{"title":"Music PlayList 🎵","text":"A collection of frequently-listened music playlist.🎵 Music Genre ClassificationPersonal NetEase Music 🎵 Light Music No. Awesome 1 All light Awesome 2 Solo Raúl Di Blasio 🎵 Songs Music No. Awesome 1 All songs Awesome","link":"/musics/index.html"},{"title":"Music Light Playlist","text":"A collection of frequently-listened music playlist.🎵 Exodus - Maksim Mrvica Crossroads - 7AND5 Snowy Lullaby (Original Mix) - K.S. Project Meadows of Heaven (Instrumental Version) - Nightwish Fly my wish - Edelis Do Not Go Away (Original Mix) - Martian Solo (Alone) - Raúl Di Blasio Wild Child - Enya","link":"/musics/light.html"},{"title":"Music Song Playlist","text":"A collection of frequently-listened music playlist.🎵 在路上 - 刘欢 海阔天空 - Beyond 水手 - 郑智化 平凡之路 (Live) 朴树 凡人歌 - 李宗盛 我有我路向 - 成龙 Andy - 阿杜 繁星之夜 - 朱桦 EconStories 1.Fight of the Century - EconStories 2.Fear the Boom and Bust - EconStories EconStories","link":"/musics/song.html"},{"title":"","text":"","link":"/projects/index.html"},{"title":"每段路(Bydj-jammy) by 吕方","text":"A collection of frequently-listened video playlist. 每段路(Bydj-jammy) by 吕方每段路（Bydj-jammy)）","link":"/videos/bydj-jammy-lvfang.html"},{"title":"How the Machine Works By Ray Dalio","text":"A collection of frequently-listened video playlist. How the Machine Works By Ray Dalio（经济这台机器是怎样运行的 作者·：瑞·达利奥） 原版：http://www.economicprinciples.org","link":"/videos/howtheeconmachine.html"},{"title":"[Fight of the Century] Keynes vs. Hayek Economics Stories.","text":"A collection of frequently-listened video playlist. Fight of the Century: Keynes vs. Hayek - Economics Rap Battle Round One(【世纪之战】凯恩斯VS哈耶克 经济学说唱第1战) Fight of the Century: Keynes vs. Hayek - Economics Rap Battle Round Two(【世纪之战】凯恩斯VS哈耶克 经济学说唱第2战)","link":"/videos/econstories.html"},{"title":"Video PlayList","text":"A collection of frequently-listened video playlist.(Reproduced reference) No. Name 1 周杰伦——出道以来所有单曲MV大盘点 含HD单曲【合集】 2 Fight of the Century: Keynes vs. Hayek - Economics Rap Battle Round One 【世纪之战】凯恩斯VS哈耶克 经济学说唱 3 How the Machine Works By Ray Dalio 经济这台机器是怎样运行的 作者·：瑞·达利奥 4 每段路 Bydj jammy – 吕方","link":"/videos/index.html"},{"title":"Jay Chou Music","text":"A collection of frequently-listened video playlist. 【黑胶】周杰伦 - 黑暗三部曲以父之名 止战之殇 夜的第七章 【黑胶】周杰伦七里香 夜曲 晴天 周杰伦——出道以来所有单曲MV大盘点 含HD单曲【合集】","link":"/videos/jaychou.html"},{"title":"Solo (Raúl Di Blasio)","text":"Solo (Raúl Di Blasio)Author：Raúl Di BlasioPublish Date：1997-05-20Publish Company： RCA InternationalA personal favorite album.🎹 IntroLatin pianist Raul Di Blasio was born in 1949 in the small town of Zapala, Argentina, the son of a small farmer. He began his musical education at the age of six. He was first exposed to Latin music such as Tango and Bossa Nova, but was also heavily influenced by European classical composers such as Beethoven and Rachmaninov. As a teenager, however, Di Blasio became obsessed with the Beatles and quickly formed his own rock band, Los Diabolicos. The band achieved some success in its home country and did not break up until 1973. He then returned to classical music and toured South America in the mid-1970s. In 1978 Di Blasio went into musical hibernation for five years at a hotel in the Chilean city of Fonsi. At the end of this period of his life, he concentrated all his talent on making music. His debut single was released by EMI in 1983. It was a huge success and was hailed by the media as “the people’s pianist”. In 1987, he moved to Miami, USA. Three years later, he released erica on BMG, which sold more than one million copies in 1994. In order to hold a solo concert in 1997, Di Blasio toured the Far East. Solo (Raúl Di Blasio)","link":"/musics/light/Solo-Ra%C3%BAl-Di-Blasio.html"}],"posts":[{"title":"AI drawing ControlNet local implementation steps by stable-diffusion-webui（AI绘画ControlNet本地构建实施步骤 by stable-diffusion-webui）","text":"Install stable-diffusion-webui[Note]: Unable to install due to network problems, it is recommended to use GIT source pull installation（因网络问题导致无法安装，故建议使用GIT源码拉取安装方式） Due to the large size of the model file, it is recommended to ensure sufficient space before installation: At least [source code + data model + extension]25G（因模型文件较大，建议安装前确保有足够空间: 至少[源码+数据模型+扩展]25G） The PC terminal to be built is 🍎 macOS Ventura 13.4.1(c), and the Windows environment is built in much the same way.（构建PC终端是🍎 macOS Ventura 13.4.1(c)，Windows系统环境构建方式大同小异） Basic build tools (brew management recommended)（基础构建工具（推荐brew管理））123456cmakewgetgitrustprotobufpython3.x Project key directory（项目关键目录） stable-diffusion-webui/extensions （扩展） stable-diffusion-webui/models (模型) Construction steps（构建步骤） Install and start service: stable-diffusion-webui (源码安装：stable-diffusion-webui) 12345678# Pull source codegit clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git &amp;&amp; cd stable-diffusion-webui# start web UI （启动web UI）./webui.sh# Running on local URL: http://127.0.0.1:7860 Default web UI url： http://127.0.0.1:7860 base model source download (绘图基础模型下载) AI drawing basic model download 1234567# models directorycd stable-diffusion-webui/models/Stable-diffusionwget https://huggingface.co/stabilityai/stable-diffusion-2/resolve/main/768-v-ema.ckpt# back stable-diffusion-webui &amp; restart webui.sh./webui.sh Basic extensions install （基础插件安装） Install controlnet extension （安装ContolNet扩展）12345678# cd extensions pathcd stable-diffusion-webui/extensions# Pull extension source codegit clone https://github.com/Mikubill/sd-webui-controlnet.git# back to browser web UI click button：apply and restart Project key directory（项目关键目录） stable-diffusion-webui/extensions （扩展） stable-diffusion-webui/models (模型) Install openpose-editor extension (Custom pose) （安装openpose扩展） 1234567# cd extensions pathcd stable-diffusion-webui/extensions# Pull extension source codegit clone https://github.com/fkunn1326/openpose-editor.git# back to browser web UI click button：apply and restart Extensions include directory structure （扩展包含目录结构）1234extensions├── openpose-editor-master├── put extensions here.txt└── sd-webui-controlnet-main Basic Extensions have been installed. back home page and open ControlNet tab. Controlnet associated base model download (controlnet相关联的基础模型下载)A list of optional models is suggested123456789101112# cd models ControlNet pathmkdir -p stable-diffusion-webui/models/ControlNet &amp;&amp; cd stable-diffusion-webui/models/ControlNet# cannywget https://huggingface.co/lllyasviel/ControlNet/resolve/main/models/control_sd15_canny.pth# openposewget https://huggingface.co/lllyasviel/ControlNet/resolve/main/models/control_sd15_openpose.pth# scribblewget https://huggingface.co/lllyasviel/ControlNet/resolve/main/models/control_sd15_scribble.pth Models include directory structure (模型包含目录结构)12345678models├── ControlNet│ ├── control_sd15_canny.pth│ ├── control_sd15_openpose.pth│ └── control_sd15_scribble.pth├── Stable-diffusion│ ├── 768-v-ema.ckpt│ └── Put Stable Diffusion checkpoints here.txt Installation completeNotice：Note that some source code, model and extension download network is slow, it is recommended to use professional download tools to download（注意事项，部分源码、模型和扩展下载网络缓慢，建议采用专业下载工具下载）","link":"/4de059e7.html"},{"title":"Thoughts on Agent-based Enterprise Application Architecture.（Agent企业级应用架构思考和挑战）","text":"“不确定性不是缺陷，而是新范式的特征，必须学会“回忆”，但同时也要学会“遗忘”。”AI时代，智能体本身的概率输出让软件走向不确定，或者说更个性。但这对企业级产品的准确率形成巨大挑战，怎么看待这种现状、机遇和商业风险？智能体和传统应用范式下在业务落地间角色和职能的划分和原则? 这是目前AI面临的核心问题，触及了AI原生时代企业软件架构、产品设计与组织协作的根本性变革和创业者的产品决策方向。 一、对“概率性智能体 vs 企业级准确率”矛盾的再审视：现状、机遇与风险1. 现状：范式冲突已成现实 传统企业软件：基于确定性逻辑（if-then、事务一致性、幂等性），追求“一次正确、处处可靠”。 AI智能体：基于概率生成（LLM、多模态模型），输出具有上下文依赖性、随机性和创造性，本质是“探索性”而非“执行性”。 现状：从“确定性软件”到“概率性智能体”的范式迁移。传统企业级软件（如ERP、CRM、数据库系统）建立在确定性逻辑之上：输入A，必然输出B。这种可预测性是企业信任、合规审计、流程控制的基础。而大模型驱动的智能体（Agent）本质上是概率性系统：基于统计学习，输出具有不确定性，同一输入在不同上下文、提示词或随机种子下可能产生不同结果。这种“个性”或“创造力”是AI智能的来源，却与企业对准确性、可重复性、可解释性的要求相冲突。 这种冲突在财务、法务、医疗、制造等强合规、高风险领域尤为尖锐。例如，一个智能客服可能今天说“可退款”，明天说“不可退款”，仅因提示词微调或上下文变化——这对企业品牌和合规是灾难。典型冲突场景：财务系统生成错误的报表数字；客服智能体给出不一致甚至错误的政策解释；法律合规助手输出存在法律风险的建议。 2. 机遇：从“执行工具”到“智能协作者” 增强而非替代：智能体可处理模糊、非结构化任务（如会议纪要提炼、客户情绪分析、市场趋势推测），释放人力聚焦高价值决策。 动态个性化：为不同角色（销售、财务、高管）提供定制化信息摘要与建议，提升组织效率。 闭环学习能力：通过用户反馈持续优化行为策略，形成“越用越懂你”的产品护城河。 3. 商业风险：信任崩塌比技术失败更致命 准确性漂移：模型更新或上下文变化导致输出不一致，破坏流程稳定性。 责任模糊：AI建议被采纳后出错，责任归属不清（开发者？部署方？使用者？）。 合规黑洞：GDPR、HIPAA、SOX等要求可解释、可审计，而黑箱推理难以满足。 用户预期错配：若产品宣传“全自动”，但实际需频繁人工干预，将引发客户流失。 关键洞察：企业客户不拒绝“智能”，但拒绝“不可控的智能”。他们要的是“确定性结果 + 智能过程”。 商业风险：不可控的“黑箱”可能摧毁信任准确性风险关键业务场景（如医疗诊断、金融交易、合规审计）对错误零容忍，概率输出若未加约束，可能引发重大损失。合规与审计难题企业需满足GDPR、SOX等法规，要求系统行为可追溯、可解释。而大模型的“黑箱”特性与之冲突。责任归属模糊若AI输出导致客户损失，责任在开发者、部署方还是模型提供商？法律尚不明确。用户信任崩塌企业用户习惯“软件即工具”，若AI频繁“胡说八道”或前后矛盾，将迅速失去信任。 二、智能体与传统应用在业务落地中的角色划分与协作原则要化解上述矛盾，必须重新定义智能体与传统系统的边界。核心原则是：“确定性归系统，探索性归智能体”。 1. 角色与职能划分（按业务生命周期） 业务阶段 传统应用（确定性系统） 智能体（概率性协作者） 数据输入 结构化表单、API接入、事务校验 解析非结构化输入（邮件、语音、PDF）、意图识别 处理逻辑 执行预设规则、工作流引擎、事务一致性保障 提供多方案建议、风险预测、上下文推理、草稿生成 决策输出 生成确定性结果（订单确认、付款指令、审批状态） 输出带置信度的建议（“建议拒绝该申请，理由：…”） 执行动作 调用ERP、支付网关、数据库写入等原子操作 不直接执行，仅触发人工审核或系统调用 审计追溯 完整日志、操作留痕、符合合规要求 记录推理链、引用来源、置信度、用户反馈闭环 2. 协作架构原则（1）职责隔离原则（Separation of Concerns） 智能体只负责“建议”和“生成”，不拥有“执行权”。 所有关键业务动作（资金变动、合同签署、数据删除）必须由传统系统在明确授权下执行。 （2）置信度驱动原则（Confidence-Gated Execution） 智能体输出必须附带置信度评分或不确定性区间。 高置信度（如 &gt;95%）可自动进入审批流；低置信度自动转人工或提供多选项。 （3）人类在环原则（Human-in-the-Loop, HITL） 在高风险场景（如法律条款生成、财务预测），必须设计“人工确认”节点。 用户可一键修正AI输出，并反馈至模型优化闭环。 （4）可解释与可回溯原则 采用 RAG（检索增强生成）确保事实可溯源； 记录完整推理链（Chain-of-Thought）供审计； 支持“为什么这样建议？”的追问机制。 （5）边界防护原则（Guardrails） 通过规则引擎、内容过滤器、合规知识库对AI输出进行实时校验； 例如：禁止生成“100%保证收益”等违规话术。 三、落地实践建议：构建“混合智能”企业产品 产品设计：明确标注哪些功能是“AI建议”，哪些是“系统执行”，管理用户预期。 技术架构：采用“传统核心系统 + AI插件层”模式，确保核心业务不受AI波动影响。 度量体系：不仅考核准确率，还需监控一致性、安全性、用户干预率、合规违规次数。 组织协同：设立“AI治理官”角色，统筹技术、法务、产品对智能体行为进行管控。 除非经由记忆之路，人不能抵达纵深。一、对人类智能的启示：记忆是纵深的唯一路径普鲁斯特强调，真正的理解、情感的深度、存在的真实感，并非来自即时感知，而是通过记忆的重构与回溯才得以浮现。 一块玛德琳蛋糕的味道，触发童年贡布雷的整个世界； 正是这种非线性、联想式、情感浸润的记忆，让人抵达经验的“纵深”。 这揭示了一个根本事实：智能若无记忆，只是反应；记忆若无关联，只是存储。纵深 = 记忆 × 时间 × 意义编织。 二、对AI智能体的拷问：当前的“记忆”是否通向纵深？今天的AI智能体（尤其是基于大模型的Agent）看似“聪明”，但其“记忆”存在严重缺陷： 类型 人类记忆 当前AI“记忆” 持续性 贯穿一生，自我叙事 会话级（短期）或依赖外部向量库（碎片化） 主体性 “我”的经历，情感锚定 无“我”，只有统计关联 重构能力 可在新情境下重新诠释旧记忆 依赖提示工程，缺乏主动回溯与意义生成 纵深生成 记忆触发顿悟、悔恨、爱 输出是概率拼接，难有真正“洞察” 因此，当前AI的“记忆之路”是断头路——它能检索、能复述，但无法像普鲁斯特那样，通过一块蛋糕的味道，唤醒整个逝去的世界。它没有“纵深”，只有“表层的流畅”。 换言之：没有主体性记忆的智能体，再聪明也只是浅层的回声。 三、对企业级AI产品的战略启示：构建“可积累、可反思、可成长”的记忆系统若想让AI真正成为企业级场景中的“深度协作者”，就必须超越“一次问答”的范式，走向长期记忆架构（Long-term Memory Architecture）： 1. 从“无状态交互”到“有历史的智能体” 智能体应记住与用户的长期互动：偏好、错误、成功案例、组织语境。 例如：销售助手记得某客户去年因合规问题拒绝某方案，今年自动规避类似建议。 2. 记忆需分层：事实层 + 经验层 + 反思层 事实记忆：客户合同条款、产品参数（传统数据库）； 经验记忆：某次谈判中客户对“价格敏感度高”（需结构化提炼）； 反思记忆：上次建议失败的原因分析（需AI具备元认知能力）。 3. 记忆必须可被“重新诠释” 真正的纵深，不是重复过去，而是在新情境下赋予旧记忆新意义。 例如：经济下行时，重新评估过去“高增长假设”下的战略建议。 4. 隐私与治理：记忆的伦理边界 企业级记忆必须可审计、可删除、可解释； 避免“记忆固化偏见”（如对某客户标签化）； 建立“记忆生命周期管理”机制。 结语：通往纵深的AI，必须学会“回忆”，但同时也要学会“遗忘”。普鲁斯特告诉我们：纵深不在远方，而在回望之中。对企业而言，真正的智能不是回答所有问题，而是在时间中积累、在错误中学习、在关系中理解。 未来的AI智能体若想超越“概率鹦鹉”，就必须走上“记忆之路”——不是简单存储日志，而是构建有叙事、有情感权重、有反思能力的数字记忆体。 唯有如此，它才能从“工具”升维为“伙伴”，从“响应”走向“理解”，从“表层流畅”抵达“企业智能的纵深”。 这句话极具洞见——“通往纵深的AI，必须学会‘回忆’，但同时也要学会‘遗忘’。” 它不仅呼应了普鲁斯特对记忆的礼赞，更引入了数字时代智能体必须面对的另一重哲学与工程命题：记忆的边界即智能的边界，而遗忘是边界的设计艺术。 一、为何必须“回忆”？——记忆是纵深的土壤如前所述，没有记忆的AI只是瞬时反应的“回声机器”。 回忆让AI具备上下文连续性（“你上周提到项目延期…”）； 回忆支撑个性化（“根据你过去偏好，推荐A而非B”）； 回忆促成学习闭环（“上次这个建议被否决，因为合规问题”）。 没有长期记忆，AI无法形成对用户、组织、业务的“理解纵深”，只能在表层滑行。 回忆，是AI从“工具”走向“协作者”的第一步。 二、为何必须“遗忘”？——遗忘是智能的净化与伦理但无节制的记忆同样危险。不加选择的记忆，不是智慧，而是负担甚至威胁。 1. 认知层面：遗忘是提炼与聚焦 人类大脑会自动遗忘琐碎信息，保留模式与意义； AI若记住所有细节，反而淹没关键信号（“噪声淹没洞察”）； 主动遗忘 = 信息蒸馏：将原始交互提炼为经验规则、用户画像或风险模式。 2. 隐私与合规层面：遗忘是责任 GDPR 的“被遗忘权”（Right to be Forgotten）要求系统能删除个人数据； 企业场景中，员工离职、客户撤回授权、敏感对话等，都需可验证的遗忘机制； 若AI“记得太多”，将成为合规雷区与法律风险源。 3. 安全与偏见层面：遗忘是纠偏 过时记忆可能固化错误认知（如“某客户总是拒绝折扣”）； 带偏见的历史数据若被永久记忆，会放大歧视； 定期“记忆刷新”或“偏见过滤”，是AI保持公正与适应性的关键。 遗忘，不是缺陷，而是智能体的自我净化能力。 三、如何设计“会回忆也会遗忘”的AI系统？——企业级智能的记忆治理框架真正的纵深智能，需要一套记忆生命周期管理（Memory Lifecycle Governance）机制： 阶段 关键能力 技术/策略示例 摄入 判断什么值得记 基于重要性评分（如用户显式确认、高业务影响事件） 存储 分层记忆结构 短期上下文（会话缓存）+ 长期经验库（向量数据库）+ 元记忆（“我曾记过什么”） 使用 动态检索与重构 RAG + 用户角色/情境感知的回忆触发 更新 记忆演化 当新证据推翻旧结论时，自动标注“记忆过期” 遗忘 主动删除与模糊化 按策略自动删除（如90天未交互）、匿名化、置信度衰减 核心原则： 最小必要记忆：只记达成目标所必需的信息； 可解释的遗忘：用户可查询“你记得我什么？为什么忘了？”； 伦理优先于效率：宁可“忘得多一点”，也不“记得危险”。 结语：记忆与遗忘的辩证，是AI走向成熟的标志 回忆赋予AI深度，遗忘赋予AI边界；深度让它理解你，边界让它值得你托付。 在人类心智中，记忆与遗忘本是一体两面——我们之所以能深情回望童年，正因为大脑自动滤去了无数琐碎与痛苦。AI若想真正“抵达纵深”，不仅要模仿人类的记忆，更要学习人类的选择性遗忘： 忘掉噪音，留下意义； 忘掉偏见，留下公正； 忘掉过去，才能拥抱未来。 这不仅是技术挑战，更是数字时代智能伦理的基石。未来的赢家，不是记得最多的AI，而是知道该记住什么、该遗忘什么的AI。 智能体不是“新软件”，而是“新的协作者”未来的企业级产品，不再是“人操作软件”，而是“人与智能体协作完成任务”。成功的AI原生企业软件，必须做到： 让确定性守住底线，让智能性拓展上限。 智能体的角色，应是“聪明的实习生”——能提出创意、处理杂务，但关键决策仍由“资深员工”（传统系统+人类专家）把关。唯有如此，才能在拥抱AI浪潮的同时，守住企业级产品赖以生存的可靠性、合规性与信任基石。 应对策略：在“可控不确定性”中构建企业级AI，全面拥抱AI时代，这是普通创业者的必经之路和破局关键，让确定性守住底线，让智能性拓展上限。 “ unless you go through the memory path, you can’t reach the depth.“(除非经由记忆之路，人不能抵达纵深。”)","link":"/3fcf7b98.html"},{"title":"WDFT (Warped Discrete Fourier Transform)","text":"WDFT (Warped Discrete Fourier Transform) by GoImplementation of Go language: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package mainimport ( &quot;fmt&quot; &quot;math&quot; &quot;math/cmplx&quot;)// 定义扭曲函数，这里以幂函数为例func distortionFunction(omega float64) float64 { return math.Pow(omega, 1.5) // 可根据需要修改扭曲函数}// 离散傅里叶变换func dft(signal []float64) []complex128 { N := len(signal) result := make([]complex128, N) for k := 0; k &lt; N; k++ { var sum complex128 for n := 0; n &lt; N; n++ { omega := -2 * math.Pi * float64(k*n) / float64(N) sum += complex(signal[n], 0) * cmplx.Exp(complex(0, omega)) } result[k] = sum } return result}// 扭曲离散傅里叶变换func wdft(signal []float64) []complex128 { N := len(signal) spectrum := dft(signal) for k := 0; k &lt; N; k++ { omega := 2 * math.Pi * float64(k) / float64(N) warpedOmega := distortionFunction(omega) spectrum[k] *= cmplx.Exp(complex(0, warpedOmega)) } return spectrum}// 反离散傅里叶变换func idft(spectrum []complex128) []float64 { N := len(spectrum) result := make([]float64, N) for n := 0; n &lt; N; n++ { var sum complex128 for k := 0; k &lt; N; k++ { omega := 2 * math.Pi * float64(k*n) / float64(N) sum += spectrum[k] * cmplx.Exp(complex(0, omega)) } result[n] = real(sum) / float64(N) } return result}func main() { // 生成一个简单的示例信号 signal := make([]float64, 8) for i := range signal { signal[i] = float64(i) } // 进行WDFT变换 spectrum := wdft(signal) // 对频域表示进行处理（这里省略具体处理步骤） // 进行反离散傅里叶变换 outputSignal := idft(spectrum) // 输出结果 fmt.Println(&quot;原始信号：&quot;, signal) fmt.Println(&quot;经过WDFT变换后的信号：&quot;, outputSignal)} Implementation of Rust language:Cargo.toml 12[dependencies]num = &quot;0.4&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576use std::f64::consts::PI;use num::complex::Complex;// 定义扭曲函数fn distortion_function(omega: f64) -&gt; f64 { omega.powf(1.5) // 可根据需要修改扭曲函数}// 离散傅里叶变换fn dft(signal: &amp;[f64]) -&gt; Vec&lt;Complex&lt;f64&gt;&gt; { let n = signal.len(); let mut spectrum = vec![Complex::new(0.0, 0.0); n]; for k in 0..n { let mut sum = Complex::new(0.0, 0.0); for n in 0..n { let omega = -2.0 * PI * k as f64 * n as f64 / n as f64; sum += Complex::new(signal[n], 0.0) * Complex::from_polar(1.0, omega); } spectrum[k] = sum; } spectrum}// 扭曲离散傅里叶变换fn wdft(signal: &amp;[f64]) -&gt; Vec&lt;Complex&lt;f64&gt;&gt; { let n = signal.len(); let spectrum = dft(signal); let warped_spectrum: Vec&lt;Complex&lt;f64&gt;&gt; = spectrum .iter() .enumerate() .map(|(k, &amp;value)| { let omega = 2.0 * PI * k as f64 / n as f64; let warped_omega = distortion_function(omega); value * Complex::from_polar(1.0, warped_omega) }) .collect(); warped_spectrum}// 反离散傅里叶变换fn idft(spectrum: &amp;[Complex&lt;f64&gt;]) -&gt; Vec&lt;f64&gt; { let n = spectrum.len(); let mut signal = vec![0.0; n]; for n in 0..n { let mut sum = Complex::new(0.0, 0.0); for k in 0..n { let omega = 2.0 * PI * k as f64 * n as f64 / n as f64; sum += spectrum[k] * Complex::from_polar(1.0, omega); } signal[n] = sum.re / n as f64; } signal}fn main() { // 生成一个简单的示例信号 let signal: Vec&lt;f64&gt; = (0..8).map(|i| i as f64).collect(); // 进行WDFT变换 let spectrum = wdft(&amp;signal); // 对频域表示进行处理（这里省略具体处理步骤） // 进行反离散傅里叶变换 let output_signal = idft(&amp;spectrum); // 输出结果 println!(&quot;原始信号：{:?}&quot;, signal); println!(&quot;经过WDFT变换后的信号：{:?}&quot;, output_signal);}","link":"/e324f38b.html"},{"title":"对比主流云原生KubeSphere、KubeVela、Rancher、Sealos和Rainbond五者之间的区别","text":"KubeSphere、KubeVela、Rancher、Sealos和Rainbond五者之间的区别：这个表格简要概述了KubeSphere、KubeVela、Rancher、Sealos和Rainbond五者之间的主要区别。每个项目都有其独特的特点和优势，适用于不同的场景和用户群体。在选择时，建议根据实际需求、技术栈和团队经验来权衡各个选项。 项目 KubeSphere KubeVela Rancher Sealos Rainbond 基本定位 面向云原生应用的分布式操作系统 现代化应用交付与管理平台 开源的企业级多集群Kubernetes管理平台 以Kubernetes为内核的云操作系统发行版 国产开源的无服务器容器云平台 内核/基础 以Kubernetes为内核 基于OAM规范和Kubernetes 以Kubernetes作为其容器编排引擎 Kubernetes Kubernetes 主要特点 全栈自动化IT运营；简化的DevOps工作流；多租户支持；丰富的企业级功能 应用部署即代码；支持多集群认证和授权；开箱即用的平台扩展；面向混合云环境 强大的多集群管理能力；一键部署应用；多种编排调度工具；支持多种基础架构 无需安装Kubernetes集群即可使用；提供秒级创建高可用数据库的服务；自动伸缩功能节省成本 以应用为中心；深度集成Kubernetes；支持多云环境下的统一运维管理 用户界面 提供开发人员友好的向导式Web UI - 提供直观的Web管理界面 内置终端支持命令行操作，同时提供管理界面 提供友好的用户界面 集成性 即插即用的架构，允许第三方应用无缝集成 可与任何CI流水线或GitOps工具无缝集成 集成开源监控、日志、Git CI 与其他云原生工具和服务有良好的兼容性 模块化拼装，加速应用构建 生态系统 整合了大量云原生相关组件 拥有快速增长的插件市场 - 与主流云服务提供商有良好的合作关系 提供了丰富的应用场景和解决方案 目标用户 面向企业和开发人员，尤其是需要简化DevOps流程的场景 面向软件开发团队，尤其是需要在混合云环境中交付应用的团队 面向需要在生产环境中运行容器和Kubernetes的组织 面向需要高效、灵活、安全的云服务解决方案的企业 面向需要云原生应用全生命周期管理的企业 部署与扩展 支持多云与多集群管理；提供KubeKey安装程序 支持多集群/混合环境持续交付策略 支持在混合云和本地数据中心集中部署与管理Kubernetes集群 快速部署各种分布式应用，如Nginx、数据库等 支持多种计算资源和存储资源的接入和管理 学习成本 对刚上手的人来说较为友好，提供了较多的整合功能 需要了解OAM规范和Kubernetes概念 学习成本较高，但提供了一站式的解决方案 相对较低，提供友好的用户操作体验 提供了丰富的文档资源和社区支持，降低学习门槛 成熟度与稳定性 经过多年发展，已成为国际化的容器开源项目 - 相较于KubeSphere更为成熟稳定 逐步发展，为企业提供稳定可靠的云服务解决方案 经过多个版本的迭代，提供了稳定可靠的云原生应用管理平台","link":"/4b8b1c9c.html"},{"title":"Eight Fallacies of Distributed Systems （分布式八大谬论）","text":"Eight Fallacies of Distributed SystemsThe network is reliable网络可靠。 Latency is zero延迟为零。 Bandwidth is infinite带宽是无限的。 The network is secure网络是安全的。 Topology doesn’t change拓扑不会改变。 There is one administrator只有一个管理员。 Transport cost is zero运输成本为零。 The network is homogeneous网络是同质的。","link":"/67fb071a.html"},{"title":"从零开始：使用三台服务器搭建最简 Kubernetes 集群并集成 Gitea + Harbor 示例","text":"在完成基础集群搭建的基础上，本文新增代码仓库（Gitea）与镜像仓库（Harbor）的集成部署指南，实现完整的 DevOps 工具链闭环。 🧩 一、前置要求补充1.1 安装 Ingress 控制器12345# 安装 Nginx Ingress（需在 Master 节点执行）kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.1/deploy/static/provider/cloud/deploy.yaml# 验证安装状态kubectl get pods -n ingress-nginx 1.2 创建共享存储目录（所有节点）12sudo mkdir -p /opt/k8s-data/{gitea,harbor}sudo chmod 777 /opt/k8s-data/{gitea,harbor} # 测试环境简化权限 📦 二、集成 Gitea 代码仓库2.1 创建 PostgreSQL 数据库（依赖 Helm 3）12345678910111213# 添加 Bitnami 仓库helm repo add bitnami https://charts.bitnami.com/bitnamihelm repo update# 创建数据库命名空间kubectl create namespace gitea# 部署 PostgreSQLhelm install gitea-db bitnami/postgresql \\ --namespace gitea \\ --set auth.postgresPassword=yourStrongPassword \\ --set persistence.size=5Gi \\ --set persistence.hostPath=/opt/k8s-data/gitea/db 2.2 部署 Gitea 服务2.2.1 创建配置文件 ConfigMap123456789101112131415161718192021# gitea-config.yamlapiVersion: v1kind: ConfigMapmetadata: name: gitea-config namespace: giteadata: app.ini: | [server] DOMAIN = gitea.wdft.com ROOT_URL = https://gitea.wdft.com/ [database] DB_TYPE = postgres HOST = gitea-db-postgresql:5432 NAME = postgres USER = postgres PASSWD = yourStrongPassword [repository] ROOT = /data/git/repositories 2.2.2 部署 Gitea 应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# gitea-deployment.yamlapiVersion: apps/v1kind: Deploymentmetadata: name: gitea namespace: giteaspec: replicas: 1 selector: matchLabels: app: gitea template: metadata: labels: app: gitea spec: containers: - name: gitea image: gitea/gitea:latest ports: - containerPort: 3000 volumeMounts: - name: gitea-config mountPath: /etc/gitea/app.ini subPath: app.ini - name: gitea-data mountPath: /data volumes: - name: gitea-config configMap: name: gitea-config - name: gitea-data hostPath: path: /opt/k8s-data/giteaapiVersion: v1kind: Servicemetadata: name: gitea namespace: giteaspec: ports: - port: 80 targetPort: 3000 selector: app: giteaapiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: gitea-ingress namespace: gitea annotations: nginx.ingress.kubernetes.io/ssl-redirect: &quot;false&quot;spec: rules: - http: paths: - path: / pathType: Prefix backend: service: name: gitea port: number: 80 2.2.3 应用部署12kubectl apply -f gitea-config.yamlkubectl apply -f gitea-deployment.yaml 2.2.4 访问初始化12345678# 查看 Ingress IPkubectl get ingress -n gitea# 浏览器访问 http://&lt;INGRESS_IP&gt; 并完成初始化：# 数据库选择 PostgreSQL# 数据库用户名/密码：postgres / yourStrongPassword# 仓库根目录：/data/git/repositories# 确认域名配置为 gitea.wdft.com 🌊 三、集成 Harbor 镜像仓库3.1 安装 Helm 客户端（所有节点）12curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3chmod 700 get_helm.sh &amp;&amp; ./get_helm.sh 3.2 部署 Harbor 依赖组件1234567891011121314# 创建命名空间kubectl create namespace harbor# 部署 Redishelm install harbor-redis bitnami/redis \\ --namespace harbor \\ --set password=redisPassword \\ --set persistence.hostPath=/opt/k8s-data/harbor/redis# 部署 PostgreSQLhelm install harbor-db bitnami/postgresql \\ --namespace harbor \\ --set auth.postgresPassword=harborPassword \\ --set persistence.hostPath=/opt/k8s-data/harbor/db 3.3 创建 Harbor 配置文件3.3.1 自签名证书生成（Master 节点）12345678910111213141516171819mkdir -p /opt/certscd /opt/certsopenssl genrsa -out ca.key 4096openssl req -x509 -new -nodes -sha512 -days 3650 \\ -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=Harbor/CN=harbor.wdft.com&quot; \\ -key ca.key -out ca.crtopenssl req -new -nodes -sha512 -days 3650 \\ -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=Harbor/CN=harbor.wdft.com&quot; \\ -keyout harbor.key -out harbor.csropenssl x509 -req -sha512 -days 3650 \\ -CA ca.crt -CAkey ca.key -CAcreateserial \\ -in harbor.csr -out harbor.crt# 所有节点信任证书sudo cp /opt/certs/ca.crt /usr/local/share/ca-certificates/sudo update-ca-certificatessudo systemctl restart containerd 3.3.2 创建 Harbor Values 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# harbor-values.yamlhostname: harbor.wdft.comnetworkPolicy: notary: false clair: false chartmuseum: falseexternalURL: https://harbor.wdft.comssl: enabled: true cert: certificate: |- -----BEGIN CERTIFICATE----- $(cat /opt/certs/harbor.crt | grep -v &quot;BEGIN CERTIFICATE&quot; | grep -v &quot;END CERTIFICATE&quot;) -----END CERTIFICATE----- privateKey: |- -----BEGIN PRIVATE KEY----- $(cat /opt/certs/harbor.key | grep -v &quot;BEGIN PRIVATE KEY&quot; | grep -v &quot;END PRIVATE KEY&quot;) -----END PRIVATE KEY-----database: type: external external: host: harbor-db-postgresql port: 5432 username: postgres password: harborPassword database: harborredis: host: harbor-redis port: 6379 password: redisPasswordpersistence: persistentVolumeClaim: registry: existingClaim: &quot;&quot; jobservice: existingClaim: &quot;&quot; chartmuseum: existingClaim: &quot;&quot; clair: existingClaim: &quot;&quot; notary: existingClaim: &quot;&quot; trivy: existingClaim: &quot;&quot; hostPath: /opt/k8s-data/harbor 3.4 部署 Harbor12345678# 添加 Harbor Helm 仓库helm repo add harbor https://helm.goharbor.iohelm repo update# 安装 Harborhelm install harbor harbor/harbor \\ --namespace harbor \\ --values harbor-values.yaml 3.5 配置 Ingress 规则1234567891011121314151617181920212223# harbor-ingress.yamlapiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: harbor-ingress namespace: harbor annotations: nginx.ingress.kubernetes.io/ssl-passthrough: &quot;true&quot;spec: tls: - hosts: - harbor.wdft.com secretName: harbor-ingress-tls rules: - http: paths: - path: / pathType: Prefix backend: service: name: harbor-core port: number: 443 1234567# 创建 TLS Secretkubectl -n harbor create secret tls harbor-ingress-tls \\ --cert=/opt/certs/harbor.crt \\ --key=/opt/certs/harbor.key# 应用 Ingresskubectl apply -f harbor-ingress.yaml 🔄 四、集成验证4.1 修改 Go 应用部署文件12# 修改 deployment.yaml 中的 image 字段image: harbor.wdft.com/library/go-hello:1.0 4.2 配置 Kubernetes 秘钥12345678910111213# 创建镜像拉取秘钥kubectl create secret docker-registry regcred \\ --docker-server=https://harbor.wdft.com \\ --docker-username=admin \\ --docker-password=Harbor12345 \\ --docker-email=admin@wdft.com# 修改 Deployment 添加 imagePullSecretsspec: template: spec: imagePullSecrets: - name: regcred 4.3 推送镜像到 Harbor123456# 登录 Harbordocker login harbor.wdft.com -u admin -p Harbor12345# 重新构建并推送镜像docker build -t harbor.wdft.com/library/go-hello:1.0 .docker push harbor.wdft.com/library/go-hello:1.0 🧪 五、完整 CI/CD 流程演示 代码提交在 Gitea 创建新仓库 go-hello，推送代码： 12git remote add origin http://git.wdft.com/ljq/go-hello.gitgit push -u origin master 镜像构建修改构建命令指向私有仓库： 12docker build -t harbor.wdft.com/ljq/go-hello:latest .docker push harbor.wdft.com/ljq/go-hello:latest 生产部署更新 Deployment 镜像地址后重新部署： 1kubectl apply -f deployment.yaml 📌 六、配置参考图示123456789+-------------------+ +------------------+ +-------------------+| | | | | || Gitea Code Repo |&lt;---&gt;| Harbor Registry |&lt;---&gt;| Kubernetes Cluster|| | | | | |+-------------------+ +------------------+ +-------------------+ ^ ^ ^ | | | v v v Developer Workstation CI/CD Pipeline Production Environment 📚 七、后续优化建议 安全加固 使用 Let’s Encrypt 自动签发证书 配置 RBAC 权限隔离 启用 Harbor 的 Clair 漏洞扫描 存储优化 替换 hostPath 为 NFS 或云存储 配置 Harbor 的 MinIO 后端存储 高可用 部署 PostgreSQL + Patroni 集群 使用 Redis Cluster 替代单实例 监控告警 部署 Prometheus + Grafana 配置 Harbor 自带的监控面板 💡 注意事项： 将 harbor.wdft.com 和 gitea.wdft.com 替换为实际域名 生产环境应使用独立存储类（StorageClass） 所有敏感信息应通过 Kubernetes Secret 管理 建议为 Harbor 配置独立的 DNS 解析记录","link":"/7c4c358b.html"},{"title":"Peter Thiel&#39;s methodology for going from zero to one（彼得·蒂尔从 0 到 1 的方法论(by 演讲)）","text":"彼得·蒂尔从 0 到 1 的方法论(by 演讲)： 每一次真正重要的创新都是独一无二的下一个扎克伯格不会再做社交网站，下一个拉里·佩奇不会再做搜索。模仿不会带来突破，从模仿中学不到创新的本质。 商业不是科学科学依赖可重复性，而真正伟大的企业无法重复。企业的本质是独特性，从 0 到 1，而不是从 1 到 N。 创业的核心问题是：你发现了别人没有看到的真相吗？你能否说出一个你相信但别人不认同的观点。伟大的机会往往隐藏在这种被忽视的“秘密”里。 目标应是垄断，而不是竞争竞争会消耗利润，让你陷入同质化，越努力越累。垄断才会带来长期、稳定、高额收益。成功公司一定独特，失败公司一定相似。 5, 竞争会缩窄视野当你沉迷于击败对手时，会忽视更重要的东西。许多人留在光鲜但空洞的路径上，只因为他们的身份依附于竞争结果。 社会文化倾向于嘲笑原创、奖励模仿真正有原创想法的人往往被质疑和劝阻。大众会本能地追随趋势而不是探索未知。 世界上仍有大量未被探索的前沿机会不仅在 IT，也在生物科技、航空航天、物理世界的技术中。真正的突破不是扩张现有模式（全球化），而是创造新的纵向技术增长。 全球化是复制成功（从 1 到 N），技术创新是创造新的东西（从 0 到 1）过去几十年全球化快于技术进步。要让发达国家重新进入增长周期，必须重启创新。 你要做的不是加入竞争，而是逃离竞争。要寻找别人忽略的真问题，做独一无二的事。真正的价值来自从 0 到 1 的创造。","link":"/e111b800.html"},{"title":"常用GUI库","text":"常用GUI库X协议 X Window System(X11)，第11个版本。 下一代改进协议Wayland，Wayland不仅仅是要完全取代X11，取代目前Linux桌面上X Client/X Server的设计理念。 注意事项：截至2020年大多数用于Linux的视频游戏和图形密集型应用程序仍为X11编写。但许多封闭源代码的图形驱动程序，例NVIDIA GPU的驱动程序都尚未完全提供对Wayland的支持。 X 协议由 X server 和 X client 组成： X server 管理主机上与显示相关的硬件设备，它负责屏幕画面的绘制与显示，以及将输入设备的动作告知 X client。 X client 应用程序端则主要负责事件的处理（程序的逻辑）。 Linux/Unix类操作系统上, $DISPLAY设置图形显示出处. graph LR A[X clients]--->B[Xlib来封装协议]; B--->C[X server]; C--->D[QT] C--->E[GTK] X clients 了Xlib来封装协议；Xlib不够方便，于是就有了qt和gtk，提供了很多窗口控件（widgets） X和XFree86 XFree86基于X协议实现免费X服务器软件 X Window System(X11)，第11个版本 X11R6 实际上是 X Protocol version 11 Release 6(X协议第11版第六次发行) X和XFree86： graph TD A[X协议]--->B[免费] A[X协议]--->C[商用] B--->D[xorg] B--->E[Xfree86] B--->F[Wayland] C--->G[MOTIF] XFree86只是实现X协议的一个免费X服务器软件.商业上常用MOTIF,现在还有XORG","link":"/8ee4d6e3.html"},{"title":"clang Data Type","text":"clang Data TypeC语言’\\0’的含义 \\0 是判定字符数组结束的标识 \\0 表示的是ASCII控制字符中空字符的含义，代码为NUL，非NULL \\0 本身占一个位置 \\0 在数组中占有空间但不显性 NUL和NULL的区别 NUL 是ASCII 字符集中 ‘\\0’ 字符的名字，它的字节模式为全 0。NULL 指一个其值为 0 的指针。它们都是整型值，其值也相同，所以它们可以互换使用。 符号 NULL 在头文件 stdio.h 中定义。另一方面，并不存在预定义的符号 NUL。 NULL 指针并不指向任何对象。除非是用于赋值或比较运算，出于其他任何目的的使用NULL指针都是非法的。 NULL是一个宏，它在几个标准头文件中定义，0是一个整型常量，’\\0’是一个字符常量，而NUL是一个字符常量的名字。术语都不可互换。 1、NULL就是空指针 2、0可以被用于任何地方，它是表示各种类型零值的符号并且编译器会挑出它 3、’\\0’应该只被用于结束字符串 4、NUL没有被定义于C和C++，它不应该被使用，除非你自己定义它，像：#define nul ‘\\0’ 空指针的用法 ： 用空指针终止对递归数据结构的间接引用 用空指针作函数调用失败时的返回值 用空指针作警戒值 加减乘除运算简写方式： 1234int a = 1, b = 2;a += 1; // a = a + 1;a *= (b-1); // a = a * (b-1);a -= (a+2); // a = a - (a+2); 特殊简写(自加或自增: ++ 和 – 自增运算符和自减运算符) 12345// a = a + 1a++;// a = a + 1++a; 前自增和后自增区别： ++ 在前面叫做前自增 ++ 在后面叫做后自增 – 在前面叫做前自减 – 在后面叫做后自减1234567891011121314int a = 1, b = 2;int a1 = ++a, b1 = b++; printf(&quot;a=%d, a1=%d\\n&quot;, a, a1);// 注意事项：b1=b++，b 值先赋值 b1，然后再加 1。printf(&quot;b=%d, b1=%d\\n&quot;, b, b1);//综合操作int a = 2, b = 1;int c = a - (b--); // 后自减，会先进行a-b运算，结果是 1，然后 b 再自减，就变成了 0；最后再将a-b的结果（也就是1）交给 c，所以 c 的值是 1。int d = (++a) - (--b); //b 的值已经变成 0。对于d=(++a)-(--b)，a 会先自增，变成 3，然后 b 再自减，变成 -1，最后再计算3-(-1)，结果是 4，交给 d，所以 d 最终是 4。printf(&quot;c=%d, d=%d\\n&quot;, c, d); 注意事项： 1.C语言中的除法运算,类型注意事项： **当除数和被除数都是整数时，运算结果也是整数；非整除则直接丢掉小数部分只保留整数部分，与小数赋值给整数类型同理。 除数和被除数中如含有小数，那么运算结果也是小数，double 类型小数。 2.取余注意事项： C语言中的取余运算 % 的两边都必须是整数，小数非法，否则编译器报错。余数可以是正数也可以是负数，由 % 左边的整数决定：如果 % 左边是正数，那么余数也是正数；如果 % 左边是负数，那么余数也是负数","link":"/8ed5dc39.html"},{"title":"clang macro","text":"C Macro 宏定义#define 宏定义命令，C语言预处理命令。标识符来表示一个字符串，代码运行中会将表示符进行全部替换成指定的字符串。 1234567#define N 1int main(){ int sum = 1 + N; printf(&quot;Output: %d\\n&quot;, sum); return 0;}// output: 2 宏定义和定义全局变量的区别和注意事项 作用时间不同：宏定义在编译期间即会使用并替换，而全局变量要到运行时才可以。 本质类型不同： 宏定义的只是一段字符，在编译的时候被替换到引用的位置。在运行中是没有宏定义的概念的。而变量在运行时要为其分配内存。 宏定义不可以被赋值，即其值一旦定义不可修改，而变量在运行过程中可以被修改。 宏定义只有在定义所在文件，或引用所在文件的其它文件中使用。全局变量可以在工程所有文件中使用，只需在使用前加一个声明就可以，即宏定义不支持extern模式。","link":"/c603c446.html"},{"title":"clang io format","text":"输入输出格式化终端输入 input键盘获取输入(三个函数)： scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据。 getchar()、getche()、getch()：这三个函数都用于输入单个字符。 gets()：获取一行数据，并作为字符串处理。 scanf()默认以空格分割： scanf() 在读取数据时需要的是数据的地址，字符串名字或者数组名字在使用的过程中自动会转换为内存地址，所以无需加&amp; int、char、float 等类型的变量用于 scanf() 时都要在前面添加&amp;，而数组或者字符串用于 scanf() 时不用添加&amp;，它们本身就会转换为地址。 scanf() 可以读取带空格的字符串，字符的数目，指定的字符，不读取某些字符，丢弃字符。 终端输出 output三个函数可以用来在显示器终端输出数据： puts()：仅输出字符串，并且输出结束后会自动换行 putchar()：仅输出单个字符 printf()：可以输出各种类型的数据 printf()缓存机制printf() 输出延迟问题： 12345678printf(&quot;输出1&quot;);//sleep() 是 Linux 和 Mac OS 下特有的函数，Sleep()是Windows函数sleep(2); // 延迟2sprintf(&quot;输出2&quot;); 本质上printf() 执行结束以后数据并没有直接输出到显示器上，而是放入了缓冲区，输出缓冲区直到遇见换行符\\n才将缓冲区中的数据输出到显示器上（Linux 或者 Mac OS 下运行）对缓存的理解，是处理C语言各种疑难问题的重要思路和方向。","link":"/5fc261d7.html"},{"title":"clang ANSI lib 标准差异汇总速查","text":"C(ANSI C)语言标准函数库C标准库概述基本说明从语言本身的角度(与平台无关)来说，标准C语言（ANSI C）共定义了15 个头文件，截至C11标准共包含29个头文件。 各标准差异： 标准名称 头文件差异 C89 15 标准头文件 C90、C89 标准头文件无差异, 排版存在差异 C95 +3 标准头文件 C99 +6 标准头文件 C11 +5 标准头文件 C17 无 C标准库按使用频度:常用： 一组： 1234stdio.hctype.hstdlib.hstring.h 二组： 1234assert.hlimits.hstddef.htime.h 三组： 1234567float.hmath.herror.hlocale.hsetjmp.hsignal.hstdarg.h 标准库备注 头文件 标准版本 备注 assert.h C89/C90 条件编译宏，将参数与零比较 ctype.h C89/C90 用于确定包含字符数据中的类型 errno.h C89/C90 报告错误条件宏,内含3个宏(EDOM 特定含义的错误，在math.h 中表示域错误;ERANGE 特定含义的错误，在math.h 中表示溢出错误;errno 库函数中用来盛放错误代码的宏) float.h C89/C90 浮点数类型,提供范围和精度的宏，包含了一组与浮点值相关的依赖于平台的常量 limits.h C89/C90 检测整型数据数据类型的表达值范围 locale.h C89/C90 本地化 math.h C89/C90 常用数学函数库 setjmp.h C89/C90 非局部跳转 signal.h C89/C90 信号处理 stdarg.h C89/C90 可变参数 stddef.h C89/C90 常用宏定义 stdio.h C89/C90 输入/输出 stdlib.h C89/C90 standard library标准库函数库：内存管理、程序工具、字符串转换、随机数 string.h C89/C90 字符串处理 time.h C89/C90 时间处理 wchar.h C95 扩展多字节和宽字符处理 wctype.h C95 包含了一系列用于检测和转换单个宽字符的函数库，wctype.h 是ctype.h的宽字符版本，wctype.h的出现晚于ctype.h。wctype.h的引入使C语言可以更好地处理英文以外的语言。 complex.h C99 复数运算 fenv.h C99 浮点数环境 inttypes.h C99 整数类型的格式转换 stdbool.h C99 布尔类型 stdint.h C99 定宽整数类型 tgmath.h C99 泛型数学（包装 math.h 和 complex.h 的宏） stdalign.h C11 alignas 与 alignof 便利宏 stdatomic.h C11 原子类型 stdnoreturn.h C11 noreturn 便利宏 threads.h C11 线程库 uchar.h C11 UTF-16 和 UTF-32 字符工具 运行时库C run-time library（CRT） C运行时库区别于C++语言的运行时库，指的是C程序运行时需要调用的库的函数，是一个相对概念 C运行时库由编译器生产商提供，亦称为第三方 C 运行库（Third party C run-time libraries） C运行时库一般是平台或系统提供，windows或linux，macos等。 Universal C Runtime 库（UCRT 库）通用C运行时库，包含多C库的头文件，Windows组件之一，自win10开始以系统发行方式部分提供。关联库： 对应的lib库为libucrt.lib 对应的dll库为ucrtbase.dll UCRT库文件： 库 关联的DLL 备注 选项 预处理器指令 libucrt.lib 无 将 UCRT 静态链接到你的代码。 /MT _MT libucrtd.lib 无 用于静态链接的 UCRT 调试版本。不可再发行。 /MTd _DEBUG,_MT ucrt.lib ucrtbase.dll UCRT 的 DLL 导入库。 /MD _MT,_DLL ucrtd.lib ucrtbased.dll UCRT 调试版本的 DLL 导入库。不可再发行。 /MDd _DEBUG,_MT,_DLL 标准库和运行时库的区别 C标准库再跨平台系统上，执行结果一致 C运行库是C标准库的扩展集，完全包含C标准库，但扩展的函数因不同的操作系统平台有差异 不同的操作系统，c运行时库执行的结果可能不同，但是对c标准库的支持是完全一致","link":"/f4ab9929.html"},{"title":"MySQL 8.0为什么使用utf8mb4_0900_ai_ci默认校对规则，而不使用utf8mb4_general_ci?","text":"MySQL 8.0 选择 utf8mb4_0900_ai_ci作为默认校对规则原因 主要的考虑主要基于对全球化支持的增强，基于Unicode 9.0规范，utf8mb4_0900_ai_ci在未来可以更容易地适应新的Unicode规范和扩展字符集。 更精确的字符处理以及适应现代应用需求等方面。 两者差异对比要点： 全球化支持的增强 更广泛的字符集支持：utf8mb4_0900_ai_ci支持Unicode 9.0标准，这意味着它可以存储和处理更多的字符，包括许多特殊的emoji表情和其他少见字符。这对于现代应用程序尤为重要，因为它们常常需要处理这些扩展字符集。 多语言环境的适用性：随着全球化的发展，应用程序需要支持多种语言和字符集。utf8mb4_0900_ai_ci不仅支持更多的语言和字符，还能更准确地处理这些语言中的特定字符问题。 国际化应用的优选：在涉及多语言和国际化处理的应用中，utf8mb4_0900_ai_ci能够提供更全面的支持，确保数据的准确性和一致性。 更精确的字符处理 不区分重音和大小写：与utf8mb4_general_ci相比，utf8mb4_0900_ai_ci在比较和排序字符时不区分重音和大小写。例如，‘é’和‘e’被认为是相同的字符，‘A’和‘a’也被认为是相同的字符。这种规则对于处理语言如西班牙语和法语等重音丰富的语言尤为重要。 基于Unicode 9.0的排序和比较规则：通过实现Unicode 9.0的排序和比较规则，utf8mb4_0900_ai_ci提供了更精确、更现代的Unicode支持。这确保了在数据库中对字符进行排序和比较时能够按照最新的国际化标准进行。 提升搜索和排序的准确性：由于其先进的排序规则，utf8mb4_0900_ai_ci能够更准确地处理涉及重音符号的字符排序，这在许多语言中是必需的。 适应现代应用需求 支持最新Unicode规范：Unicode规范不断更新，以包含更多的字符和修正现有的规则。utf8mb4_0900_ai_ci基于较新的Unicode 9.0规范，能够更好地适应未来的应用需求。 提高数据准确性：在需要高度准确的字符表示和处理的场景中，utf8mb4_0900_ai_ci能够提供更好的支持。例如，电子商务平台和内容管理系统等需要处理多语言字符并保持数据准确性的应用，都会从中受益。 满足多样化的使用场景：无论是国际化应用还是本地化要求高的应用，utf8mb4_0900_ai_ci都能提供强大的支持，满足多样化的使用场景。 性能与优化 性能的权衡考虑：虽然utf8mb4_0900_ai_ci在处理更复杂的排序和比较规则时可能会牺牲一定的性能，但这与其提供的其他优势相比是值得的。尤其是在现代硬件条件下，这种性能差异的影响越来越小。 优化字符存储和传输：通过支持更多的字符集，utf8mb4_0900_ai_ci能够在存储和传输数据时更加高效。特别是在处理Emoji表情和其他4字节字符时，其优势尤为明显。 适应高负载应用环境：在高负载和高并发的应用环境中，utf8mb4_0900_ai_ci能够保持较好的性能表现，同时确保数据的一致性和准确性。 兼容性与扩展性 向下兼容早期版本：尽管utf8mb4_0900_ai_ci是为MySQL 8.0及以上版本设计的，但它也在一定程度上保持了对早期版本的兼容。这使得升级数据库时能够更加平滑地过渡。 未来扩展的可能性：基于Unicode 9.0规范，utf8mb4_0900_ai_ci在未来可以更容易地适应新的Unicode规范和扩展字符集。这对于确保数据库系统在未来继续有效运行至关重要。 跨平台和跨系统的支持：由于其强大的兼容性和扩展性，utf8mb4_0900_ai_ci可以在各种平台和系统中使用，确保了广泛的应用范围。 概述MySQL 8.0采用utf8mb4_0900_ai_ci作为默认校对规则，主要是为了更好地适应全球化应用需求、提供更精确的字符处理能力、并确保数据库系统在未来的持续可用性和扩展性。尽管在性能上可能稍有牺牲(实际上经过mysql8.0版本的重构，性能损失可以不必过度考量)，但其带来的长期收益和对现代应用需求的支持使得这一选择具有显著的合理性和前瞻性。","link":"/93d6d12a.html"},{"title":"GitHub以及其他GIT平台中启用GPG2认证基本使用流程(MacOS)，增强身份识别和安全性","text":"base gnupg（version &gt;= 2.1.17,版本gnupg已包含gpg-agent）注意事项：gpg2默认交互式输入密码，有相应的解决方案。 brew install（推荐）：1brew install gnupg 版本信息（截至2022.06.19）1234567gnupg: stable 2.3.6 (bottled)GNU Pretty Good Privacy (PGP) packagehttps://gnupg.org//usr/local/Cellar/gnupg/2.3.6 (149 files, 13.3MB) * Poured from bottle on 2022-05-04 at 00:14:15From: https://mirrors.ustc.edu.cn/homebrew-core.git/Formula/gnupg.rbLicense: GPL-3.0-or-later 生成以及查看密钥 生成密钥(交互选择建议默认) 1gpg --full-generate-key 在提示时，指定要生成的密钥类型，或按 Enter 键接受默认值。 在提示时，指定想要的密钥大小，或按 Enter 键接受默认值。 密钥必须至少是 4096 位。 输入密钥的有效时长。 按 Enter 键将指定默认选择，表示该密钥不会过期。 验证您的选择是否正确。 输入您的用户 ID 信息。 查看已签发密钥 1gpg --list-secret-keys --keyid-format=long 查看指定公钥的信息(Prints the GPG key ID, in ASCII armor format) 1gpg --armor --export &lt;GPG key ID&gt; 复制公钥信息到GitHub上：从 -----BEGIN PGP PUBLIC KEY BLOCK----- 开始，到 -----END PGP PUBLIC KEY BLOCK----- 设置邮箱(建议全局默认一个常用Email)： 1git config --global user.email &quot;&quot; 设置项目开启GPG验证签名(不建议全局开启，可局部开启，防止影响其他平台或项目的提交引发连锁反应) 1git config commit.gpgsign true GPG密钥导出以及备份创建导出备份密钥文件的路径(例如)： 12# 注意：密钥备份完毕后建议清理此目录及文件夹！mkdir -p ~/GPGBAK 警告：导出的备份密钥为敏感文件，为了安全请确保密钥异地保存妥当后，清理导出当前的备份文件 备份GPG公钥 1gpg -o ~/GPGBAK/gpg_keys_github_macos --export &lt;GPG Key ID&gt; 备份GPG私钥 1gpg -o ~/GPGBAK/gpg_secret_keys_github_macos --export-secret-keys &lt;GPG Key ID&gt; 常见问题 在终端可能出现git提交commit时提交失败需要输入GPG密码解密密钥？ 可设置终端信息，然后重新开启一个终端生效。 错误信息： 12error: gpg 数据签名失败fatal: 写提交对象失败 解决方案： 1vim ~/.zshrc 12# GPG CONFIG (交互式窗口不弹出解决方案)export GPG_TTY=$(tty) GPG2密码缓存时间设置：默认文件不存在则创建 123456789touch ~/.gnupg/gpg-agent.conf``` **推荐**配置gpg-agent 选项(密码缓存有效时间(不建议ttl设置过长！) * GnuPG agent是一个帮助工具，当你运行gpg用于缓存私钥时会自动运行。* default-cache-ttl（seconds）：如果在失效期前，使用了相同名称的私钥，那么计数器会被重置，默认是600s（10min）* max-cache-ttl (seconds)：不论你最近是否使用过私钥，只要超过了此值，就需要进行重新验证，默认是30min。* **可设置长时间，但不建议太长**，还有一种是定期刷新有效时间，但需要配置系统任务容易遗忘所以不推荐。 default-cache-ttl 1800max-cache-ttl 7200 12重启 gpg-agent进程： echo RELOADAGENT | gpg-connect-agent 提交推送完成后GitHub仍然提示未验证？解决方案：检查本地提交的GIT默认邮箱和GitHub平台的登记邮箱是否一致，不一致可修改当前项目的邮箱保持和GPG一致即可。 其他平台如何设置？解决方案：其他GIT在线平台和GitHub操作方法基本一致。 请妥善保存和使用GPG签名密钥，防止敏感文件泄漏！","link":"/eadfec01.html"},{"title":"Go tool pprof性能监控调试工具基本使用说明","text":"Go tool pprof使用方式go中有pprof包来做代码的性能监控主要涉及两个pkg： 1234567891011#web服务器:import ( &quot;net/http&quot; _ &quot;net/http/pprof&quot;)#一般应用程序(实际应用无web交互)import ( &quot;net/http&quot; _ &quot;runtime/pprof&quot;) net/http/pprof中只是使用runtime/pprof包来进行封装了一下，并在http端口上暴露出来。 Go tool pprof辅助工具安装(图形工具graphviz为例) __Windows__：1.官方下载安装包: http://www.graphviz.org/download/下载Stable稳定版本(.msi)2.配置PATH系统环境变量：C:\\Program Files (x86)\\Graphviz2.38\\bin Linux(例：Centos) 方式1).添加repo依赖http://204.178.9.49/graphviz-rhel.repo 123yum list available 'graphviz*'yum install 'graphviz*' --skip-broken#备注：--skip-broken可选：跳过错误依赖，不加这个参数会提示安装包依赖错误，因为这里并不需要其它的安装包，所以跳过即可。 –skip-broken可选：跳过错误依赖，不加这个参数会提示安装包依赖错误，因为这里并不需要其它的安装包，所以跳过即可。 方式2).源码包编译安装./configuremakemake install MacOS:brew install graphviz Go tool pprof常用基本调试基本命令(默认30s采集时间，可通过–seconds)HTTP场景(参数可选:–text)：Heap profile: 1go tool pprof --text http://localhost:8080/debug/pprof/heap CPU profile: 1go tool pprof --text http://localhost:8080/debug/pprof/profile Goroutine blocking profile: 1go tool pprof --text http://localhost:8080/debug/pprof/block 1.实时通过地址查看浏览器: http://localhost:8080/debug/pprof/;2.通过生成的profile文件分析;选择指定的profile压缩gz文件(.gz),使用go tool pprof进入 12345go tool pprof http://localhost:8080/debug/pprof/profile#结束后直接进入交互：(pprof) web(pprof) 如查看历史调试文件信息，通过指定的profile文件进入即可:go tool pprof [*.gz] pprof交互基本命令：web 直接生成web浏览器可访问的svg图;(其他命令自行摸索)Windows下自动生成.svg文件且调用默认浏览器访问;MacOS下自动生成.gz文件，系统限制可根据提示文件路径通过手动访问查看; 【注意事项】：profile文件为空的问题, heap和block一般不受影响。执行交互web命令会报: 123(pprof) webprofile is empty(pprof) 产生原因：pprof内存分析器采取抽样的方式，它仅仅从一些内存分配的子集中收集信息。有可能对一个对象的采样与被采样对象的大小成比例。通过使用go test –memprofilerate标识，或者通过程序启动时 的运行配置中的MemProfileRate变量来改变调整这个采样的比例。如果比例为1，则会导致全部申请的信息都会被收集，但是这样的话将会使得执行变慢。默认的采样比例是每512KB的内存申请就采样一次。 方法1).在进行调试时，指定运行参数，或运行代码中动态调整参数1go tool pprof --text http://localhost:8080/debug/pprof/profile 此命令将会打印耗费最多CPU时间的函数列表。这里有几种可用的输出形式，最实用的有 –text, –web 和 –list。运行 “go tool pprof” 来得到完整的列表。 【备注】：实际测试时，MacOS下基本是空的,需要指定参数。 方法2).设置环境变量(此方法极不推荐!)设置Go环境变量 GODEBUG=”memprofilerate=1”. 通过控制采样的比例和行为，可以达到性能调试粒度的控制！","link":"/2188b831.html"},{"title":"Golang CHANGELOG History(截至2025.11.07的完整变更日志Changelog)","text":"Golang Changelog**： Go语言版本变更日志（截至2025.11.07的变更日志）Go 1.25 (2025年8月12日发布)发布日期: 2025年8月12日版本周期: 距离Go 1.24发布六个月兼容性: 保持Go 1的兼容性承诺 主要特性与改进: 语言与编译器: 大部分更改集中在工具链、运行时和库的实现优化 没有引入破坏性的语言变化 标准库增强: 新增encoding/json/v2包（通过GOEXPERIMENT=jsonv2标志启用），带来显著性能改进 修复了crypto/subtle、encoding/pem、net/url和os等包的多个问题 运行时优化: 容器感知运行时，更好地适应容器化环境 实验性功能支持，为未来版本奠定基础 性能改进: 运行时性能显著优化，提供更高效的执行体验 内存管理和垃圾回收进一步优化 Go 1.24 (2025年2月6日发布)发布日期: 2025年2月6日版本周期: 距离Go 1.23发布六个月，开发周期从2024年7月开始，11月下旬冻结，经过3个月测试完善 主要特性与改进: 语言特性: 泛型类型别名: 完全支持泛型类型别名，允许开发者以与定义泛型相同的方式参数化类型别名 弱指针支持: 引入全新的weak包，支持弱指针功能 终结器增强: 改进对象清理机制，提供更智能的资源管理 性能优化: CPU性能提升: CPU开销平均降低2-3% Map实现重构: 基于Swiss Tables的全新内置map实现，大幅提升map操作性能 内存分配优化: 更高效的小对象内存分配策略 垃圾回收改进: 更智能的垃圾回收与对象清理机制 工具链更新: 更智能的依赖管理 构建系统和测试工具的多项改进 文件系统访问: 目录范围的文件系统访问控制 增强的文件操作安全性和性能 版本维护: 定期安全更新，如go1.24.5（2025年7月8日发布）包含go命令的安全修复，以及编译器、链接器、运行时和go命令的错误修复 Go 1.23 (2024年8月6日发布)发布日期: 2024年8月6日 语言特性 迭代器语法转正：for-range循环支持使用函数作为range表达式，标准库slices和maps包新增迭代器支持 泛型类型别名预览：启用GOEXPERIMENT=aliastypeparams后可在包内使用泛型类型别名 包级变量初始化次序明确化：修正并明确包级变量初始化顺序 术语规范：澄清”严格可比较”和”类型约束”等术语，禁止匿名接口类型的循环定义 工具链 新增go telemetry命令：可选的遥测系统，支持on/local/off三种模式 构建结果JSON化：go build -json支持结构化输出 移除GOROOT_FINAL支持 运行时与编译器 Timer/Ticker改进： 未引用的Timer/Ticker可被GC立即回收，无需手动Stop Timer/Ticker的channel改为无缓冲，保证Stop/Reset后不接收旧值 PGO优化：通过重叠函数中局部变量的栈帧槽位减少栈使用，改善编译时间 架构支持：新增GOARM64和GORISCV64环境变量，支持openbsd/riscv64实验性端口 系统要求 macOS最低版本要求提升至11 Big Sur 最后一个支持Linux 2.6.32的版本（Go 1.24将要求Linux 3.17+） Go 1.22 (2024年2月6日发布)发布日期: 2024年2月6日 语言特性 For循环变量作用域修复：每次迭代创建新变量，解决循环变量意外共享问题 整数范围支持：支持for i := range n语法（n为整数） 标准库 新增math/rand/v2包：更简洁的API，更高质量的伪随机算法 新增go/version包：版本信息管理 net/http路由增强：支持方法（GET/POST等）和通配符（如/task/{id}/） database/sql新增Null[T]类型：更好的可空列处理 slices包新增Concat函数：连接多个切片 工具链 go vet增强：检测循环变量引用、log/slog键值不匹配等问题 go env -changed：列出非默认环境配置 go mod tidy -diff：预览文件变更而不实际修改 运行时 GC元数据优化：提升1-3% CPU性能，减少约1%内存开销 Windows/AMD64增强：支持SetUnhandledExceptionFilter捕获未处理异常 Go 1.21 (2023年8月8日发布)发布日期: 2023年8月8日 主要特性 min/max内置函数：支持任意可比较有序类型 clear内置函数：清空map或切片 结构化日志完善：log/slog包性能优化 panic调用栈改进：优化错误信息展示 工具链 Go工具链模块化：go命令使用语义化版本控制 **基于配置文件优化(PGO)**：正式稳定支持 go test覆盖率改进：支持集成测试覆盖率收集 标准库 新增maps包：map相关操作函数 新增slices包：切片操作函数（实验性） 性能 垃圾回收器优化：某些程序性能提升可达40% 内存分配器优化：减少锁竞争 Go 1.20 (2023年2月1日发布)发布日期: 2023年2月1日 语言特性 切片转数组指针简化：语法更简洁，无需unsafe包 工具链 应用覆盖率报告：扩展go test -cover支持应用整体覆盖率统计 废弃-i标志：go build/install/test不再支持-i标志 标准库 新增http.ResponseController：支持对正在进行的请求进行更精细控制 新增crypto/ecdh包：椭圆曲线Diffie-Hellman密钥交换 运行时 启动时间优化：减少约25%启动时间 GC暂停时间改善：大部分程序暂停时间&lt;100微秒 Go 1.19 (2022年8月2日发布)发布日期: 2022年8月2日 语言特性 内存模型修订：与C/C++/Java等主流语言内存模型保持一致 sync/atomic新类型：新增Bool, Int32, Int64, Uint32, Uint64, Uintptr, Pointer等类型 运行时 新增SetMemoryLimit：runtime/debug.SetMemoryLimit限制Go内存使用 文档注释增强：支持链接、列表和更清晰的标题 标准库 net/http超时改进：Server.ConnContext支持设置连接级超时 移植性 新增LoongArch 64位支持：linux/loong64端口 Go 1.18 (2022年3月15日发布)发布日期: 2022年3月15日 语言特性 泛型正式发布：支持类型参数、类型约束，实现算法复用 函数迭代器预览：range over func（需GOEXPERIMENT=rangefunc） 工具链 Fuzzing测试：首个将模糊测试集成到标准工具链的主要语言 工作区模式：解决本地多模块开发依赖问题（go work命令） 编译性能：AMD64架构性能提升20%（寄存器ABI扩展） 标准库 新增net/netip包：更高效的IP地址处理 crypto/tls：默认使用TLS 1.2+ crypto/x509：默认拒绝SHA-1签名证书 性能改进 CPU性能提升：ARM64和PowerPC64上提升高达20% Go 1.17 (2021年8月16日发布)发布日期: 2021年8月16日 语言特性 切片转数组指针：支持(*[N]T)(slice)语法，运行时边界检查 工具链 构建约束新语法：引入//go:build替代旧的// +build 模块图裁剪：go.mod更精简 运行时 寄存器ABI扩展：64位ARM架构性能提升10%+ 垃圾回收优化：暂停时间进一步降低 标准库 新增io/fs包：抽象文件系统接口 embed包转正：正式支持静态资源嵌入 Go 1.16 (2021年2月16日发布)发布日期: 2021年2月16日 语言特性 embed包：静态资源编译时嵌入 io/fs包：文件系统抽象 工具链 Module成为默认：GO111MODULE默认开启 Mac Apple Silicon支持：darwin/arm64端口 标准库 net/http：HTTP/2推送支持改进 archive/zip：性能优化 Go 1.15 (2020年8月11日发布)发布日期: 2020年8月11日 运行时 GC优化：典型GC暂停时间&lt;1ms 链接器优化：链接速度提升20%，二进制体积减小 标准库 time包性能提升：T削弱对cgo的依赖 Go 1.14 (2020年2月25日发布)发布日期: 2020年2月25日 运行时 goroutine抢占调度：基于信号的异步抢占，解决长时间占用CPU问题 defer性能提升：defer性能提升30% 工具链 Module支持生产环境：模块缓存改进 Go 1.13 (2019年9月3日发布)发布日期: 2019年9月3日 工具链 数字字面量语法：支持0b二进制、0o八进制、0x十六进制及下划线分隔 错误包装：标准库支持%w格式化动词 标准库 新版TLS 1.3：crypto/tls默认启用TLS 1.3 Go 1.12 (2019年2月25日发布)发布日期: 2019年2月25日 运行时 GC优化：写入屏障优化，减少约10-30%内存占用 工具链 Module实验性支持：GO111MODULE引入 标准库 crypto/tls：性能和安全改进 Go 1.11 (2018年8月24日发布)发布日期: 2018年8月24日 主要特性 Modules：引入Go模块系统，解决GOPATH依赖管理问题 WebAssembly支持：实验性支持Go编译为Wasm Go 1.10 (2018年2月16日发布)发布日期: 2018年2月16日 工具链 构建缓存：go build引入构建缓存，大幅提升构建速度 测试缓存：go test结果缓存 标准库 strings.Builder：高效字符串构建 Go 1.9 (2017年8月24日发布)发布日期: 2017年8月24日 标准库 type alias正式支持：类型别名语法稳定 sync.Map：并发安全的map实现 运行时 垃圾回收优化：并行GC，减少STW时间 Go 1.8 (2017年2月16日发布)发布日期: 2017年2月16日 标准库 context包进入标准库：提供取消和超时机制 sort.Slice：基于回调的切片排序 运行时 GC延迟优化：STW时间降至毫秒级 defer性能改进：延迟调用开销降低 Go 1.7 (2016年8月15日发布)发布日期: 2016年8月15日 主要特性 context包引入（实验性） 编译器优化：编译速度提升，二进制体积缩小20-30% 移植性 Linux on IBM z Systems：新增linux/s390x端口 Go 1.5 (2015年8月19日发布)发布日期: 2015年8月19日 重大变革 自举编译：Go编译器完全用Go重写，不再依赖C语言 GC重写：引入并发GC，STW时间大幅缩短 Go 1.4 (2014年12月10日发布)发布日期: 2014年12月10日 工具链 go generate：代码生成工具引入 internal包：支持internal目录可见性约束 Go 1.3 (2014年6月18日发布)发布日期: 2014年6月18日 运行时 栈管理优化：分段栈改为连续栈 标准库 sync.Pool：对象池机制引入 Go 1.2 (2013年12月1日发布)发布日期: 2013年12月1日 语言特性 三索引切片：introduced slice[low:high:max] syntax 测试覆盖率：go test支持覆盖率统计 Go 1.1 (2013年5月13日发布)发布日期: 2013年5月13日 主要改进 性能大幅提升：编译器和运行时优化 Method values：支持将方法作为函数值 Go 1.0 (2012年3月28日发布)发布日期: 2012年3月28日 里程碑 首个稳定版本：Go 1兼容性承诺开始 语言规范确定：奠定后续版本基础 版本发布周期 常规周期：每年2月、8月发布两个版本 维护策略：当前版本bug修复，前两个版本安全更新 兼容性：遵循Go 1兼容性承诺，保证向后兼容 官方Release CHANGELOG参考go.dev/doc/devel/release","link":"/3ba902b3.html"},{"title":"Go:chain operation","text":"chain operation链式调用注意事项 本身为较宽泛的概念 链式调用的场景： 返回值是一个函数或方法(很少有实际意义)； 方法链（func chain或method chain）:返回值是一个对象时，可以直接调用对象绑定的方法； 链式调用方法链是包含关系，严格意义上说，链式调用​ ≠ 方法链； 链式调用的优点 调用过程更接近自然语言，链式呈现可读性好； 参数列表复杂化的方法极大简化清晰； 精简代码量，避免主操作对象反复的书写； 优势:设计上，操作与数据分离、解耦; 链式调用的缺点 开发者需要记住调用的层数，层数不能过多。 每次调用都需要创建很深的调用堆栈，效率相对较低。 链式操作的实质（函数OR方法）操作 =》 返回对象 =》继续操作返回对象所属函数OR方法 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;type A struct { Aa string Ab int}func (p *A) SetAa(aa string) *A { p.Aa = aa return p //返回操作对象}func (p *A) SetAb(ab int) *A { p.Ab = ab return p //返回操作对象}func (p *A) Print() { fmt.Printf(&quot;Aa:%s || Ab:%d\\n&quot;, p.Aa, p.Ab)}func main() { varA := &amp;A{} varA.SetAa(&quot;Aa&quot;).SetAb(100).Print()}","link":"/b45ac9b7.html"},{"title":"Go:方法值(func value) 和 方法表达式(func expression)","text":"方法值(func value) &amp; 方法表达式(func expression)依据函数或方法具备两大特点： 1.函数本身是一种类型T； 2.函数变量：函数或方法本身储存在变量中； 方法值方法值的本质是调用时隐藏了接收者，和传统调用是等价的； 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;type A struct { name string}func (a *A) SetValue () { fmt.Println(&quot;set&quot;)}func main() { aa := A{&quot;Jaco&quot;} //传统调用 aa.SetValue() //方法值，调用时隐藏接收者 vFunc := aa.SetValue vFunc() //方法表达式，调用时隐藏接收者 aFunc := (*A).SetValue //显式传递接收者,等价于aa.SetValue() aFunc(&amp;aa)}","link":"/78f4f0b0.html"},{"title":"Go:func 函数","text":"func 函数func函数（适用于method）小结Go函数数也是一种类型，可以和其他类型一样被保存在变量中。和接口一样，接口也是一种类型。 12345678910111213package mainimport ( &quot;fmt&quot;)func foo() { fmt.Println(&quot;foo&quot;)}func main() { var f func() f = foo f()} Go函数类型实现接口——把函数作为接口来调用函数体实现接口函数的声明不能直接实现接口，需要将函数定义为类型后，使用类型实现结构体。当类型方法被调用时，还需要调用函数本体。 1234567891011121314// 函数定义为类型type FuncCaller func(interface{}) // func(interface{}) 定义为 FuncCaller 类型。// 实现Invoker的Callfunc (f FuncCaller) Call(p interface{}) { // 调用f()函数本体 f(p) //FuncCaller 的 Call() 方法将实现 Invoker 的 Call() 方法。 // FuncCaller 的 Call() 方法被调用与 func(interface{}) 无关，还需要手动调用函数本体。}//代码备注：//以上函数类型，需要函数本身进行逻辑处理。FuncCaller 无须被实例化，只需要将函数转//换为 FuncCaller 类型即可，函数来源可以是命名函数、匿名函数或闭包。 HTTP实现场景：函数 handler() 转为 HandlerFunc 类型，HandlerFunc 类型实现了 Handler 的 ServeHTTP 方法，底层可以同时使用各种类型来实现 Handler 接口进行处理。 1234567891011121314151617181920212223HTTP 包中包含有 Handler 接口定义，代码如下：type Handler interface { ServeHTTP(ResponseWriter, *Request)}Handler 用于定义每个 HTTP 的请求和响应的处理过程。同时，也可以使用处理函数实现接口，定义如下：type HandlerFunc func(ResponseWriter, *Request)func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r)}要使用闭包实现默认的 HTTP 请求处理，可以使用 http.HandleFunc() 函数，函数定义如下：func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler)}而 DefaultServeMux 是 ServeMux 结构，拥有 HandleFunc() 方法，定义如下：func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { mux.Handle(pattern, HandlerFunc(handler))}上面代码将外部传入的函数 handler() 转为 HandlerFunc 类型，HandlerFunc 类型实现了 Handler 的 ServeHTTP 方法， 底层可以同时使用各种类型来实现 Handler 接口进行处理。 Go可变参数函数调用注意事项（three dots） 若将 string 数组切片，每项独自传入函数，则会执行[]T{arg1,arg2}等类似操作，从新进行初始化； 若将 interface{} 数组切片打散后直接传入函数，则不再进行对象的创建，直接试用该对象； Go … three dots 用法：变长的函数参数（逐一传参用法）调用参数最后一个…T，在参数列表的最后使用若干个类型为T的参数。…T在函数内部的类型实际是[]T. 调用拥有变长参数列表的函数slice类型参数不必拆分调用，直接在slice后跟… 标识数组元素个数例如[…]int{1,2,3} Go命令行中的通配符描述包文件的通配符。会执行当前目录和所有子目录的所有包： 12345go test ./...go run ./...go build ./..","link":"/4f443298.html"},{"title":"Proverbs from @rob_pike&#39;s inspiring talk at Gopherfest SV 2015 (video)","text":"Go Proverbs Simple, Poetic, Pithy Don't communicate by sharing memory, share memory by communicating. Concurrency is not parallelism. Channels orchestrate; mutexes serialize. The bigger the interface, the weaker the abstraction. Make the zero value useful. interface{} says nothing. Gofmt's style is no one's favorite, yet gofmt is everyone's favorite. A little copying is better than a little dependency. Syscall must always be guarded with build tags. Cgo must always be guarded with build tags. Cgo is not Go. With the unsafe package there are no guarantees. Clear is better than clever. Reflection is never clear. Errors are values. Don't just check errors, handle them gracefully. Design the architecture, name the components, document the details. Documentation is for users. Don't panic. Proverbs from @rob_pike's inspiring talk at Gopherfest SV 2015 (video). The Gopher character is based on the Go mascot designed by Renée French and copyrighted under the Creative Commons Attribution 3.0 license. These proverbs are the basis of a talk by Rob Pike and the list may be updated when he next gives the talk. Please read the contribution guidelines before opening an issue to nominate a new proverb.","link":"/5978836a.html"},{"title":"Jaco Liu Golang personal summary combing notes","text":"Jaco Liu Golang personal summary combing notesJaco Liu Golang personal summary notes GoJaco Liu contact Item Contact Author Jaco Liu Email ljqlab@163.com WeChat laulinux QQ 404691073 Blog https://www.wdft.com I love Go，Simple, efficient, practical, engineered …The world of programming should be pluralistic, free from any one mindset.EN English DocumentsEnglish Documents zh_CN 中文README_CN","link":"/5767103d.html"},{"title":"Go:goroutine","text":"goroutineGolang不使用OS层process而使用语言层面（Goroutine）处理 并发 &amp; 并行 Task任务方案(针对业务来说)的个人思考和实践思路随想 —Jaco Liu 秋1.使用OS层面进程管理，虽然成本低廉快捷，但对CPU的性能开销比较大，Golang通过Goroutine的引入，构建一种SandBox沙箱容器式的方案，可以将并发处理任务放在语言层面内部，“隔离“在系统层面之上，构建Goroutine池的同时，也能保证在性能可靠的前提下，安全性也增强。 目前大规模分布式系统的整体方向，大部分也都是建立在OS系统层之上(而非系统层面)以达到可控的标准控制，将OS系统级内核CPU的开销降到最低保证OS层流畅运行，这也让Linux为代表的服务器OS系统更“专注”做Base底层基础性的业务支撑。 2.系统层面上，抛开编程语言层面不谈，服务端越来越趋于Service服务化和分布式、集群化，以此应对越来越复杂的业务。现有编程语言历史遗留和生态环境等因素处理的成本较高，针对多核CPU使用率也不高，性能问题凸显。Golang在服务器端的优势在于，非常低成本将开发人员从以前的单进程类编程语言中解放，提供最低成本快速转变为并行编程的思维模式。Goroutine并发执行的模式，不放在系统进程处理，好处：（1）.安全隔离型设计，限制进程中Task Process处理的边界，在大规模集群服务器中使用相对统一的标准处理方式，最大限度规避OS层面的差异带来的问题；（2）.降低OS进程的开销，不因golang的执行导致拖累系统CPU资源；（3）.并发Task任务行为和状态可控，内存占用开销小，容量自由扩展；（4）.轻量级在协程处理时可靠性高；（5）.使用这种机制，可以较低成本构建大型和可伸缩计算和批处理Task任务的应用和程序，一开始Golang的定位就是系统级编程语言，所以二进制的运行性能不会差，现阶段的语言性能之争毫无意义。 目前业内针对业务处理的大型系统应用的常态应该至少包含两点：1.支持最小成本组织大规模数据和计算处理；2.Task任务的行为和状态能够可靠、低成本可控。 云计算追求对服务端在安全可控的前提下软硬件资源的最低成本配置和最佳的资源调度，做的所有分布式、自由伸缩、集群的重要原因也是源为此，Goroutines在这方面大有可为。 官方一句话说得比较直白和代表性：Do not communicate by sharing memory; instead, share memory by communicating.不要通过共享内存进行通信，而是通过通信共享内存。 明确并发和并行的两个概念：并发不是并行：并发是由切换时间来实现“同时”运行，并行是多核多线程goroutine 通过通信来共享内存，而不是共享内存来通信。这样就可以较为充分利用多核CPU和内存资源的同时，又相对比较可靠，”协程”也是类似种”管道”的思维模式，在这里，通信显得比较重要，这些Golang已经做了底层化实现，对开发者来说比较简便一些，大部分精力放在管理好这些阀门出入口即可。Linux的管道是非常优秀的设计。 这个应该不是说以前的方案或其他语言处理思路是错误、不佳或有偏差的，历史上很多方案往往受制于硬件的运算性能综合因素考虑，是当时权衡下来的最好的方案，比如硬件成本太高等，现在随着软硬件的快速发展和成本低廉有这个条件来做这个事情了。终归是有当时基于现实情况的各种因素考量。无论性能再怎么快，必须把可靠性放在重要位置，一个相对不可靠的方案，程序运行速度再快将毫无意义，我想这是Golang从软件工程化考虑的重要考量吧。 Golang设计哲学和Unix应该是一致的：大道至简，“简”是对大规模工程化系统开发中最好的思考范畴，虽万变仍不离其宗。 并发&amp;并行的编程理念对开发人员来说是未来编程思维的常态，事物发展的规律。 至少在公司产品和项目开发中，Golang至少是未来主力的语言，因为随着数据的不断增长，必须要一种从性能上，可靠性上和开发上相对最合适的技术选型，Golang是很符合这一点的，Golang不只是一个简单的编程语言这么简单。C系的开发语言经久不衰很重要的原因就是追求用最简单的方式解决现实问题，Golang是未来考虑的主力开发语言。 个人实践思路示意： ——— Jaco Liu 秋 Date：2017-05-30","link":"/6480b1cd.html"},{"title":"Go:init()","text":"init()init()函数特性 init()在main包执行之前 init()自动执行,不能显示调用 同一个Go文件中可定义多个init()函数，顺序执行 同一个package中不同文件，将文件名按字符串进行字母和数字自然排序，之后顺序调用各文件中的init() import导入： 字符 _ (下划线)操作，本质是引入package且不直接使用内部函数，仅仅调用init()初始化 按照import导入顺序调用包中init() package的init()在被引用时自动被调用 package存在依赖，调用顺序为最后被依赖的最先被执行初始化 package被其他多个包import，只能被初始化一次","link":"/5ae2eb16.html"},{"title":"Go:interface","text":"interface 接口go：interface{}、断言与类型转换 Go的接口更大的作用是声明方法集合，而非类型约束。 interface{}可用于向函数传递任意类型的变量，但对于函数内部，该变量仍然为interface{}类型（空接口类型），故必须进行类型断言确认类型后检查才能使用（不能直接隐式转换）。 接口类型向普通类型的转换称为类型断言(运行期确定)。 接口转换基本原则 普通类型 =》 接口类型：编译器运行时隐式转换。 接口类型 =》普通类型：必须显式类型断言。 超集和子集转换关系：超转子可以，子转超不可以。 断言推荐方式：1234567b,ok:=a.([]int)if ok{ ...}//断言失败在编译阶段不会报错，故很可能出现断言失败导致运行错误。 1.断言的作用：使用interface{}时，解决空接口类型向普通类型转换的类型转换问题； 2.普通类型之间的转换，使用显式的类型转换，否则后果严重不可控。 interface值传递注意事项： 如果接口实现方法，类型自己的实现使用的是值接收器，那么在传递值的时候无论使用指针还是值都可以。 如果接口实现方法，类型自己的实现使用的是指针接收器，那么在传递值的时候必须传递地址。12345原因：编译器不能自动获得一个未声明地址。结构体类型定义的方法可以被该结构体的指针类型调用；而结构体类型调用该指针类型的方法时是被转换成指针，不是直接调用。接口实现方法时，用指针类型实现的接口函数只能算是指针类型实现的，用结构体类型实现的方法也作为是指针类型实现。 interface{} 与 []interface{}12var dataSlice []int = foo()var interfaceSlice []interface{} = dataSlice 编译错误 1cannot use dataSlice (type []int) as type []interface { } in assignment 任何类型赋值给interface{}，不能把任何类型的切片赋值到[]interface{} 不能 直接将某些[]MyType切片赋值给[]interface{}， 他们背后代表的数据意义不同。 12345678910 //编译错误//t := []int{1, 2, 3, 4} wrong //var s []interface{} = t //正确t := []int{1, 2, 3, 4} //right s := make([]interface{}, len(t)) for i, v := range t { s[i] = v } 接口转换 利用类型推断，可判断接口对象是否某个具体的接口或类型。 还可用 switch 做批量类型判断，不支持 fallthrough。 超集接口对象可转换为子集接口，反之出错。 原因： []interface{}类型 不是 interface{}类型， 它是一个切片，切片元素的类型恰好是interface{}。 []interface{}类型变量拥有特定的内存结构，这在编译时就已经决定。每个interface{}占两个字（word)，一个字用于存放interface存放的类型，另一个字用于存放实际数据或者是指向数据的指针。于是长度为N的[]interface{}类型切片背后是一个N2字长的一块数据。这与一般的[]MyType类型切片不同，相同长度的[]MyType切片背后的数据块大小为Nsizeof(MyType)字长。 使用方式：如果想得到一个元素为任意类型的列表的容器，并且在索引其中元素之前会把它转换为原本的数据类型，可以直接使用interface{}即可。此种方式很通用（如果 不是编译时类型安全 的）也很快速。 接口类型内存布局(原理)interface在内存上实际由两个成员组成 tab指向虚表(Virtual Table) data则指向实际引用的数据。 虚表描绘了实际的类型信息及该接口所需要的方法集。 接口的底层结构runtime.h 123456789101112131415161718192021struct Iface{ Itab* tab; void* data;};struct Itab{ InterfaceType* inter; Type* type; void (*fun[])(void);};struct Itab{ InterfaceType* inter; Type* type; void (*fun[])(void);};//只有 tab 和 data 都为 nil 时，接口才等于 nil。 接口Demo： 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot;)type People interface { Do()}type Student struct { UserId int UserName string}func (s Student) Do() { s.UserName = &quot;Jaco Liu&quot; return}func main() { stu := Student{1, &quot;Jaco&quot;} p := People(stu)// //a.Do() fmt.Printf(&quot;%T %v&quot;, p, p)} People接口本身，底层含有tab虚表和data实际存储的值两部分； :123456789101112131415161718192021222324**通过接口进行函数调用** ，实际的操作其实就是```p.tab-&gt;fun[0](p.data)```; ###### 参考Go和C++的虚表的异同：* C++： * c++ 的虚表是在编译时生成的，注意：表现出的多态是在runtime运行时决定; * 每个class创建了一个方法集(虚表); * 当子类重写父类的虚函数时，就将表中的相应函数指针改为子类自己实现的函数; * 如果没有则指向父类的实现; * 当面临多继承时，C++对象结构里就会存在多个虚表指针，每个虚表指针指向该方法集的不同部分。* Go: * Go 接口的虚表是在runtime运行时生成； * ``` p := People(Student{1, &quot;Jaco&quot;})```生成People接口对应于Student类型的虚表，并将其缓存。###### 原因：* Go无继承关系，采用的是组合方式，所以不能进行虚表初始化(多少类型实现了某个接口，单个类型到底实现了多少接口这让编译器无从获知.* 选择在运行时生成虚表是自然的方案，放到runtime运行时，只要在需要接口的去分析一下类型是否实现了接口的所有方法即可，这样避免了去维护大量继承和绑定关系的心智负担，此并不会带来性能上的太大问题。* Go接口组合的方案和C++反其道而行之，本质上来说，各有优缺点。#### 接口技巧让编译器检查，以确保某个类型实现接口。``` var _ fmt.Stringer = (*Data)(nil) ```某些时候，让函数直接 &quot;实现&quot; 接口能省不少事。 type Tester interface { Do()} type FuncDo func()func (self FuncDo) Do() { self() } func main() { var t Tester = FuncDo(func() { println(“Hello, World!”) }) t.Do()}","link":"/512e106c.html"},{"title":"Go:interface原理详解-接口由使用者定义，而不是由实现者定义。","text":"接口设计模式的常见疑惑Golang接口由使用者定义，而不是由实现者定义。开发常见的疑惑：“如果接口是使用者定义的，那使用者怎么知道实现者有没有那个方法？会不会猜错？是不是反而更难用了？” 这个问题是很多人的困惑，而且触及了 Go 接口设计哲学中最容易让人困惑的核心矛盾： “如果接口是使用者定义的，那使用者怎么知道实现者有没有那个方法？会不会猜错？是不是反而更难用了？” 我们来一层层拆解这个疑问，你会发现：Go 的设计其实不是“让使用者去猜”，而是“让能力自然暴露”。 ❓ 问题本质：使用者真的需要“猜”吗？不需要。 在 Go 中，接口不是凭空定义的，而是基于已有的方法行为来定义的。也就是说：你先看到某个类型有 ToString() 方法，然后你才定义 Stringable 接口，而不是反过来。 举个实际开发场景：你正在用一个第三方库，比如： 12type Config struct { ... }func (c Config) String() string { return &quot;...&quot; } 你想写一个通用日志函数，能打印任何“能转成字符串”的对象。 你看到 Config 有 String() 方法（通过文档、IDE 提示、源码），于是你写： 1234567type Loggable interface { String() string // 注意：名字和第三方库一致！}func Log(l Loggable) { fmt.Println(l.String())} ✅ 你不是在“猜”，而是在观察已有行为后，提炼出共性。 🆚 和 Java 的对比：谁更“反人类”？ Java Go 接口定义时机 实现者提前定义接口（implements） 使用者按需定义接口（隐式满足） 耦合性 实现者必须知道接口存在 实现者完全不知道接口存在 扩展性 无法让第三方类实现你的接口 任何有对应方法的类型自动“实现”你的接口 心智负担 实现者要规划接口 使用者只需观察方法签名 👉 Go 把“抽象”的权力交给了最需要它的人——使用者。而 Java 把“契约”的责任压给了实现者。 🤔 那如果方法名不一样怎么办？比如有人用 ToString()，有人用 String()？这确实是现实问题，但 Go 的解法是： 标准库和社区约定优先，小接口降低冲突 比如： Go 标准库中，几乎所有类型如果要转字符串，都实现 String() string（这是 fmt 包约定的） 所以你定义接口时，直接用 String() string，就能兼容大量类型 如果某个类型用了 ToString()，你可以： 自己包一层适配器（wrapper） 或者就别强求统一，直接调用它的方法 Go 不追求“万物归一”，而是“按需组合”。 💡 关键认知转变： Go 的接口不是“设计契约”，而是“行为匹配”。 你不是在“猜测实现者有什么接口”，而是在说： “我需要一个有 Xxx() Yyy 方法的对象，不管它是谁，只要它有，我就用。” 这就像你去租房子，不会说“你必须是‘正规房东接口’的实现类”，而是说： “只要你有房产证、能签合同、能收租，我就租你的房。”——不管你是个人房东、中介、还是 Airbnb。 ✅ 举个极端但真实的例子：标准库 io.Reader123type Reader interface { Read(p []byte) (n int, err error)} 这个接口是 Go 标准库定义的（使用者视角），但成千上万的类型都“自动实现”了它： os.File bytes.Buffer net.Conn strings.Reader 甚至你自己写的 MyCustomStream 这些类型的作者在写代码时可能根本没看过 io.Reader 的定义，但他们提供了 Read([]byte) (int, error) 方法，于是就能被 io.Copy、ioutil.ReadAll 等函数使用。 👉 这就是“使用者定义接口”的威力：无需协调，自然兼容。 🧠 最后总结：为什么你觉得“更复杂”？因为你可能还在用 “面向接口设计” 的思维（像 Java 那样），而 Go 是 “面向行为组合”。 不要一开始就定义接口 先写具体类型和方法 当多个地方出现重复逻辑时，再提炼接口 接口只为当前使用场景服务，越小越好 Go 的哲学是：“If it walks like a duck and quacks like a duck, it’s a duck.”（走起来像鸭子，叫起来像鸭子，它就是鸭子。） 你不需要鸭子“声明自己是鸭子”，你只需要它表现出鸭子的行为。 如果你还是觉得别扭，那很正常——这是从“显式契约”到“隐式能力”的思维切换。但一旦你在一个真实项目中遇到“需要统一处理多个第三方类型”的场景，你就会发现 Go 这种方式极其灵活、极其解耦。 为什么说这是“Go 的精髓”？解耦：实现者不需要知道谁会用它，使用者也不需要修改实现者的代码。灵活：你可以给任何已有类型（包括标准库类型）“赋予”接口能力，只要它有对应方法。小而专：Go 鼓励定义小接口（比如 io.Reader 只有一个 Read() 方法），用的时候按需组合。 实际上 Go 标准库就是这么干的！比如 io.Copy(dst Writer, src Reader) 中的 Writer 和 Reader 接口，是标准库定义的，但成千上万的类型（文件、网络连接、buffer 等）都“自动”实现了它们，而它们的作者根本没看过 io 包的源码。 Golang的interface设计静态编译语言的类型安全、类似动态语言的灵活性以及组件间的解耦三者之间取得了精妙的平衡。这种平衡正是 Go 语言“务实”哲学的体现，工程实践的价值。要知道在此之前，想做到“静”和“动”的结合，很多解决方案都存在问题因为引入过多的中间层最后被放弃，Go不是最完美的，但是相对实用的解决方案，而且Go语言的静态类型检查、编译、运行速度非常高效，说interface是Go语言的“灵魂”“ 之一不夸张。","link":"/82c2ce4a.html"},{"title":"Go:new,make,struct{}","text":"new,make,struct{} 函数 适用范围 返回值 填充值 make() 仅限创建类型(slice map channel) 引用，make返回复杂的结构为slice时:它是一个包含3个域的结构体：指向slice中第一个元素的指针，slice的长度，以及slice的容量。 非零值，make(T, args)返回一个初始化的(而不是置零)，类型为T的值（而不是*T）。之所以有所不同，是因为这三个类型的背后引用了使用前必须初始化的数据结构 new() 所有类型 指针，new返回一个指向已清零内存的指针，而make返回一个复杂的结构。 零值，new(T)会为T类型的新项目，但new它并不初始化内存，只是将其置零 备注：直接使用struct{} 来初始化strut时，返回的是一个struct类型的值，而不是指针。","link":"/96edd24c.html"},{"title":"Go:JSON","text":"JSONjson.Marshal()默认转换规则：1.布尔型转换为 JSON 后仍是布尔型 ， 如true -&gt; true2.浮点型和整数型转换后为JSON里面的常规数字，如 1.23 -&gt; 1.233.字符串将以UTF-8编码转化输出为Unicode字符集的字符串，特殊字符比如&lt;将会被转义为\\u003c 4.数组和切片被转换为JSON 里面的数组，[]byte类会被转换为base64编码后的字符串，slice的零值被转换为null5.结构体会转化为JSON对象，并且只有结构体里边以大写字母开头的可被导出的字段才会被转化输出，而这些可导出的字段会作为JSON对象的字符串索引6.转化一个map 类型的数据结构时，该数据的类型必须是 map[string]T（T 可以是encoding/json 包支持的任意数据类型） json.Unmarshal()注意：如果JSON中的字段在Go目标类型中不存在，json.Unmarshal() 函数在解码过程中会丢弃该字段。未知类型,遵循规则：1.JSON中的布尔值将会转换为Go中的bool类型2.数值会被转换为Go中的float64类型3.字符串转换后还是string类型4.JSON数组会转换为[]interface{} 类型5.JSON对象会转换为map[string]interface{}类型6.null值会转换为nil","link":"/72259ecc.html"},{"title":"Go:null judge","text":"null judgeint空值是0，string空值是””而不是null或者nil（区别Slice空值是长度为0的map空值是nil，error空值是nil，struct空值是一个“所有成员都是空值”的空Struct而不是nil， 不能单纯地判断一个struct是不是nil，因为它永远不可能是nil，可以通过返回一个error来判断是否为空，golang标准库里的常见做法：if err != nil","link":"/31b42193.html"},{"title":"Go:Map","text":"Map 要点注意事项 map 是引用类型的： 内存用 make 方法来分配。 new，永远用 make 来构造 map。new() 分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址。 当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。 特殊用法用切片作为 map 的值 12mp1 := make(map[int][]int)mp2 := make(map[int]*[]int) 只遍历键KEY时，使用下面的形式,无须将值改为匿名变量形式，忽略值即可: 123for key := range mapData { //Code ...} map清空：无相关函数和方法。截至Go 1.12，清空唯一办法就是重新 make 一个新的 map。但担心垃圾回收的效率，Go的GC的回收效率远高于一个清空函数。 map并发安全注意事项sync.Map有以下特性： 无须初始化，直接声明即可。 sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用。 Store 表示存储， Load 表示获取， Delete 表示删除。 遍历操作 Range加回调函数，回调函数返回内部遍历出来的值。 Range 参数中的回调函数的返回值功能是： 需要继续迭代遍历时，返回 true； 终止迭代遍历时，返回false。 12345678910#定义var mapData sync.Map#遍历所有sync.Map中的键值对mapData.Range(func(k, v interface{}) bool { fmt.Println(&quot;list-kv: %v , %v&quot;, k, v) return true})","link":"/73ca5667.html"},{"title":"Go:polymorphism","text":"polymorphism多态特性 多态：同一件事情由于条件不同产生的结果不同； 由于Go语言中结构体不能相互转换，所以没有结构体类型的多态，只有基于接口的多态。这符合Go语言对面向对象的诠释； 多态和泛型的区别 泛型是当我们使用这个泛型类时候再去确定这个类里面的成员具体什么类型的，两者本质不是一个层次，多态不能实现泛型。 多态是在继承层面上，即根据实际运行时候来确定具体的实现。 泛型本质上并不是多态的一种特例，多态并不能实现泛型。 引入泛型的本质是为了安全，把编译时能发现的错误不带到runtime运行时。","link":"/165668dc.html"},{"title":"Go:fmt.Printf() 格式化占位符","text":"fmt.Printf() 格式化占位符格式符 fmt.Printf(&quot;%v&quot;, variable) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 【通用占位符】 v 值的默认格式。 %+v 添加字段名(如结构体) %#v 相应值的Go语法表示 %T 相应值的类型的Go语法表示 %% 字面上的百分号，并非值的占位符 # 【布尔值】 %t true 或 false# 【整数值】 %b 二进制表示 %c 相应Unicode码点所表示的字符 %d 十进制表示 %o 八进制表示 %q 单引号围绕的字符字面值，由Go语法安全地转义 %x 十六进制表示，字母形式为小写 a-f %X 十六进制表示，字母形式为大写 A-F %U Unicode格式：U+1234，等同于 &quot;U+%04X&quot;# 【浮点数及复数】 %b 无小数部分的，指数为二的幂的科学计数法， 与 strconv.FormatFloat中的 'b' 转换格式一致。例如 -123456p-78 %e 科学计数法，例如 -1234.456e+78 %E 科学计数法，例如 -1234.456E+78 %f 有小数点而无指数，例如 123.456 %g 根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 %G 根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出# 【字符串和bytes的slice表示】 %s 字符串或切片的无解译字节 %q 双引号围绕的字符串，由Go语法安全地转义 %x 十六进制，小写字母，每字节两个字符 %X 十六进制，大写字母，每字节两个字符# 【指针】 %p 十六进制表示，前缀 0x 这里没有 'u' 标记。若整数为无符号类型，他们就会被打印成无符号的。# 【精度和对齐方式】 〔输出最少宽度〕〔．精度〕〔长度〕类型 &quot;%-md&quot; ：左对齐，若m比实际少时，按实际输出。 &quot;%m.ns&quot;：输出m位，取字符串(左起)n位，左补空格，当n&gt;m or m省略时m=n &quot;%m.nf&quot;：输出浮点数的输出宽度对齐，m为宽度，n为小数点右边数位# 【宽度和精度】 指示符(`f')为例： %f: 默认宽度和精度 %mf 宽度m, 默认精度 %.nf 默认宽度, 精度n %m.nf 宽度m, 精度n %m.f 宽度m, 精度0 若遇到浮点数的指示符(`f')的话，它表示小数部分的位数。 若遇到浮点数的指示符(`e', `E', `g', `G')的话，它表示有效位数 若将精度设为`*'的话，将从参数中提取精度的值 整数的指示符(`d', `i', `b', `o', `x', `X', `u') 其中对于字符串％s或者浮点类型％f,来说，精度可以截断数据的长度 &quot;%-md&quot; ：左对齐，若m比实际少时，按实际输出。 &quot;%m.ns&quot;：输出m位，取字符串(左起)n位，左补空格，当n&gt;m or m省略时m=n# 【显示参数占位符】 %[2]d, %[1]d 以%d为例：先输出第二个值，再输出第一个值.# 【特殊格式标识符】 + 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。 - 左对齐 # 备用格式： 为八进制添加前导 0（%#o）， 为十六进制添加前导 0x（%#x）或0X（%#X），为 %p（%#p）去掉前导 0x； 对于 %q，若 strconv.CanBackquote 返回 true， 就会打印原始（即反引号围绕的）字符串； 如果是可打印字符，%U（%#U）会写出该字符的 Unicode编码形式（如字符 x 会被打印成 U+0078 'x'）。 ' ' （空格）为数值中省略的正负号留出空白（% d）； 以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开 0 填充前导的0而非空格；对于数字，这会将填充移到正负号之后","link":"/8aaf9686.html"},{"title":"Go:pointer","text":"pointer 指针基于指针对象的方法当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法，如下： func (p *Point) ScaleBy(factor float64) { p.X *= factor p.Y *= factor}这个方法的名字是(Point).ScaleBy。这里的括号是必须的；没有括号的话这个表达式可能会被理解为(Point.ScaleBy)。 在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。我们在这里打破了这个约定只是为了展示一下两种方法的异同而已。 只有类型(Point)和指向他们的指针(*Point)，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子： type P intfunc (P) f() { / … */ } // compile error: invalid receiver type想要调用指针类型方法(*Point).ScaleBy，只要提供一个Point类型的指针即可，像下面这样。 r := &amp;Point{1, 2}r.ScaleBy(2)fmt.Println(*r) // “{2, 4}”或者这样： p := Point{1, 2}pptr := &amp;ppptr.ScaleBy(2)fmt.Println(p) // “{2, 4}”或者这样: p := Point{1, 2}(&amp;p).ScaleBy(2)fmt.Println(p) // “{2, 4}”不过后面两种方法有些笨拙。幸运的是，go语言本身在这种地方会帮到我们。如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法： p.ScaleBy(2)编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如p.X，以及array和slice内的元素比如perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到： Point{1, 2}.ScaleBy(2) // compile error: can’t take address of Point literal但是我们可以用一个Point这样的接收器来调用Point的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号来取到该变量即可。编译器在这里也会给我们隐式地插入*这个操作符，所以下面这两种写法等价的： pptr.Distance(q)(*pptr).Distance(q)这里的几个例子可能让你有些困惑，所以我们总结一下：在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的： 不论是接收器的实际参数和其接收器的形式参数相同，比如两者都是类型T或者都是类型*T： Point{1, 2}.Distance(q) // Pointpptr.ScaleBy(2) // Point或者接收器实参是类型T，但接收器形参是类型T，这种情况下编译器会隐式地为我们取变量的地址： p.ScaleBy(2) // implicit (&amp;p)或者接收器实参是类型*T，形参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量： pptr.Distance(q) // implicit (pptr)如果命名类型T(译注：用type xxx定义的类型)的所有方法都是用T类型自己来做接收器(而不是T)，那么拷贝这种类型的实例就是安全的；调用他的任何一个方法也就会产生一个值的拷贝。比如time.Duration的这个类型，在调用其方法时就会被全部拷贝一份，包括在作为参数传入函数的时候。但是如果一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这样可能会破坏掉该类型内部的不变性。比如你对bytes.Buffer对象进行了拷贝，那么可能会引起原始对象和拷贝对象只是别名而已，但实际上其指向的对象是一致的。紧接着对拷贝后的变量进行修改可能会有让你意外的结果。 译注： 作者这里说的比较绕，其实有两点： 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C艹的人这里应该很快能明白。","link":"/a753c2b9.html"},{"title":"Go:reflect 反射","text":"reflect 反射反射性能的一般原则基准测试结果的数值分析的一般原则建议： 能使用原生代码时，尽量避免反射操作。 提前缓冲反射值对象，对性能有很大的帮助。 避免反射函数调用，实在需要调用时，先提前缓冲函数参数列表，并且尽量少地使用返回值。 reflect 包类型定义12345678910111213141516171819202122232425262728293031323334//reflect 包类型定义type Kind Signconst ( Invalid Kind = iota // 非法类型 Bool // 布尔型 Int // 有符号整型 Int8 // 有符号8位整型 Int16 // 有符号16位整型 Int32 // 有符号32位整型 Int64 // 有符号64位整型 Uint // 无符号整型 Uint8 // 无符号8位整型 Uint16 // 无符号16位整型 Uint32 // 无符号32位整型 Uint64 // 无符号64位整型 Uintptr // 指针 Float32 // 单精度浮点数 Float64 // 双精度浮点数 Complex64 // 64位复数类型 Complex128 // 128位复数类型 Array // 数组 Chan // 通道 Func // 函数 Interface // 接口 Map // 映射 Ptr // 指针 Slice // 切片 String // 字符串 Struct // 结构体 UnsafePointer // 底层指针)","link":"/53f6e137.html"},{"title":"Go:slice 切片本质","text":"go 切片：本质数组Go的切片是在数组之上的抽象数据类型，因此在了解切片之前必须要要理解数组。数组类型由指定和长度和元素类型定义。数组不需要显式的初始化；数组元素会自动初始化为零值： Go的数组是值语义。一个数组变量表示整个数组，它不是指向第一个元素的指针（比如C语言的数组）。当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。（为了避免复制数组，你可以传递一个指向数组的指针，但是数组指针并不是数组。）可以将数组看作一个特殊的struct，结构的字段名对应数组的索引，同时成员的数目固定。 切片数组虽然有适用它们的地方，但是数组不够灵活，因此在Go代码中数组使用的并不多。但是，切片则使用得相当广泛。切片基于数组构建，但是提供更强的功能和便利。切片的类型是 []T，T 是切片元素的类型。和数组不同的是，切片没有固定的长度。切片的字面值和数组字面值很像，不过切片没有指定元素个数：切片可以内置函数 make 创建，函数签名为：func make([]T, len, cap) []TT 代表被创建的切片元素的类型。函数 make 接受一个类型、一个长度和一个可选的容量参数。调用 make 时，内部会分配一个数组，然后返回数组对应的切片。当容量参数被忽略时，它默认为指定的长度。下面是简洁的写法：s := make([]byte, 5)可以使用内置函数 len 和 cap 获取切片的长度和容量信息。len(s) == 5cap(s) == 5 长度和容量之间的关系。零值的切片类型变量为 nil。对于零值切片变量，len 和 cap 都将返回 0。切片也可以基于现有的切片或数组生成。切分的范围由两个由冒号分割的索引对应的半开区间指定。切片的开始和结束的索引都是可选的；它们分别默认为零和数组的长度。 切片的本质一个切片是一个数组切割区间的描述。它包含了指向数组的指针，切割区间的长度，和容量（切割区间的最大长度）。切片并不复制整个切片元素。它创建一个新的切片执行同样的底层数组。这使得切片操作和数组索引一样高效。因此，通过一个新切片修改元素同样会影响到原始的切片。切片增长不能超出其容量。增长超出切片容量将会导致运行时异常，就像切片或数组的索引超出范围引起异常一样。同样，不能使用小于零的索引去访问切片之前的元素。切片生长（复制和追加）要增加切片的容量必须创建一个新的、更大容量的切片，然后将原有切片的内容复制到新的切片。整个技术是一些支持动态数组语言的常见实现。循环中复制的操作可以由 copy 内置函数替代。copy 函数将源切片的元素复制到目的切片。它返回复制元素的数目。func copy(dst, src []T) intcopy 函数支持不同长度的切片之间的复制（它只复制最小切片长度的元素）。此外，copy 函数可以正确处理源和目的切片有重叠的情况。但大多数程序不需要完全的控制，因此Go提供了一个内置函数 append，用于大多数场合；它的函数签名：func append(s []T, x …T) []Tappend函数将x追加到切片s的末尾，并且在必要的时候增加容量。如果是要将一个切片追加到另一个切片尾部，需要使用…语法将第2个参数展开为参数列表。可以声明一个零值切片（nil），然后在循环中向切片追加数据： 可能的“陷阱”切片操作并不会复制底层的数组。此层的数组将被保存在内存中，直到它不再被引用。有时候可能会因为一个小的内存引用导致保存所有的数据。 Go 切片扩容机制详解：容量增长与内存对齐的底层逻辑（重要提示）在 Go 语言中，切片（slice）是日常开发中最常用的数据结构之一。它灵活、高效，支持动态增长。然而，当我们频繁使用 append 向切片添加元素时，其底层容量（cap）是如何增长的？为什么有时实际分配的容量会“略大于”我们预期的值？本文将结合 Go 源码，深入剖析切片扩容机制，特别是容量增长策略与内存对齐对最终分配大小的影响。 一、切片的基本结构回顾Go 的切片本质上是一个结构体，包含三个字段： 12345type slice struct { array unsafe.Pointer // 指向底层数组 len int // 长度 cap int // 容量} len：当前元素个数； cap：从 array 开始到底层数组末尾的可用元素总数； 当 len == cap 时，再执行 append 就会触发扩容（reallocation）。 二、扩容的核心逻辑：growsliceGo 的切片扩容由运行时函数 growslice 实现（位于 runtime/slice.go）。其核心目标是：在满足新容量需求的前提下，尽量减少内存分配次数，同时兼顾内存效率。 扩容策略概览 若原容量为 0：新容量至少为 1（或所需最小容量）； 若原容量 &lt; 1024：大致翻倍（×2）； 若原容量 ≥ 1024：每次增长约 25%（×1.25）； 最终容量需 ≥ 所需最小容量（即 len + 新增元素数）； 为内存对齐，实际分配可能略大于计算值。 三、内存对齐：为什么“略大”？即使我们计算出“理想新容量”为 1600，Go 实际分配的容量可能是 1632 或 1664。这是因为在分配内存时，Go 会考虑内存对齐（memory alignment），以提升 CPU 访问效率并满足底层分配器的要求。 对齐原理简述现代 CPU 在访问内存时，对某些数据类型（如 int64、指针）要求其地址是 8 字节对齐的。Go 的内存分配器（如 mallocgc）会将请求的内存大小向上对齐到特定的“尺寸类”（size class），这些尺寸类是预定义的、对齐友好的块大小。 因此，即使你只需要 1600 个 int（假设 int 为 8 字节，共 12800 字节），分配器可能会分配一个 13056 字节 的块（对应容量 1632），因为这是最接近且满足对齐要求的尺寸类。 四、结合代码验证我们通过一个实验观察实际扩容行为： 123456789101112131415161718192021// grow_test.gopackage mainimport &quot;fmt&quot;func main() { s := make([]int, 0, 1000) // 初始 cap=1000 fmt.Printf(&quot;初始: len=%d, cap=%d\\n&quot;, len(s), cap(s)) // 追加 25 个元素，使 len=1025 &gt; cap=1000，触发扩容 for i := 0; i &lt; 25; i++ { s = append(s, i) } fmt.Printf(&quot;扩容后: len=%d, cap=%d\\n&quot;, len(s), cap(s)) // 继续追加，观察下一次扩容 for i := 0; i &lt; 300; i++ { s = append(s, i) } fmt.Printf(&quot;再次扩容后: len=%d, cap=%d\\n&quot;, len(s), cap(s))} 输出（Go 1.22）： 123初始: len=0, cap=1000扩容后: len=25, cap=1280再次扩容后: len=325, cap=1632 分析： 初始 cap=1000，属于 ≥1024 的临界点附近； 第一次扩容：期望容量 = 1000 + 25 = 1025； 按 1.25 倍增长：1000 × 1.25 = 1250； 但 1250 &lt; 1025？不成立，实际应为 max(1250, 1025) = 1250； 然而实际 cap=1280，比 1250 大 —— 这就是内存对齐的结果； 第二次扩容：从 1280 增长 25% → 1600，但实际分配 1632。 💡 注意：Go 1.18+ 对增长算法做了优化，确保增长后容量至少满足需求，并考虑对齐。 五、源码片段解析（Go 1.22）以下是 runtime/slice.go 中 growslice 的关键逻辑（简化）： 12345678910111213141516171819202122232425262728293031func growslice(et *_type, old slice, cap int) slice { newcap := old.cap doublecap := newcap + newcap if cap &gt; doublecap { newcap = cap } else { if old.cap &lt; 1024 { newcap = doublecap } else { // Check 0 &lt; newcap to detect overflow for 0 &lt; newcap &amp;&amp; newcap &lt; cap { newcap += newcap / 4 } // 如果仍不够，直接设为 cap if newcap &lt;= 0 { newcap = cap } } } // 内存对齐：计算所需字节数，并向上对齐 var overflow bool uintptr(newcap) * et.size // 检查溢出 newcap, overflow = roundupsize(uintptr(newcap) * et.size) if overflow { panic(errorString(&quot;growslice: cap out of range&quot;)) } newcap = int(newcap / et.size) // 转回元素个数 // 分配新数组...} 关键点： roundupsize 是内存对齐的核心函数，它将请求的字节数向上舍入到最近的对齐尺寸类； 最终 newcap 是对齐后的字节数除以元素大小，因此可能略大于理论计算值。 六、对开发者的启示 预分配容量：若能预估元素数量，使用 make([]T, 0, N) 可避免多次扩容和数据拷贝； 不要依赖具体扩容倍数：Go 版本升级可能调整策略； 大容量切片注意内存开销：扩容虽平缓，但底层数组一旦分配，直到无引用才会释放； 性能敏感场景慎用 append：可考虑 copy + 预分配或使用 sync.Pool 缓存切片。 七、结语Go 切片的扩容机制是性能与内存效率之间精妙平衡的体现。它不仅考虑了算法层面的增长策略（小切片翻倍、大切片缓增），还深入到系统底层，通过内存对齐确保运行效率。理解这一机制，有助于我们写出更高效、更可预测的 Go 代码。 📌 记住：Go 的设计哲学是“简单但不简陋”——看似自动的 append 背后，是运行时精心优化的工程智慧。 参考： Go 源码：src/runtime/slice.go Go 内存分配器：src/runtime/malloc.go 《Go 语言高级编程》——切片与内存管理章节 本文基于 Go 1.22 编写，不同版本行为可能略有差异。建议在关键项目中通过实测验证。","link":"/647ce9cb.html"},{"title":"Go:string","text":"string常用拼接方法 += 来拼接 bytes.Buffer strings.Builder ( &gt;= go1.10 ) 拼接方法性能对比 使用 += 的方法性能是最慢的，性能消耗相对最大; Buffer和Builder性能相差无几，Builder在内存的使用上要略优于Buffer; 官方推荐strings.Builder，优点: 性能好，代码清晰;","link":"/765e2161.html"},{"title":"Go:关于Go语言:结构体(Struct)-方法(Method)-接收者(Receiver)类型的适用场景选择和命名约定(Go官方建议)","text":"关于Go语言:结构体(Struct)-方法(Method)-接收者(Receiver)类型的适用场景选择和命名约定(Go官方建议)何时使用值类型场景1.如果接受者是一个 map，func 或者 chan，使用值类型(因为它们本身就是引用类型)。2.如果接受者是一个 slice，并且方法不执行 reslice 操作，也不重新分配内存给 slice，使用值类型。3.如果接受者是一个小的数组或者原生的值类型结构体类型(比如 time.Time 类型)，而且没有可修改的字段和指针，又或者接受者是一个简单地基本类型像是 int 和 string，使用值类型就好了。 一个值类型的接受者可以减少一定数量的垃圾生成，如果一个值被传入一个值类型接受者的方法，一个栈上的拷贝会替代在堆上分配内存(但不是保证一定成功)，所以在没搞明白代码想干什么之前，别因为这个原因而选择值类型接受者。 使用指针类型场景1.如果方法需要修改接受者，接受者必须是指针类型。2.如果接受者是一个包含了 sync.Mutex 或者类似同步字段的结构体，接受者必须是指针，这样可以避免拷贝。3.如果接受者是一个大的结构体或者数组，那么指针类型接受者更有效率。4.从此方法中并发的调用函数和方法时，接受者可以被修改吗？一个值类型的接受者当方法调用时会创建一份拷贝，所以外部的修改不能作用到这个接受者上。如果修改必须被原始的接受者可见，那么接受者必须是指针类型。5.如果接受者是一个结构体，数组或者 slice，它们中任意一个元素是指针类型而且可能被修改，建议使用指针类型接受者，这样会增加程序的可读性。 Receiver接收者的命名1.社区约定的接受者命名是类型的一个或两个字母的缩写(像 c 或者 cl 对于 Client)。2.避免使用泛指的名字像是 me，this 或者 self，也避免使用过度描述的名字；3.如果你在一个地方使用了 c，那么就不要在别的地方使用 cl； 自我总结一般使用场景下，决定是否使用指针，看数据单体(结构体、接口等等…)容量的大小(特别注意:注意切片slice、字典map、管道channel本身引用类型，底层本身是指针调用)，语言层面数据单体存储的形式是否本身就是指针类型，数据单体的作用范围和操作的范围，归根结底，还是要结合实际具体业务场景提前规划好数据结构,开发中多考虑数据单体的拷贝成本是否过高。Go官方的使用建议，也是在Go内存分配和数据存储原理上的归纳总结。Go语言虽然有指针但是没有包含指针计算，指针的操作也非常简单(这点考量特别地好,简单的结构可以让GC最低成本地监测内存运行状态,避免过多的指针关联,利于GC内存管理和回收)。","link":"/b5903345.html"},{"title":"Go:struct","text":"struct面向对象Class类的底层实现从某些方面说就是结构体，对象的引用就是指针，只是语言把他们封装起来了而已。Golang的Struct结构体（源于C语言，但又有别于C）的灵活性：go语言中并没有像C++，Java语言中这类的Class，它只含有像C语言中的结构体，用结构体和指针等特性，完成一个类的作用，很巧妙的使用了指针和结构体，不仅是go的面向对象，包括go语言中的map等操作都是借助了结构体。其实，说白了，C++、Java等面向对象的语言中，类的底层实现就是结构体，对象的引用就是指针，只是语言把他们封装起来了而已。很多人刚接触面向对象很不理解这些东西也应该缘于此。 或者说，面向对象的封装在某种意义上是以牺牲灵活特性的为代价的一种抽象简化。 所有高级语言(PHP、Java、Python、JavaScript等等…)的数组Array、字典map、Slice切片、Json等结构类型往往只是叫法不一样，多少都源于C系或者受到C系的Struct结构体思想的影响,在某些特定领域内，做了一些针对性的解决方案。 PHP就是c语言实现的一套高级“程序”语言，只不过是这套“程序化的语言”的规范和语法等机制可以用来快速做web领域的事情，通过解释器，转成底层语言完成代码的最终执行。 这也印证了很多答案往往追根溯源都在计算机数据结构基础里没有捷径可以走。 golang struct注意事项：对于struct类型来说，字段的先后顺序是非常关键的。如果两个struct类型包含了完全相同的字段，但是排列顺序不同或者进行了部分合并，那么这两个struct就是不同的类型！ 如果struct字段是大写字母开头，那么该字段就是导出的（包外可见），这也符合Go语言的可见性规则。因此一个struct可以同时包含导出和未导出的变量。","link":"/527244e6.html"},{"title":"Go:switch","text":"switchswitch 注意事项 fallthrough不能用在switch的最后一个分支。","link":"/8709d8d0.html"},{"title":"Go:package time","text":"package timetime 转换注意事项Go语言指定时间原点 123456789101112package mainimport ( &quot;time&quot; &quot;fmt&quot;)func main() { //当前时间格式化，记忆规律：创始年份2016 | 一 | 二 | 三（15时，即 3 pm） | 四 | 五 nowTime := time.Now().Format(&quot;2006-01-02 15:04:05&quot;) fmt.Println(nowTime)}","link":"/b5c88baa.html"},{"title":"Go:type关键词总结","text":"type关键词总结type 用法： 定义结构体 定义接口 类型别名 类型定义 类型开关 类型定义和类型别名的区别：区别就是类型定义是完全定义了一种新的类型，而类型别名只是给现有的类型取了一个别名alias。（编译器会替换成基本类型。） Type常见Demo定义结构体12type Demo struct {} 定义接口12type Demoer interface {} 类型别名12type Demo string 类型定义12type handle func(str string) 类型开关1234567891011func Demo(params ...interface{}) { for i, x := range params { switch x.(type) { case bool: fmt.Printf(&quot;type #%d is bool&quot;,i) default: fmt.Printf(&quot;type is unknow&quot;) } }} 类型注意事项类型比较备注：参考Go文档type说明： 命名类型（简单类型），有类型名称如 int, int64, float, string, bool. 还有自定义的命名类型。 非命名类型（复杂类型），没类型名称 array slice, map，func(){}, interface{}。但是chan类型是可以==比较。 slice 内存不连续，底层对象分开放的，不能直接比较； map 内存不连续，底层对象独立存放，不能直接比较； chan 内存是连续的，单一对象，可以直接比较； 当比较两个命名类型的时候，类型名称必须一样；当比较命名类型和非命名类型的时候，底层类型一样即可。 比较基于两个原则：1.内存底层基本类型；2.类型本身是否确定类型或不稳定类型； 空接口值比较 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type T1 []stringtype T2 []stringfunc main() { foo0 := []string{} foo1 := T1{} foo2 := T2{} fmt.Println(reflect.TypeOf(foo0)) fmt.Println(reflect.TypeOf(foo1)) fmt.Println(reflect.TypeOf(foo2)) // Output: // []string // main.T1 // main.T2 //编译通，反之亦然 //foo1 = foo0 //foo0 = foo1 // 编译不通过 // 错误提示：cannot use foo2 (type T2) as type T1 in assignment foo2 = foo0 foo1 = foo2 //cannot //编译通过：chan ch1 := make(chan int) ch2 := make(chan int) fmt.Println(ch1 == ch2) //编译不通过：slice s1 := []int{1,2} s2 := []int{2,1} fmt.Println(s1 == s2) //编译不通过：map m1 := make(map[int]int) m2 := make(map[int]int) fmt.Println(m1 == m2)} 类型可比较性判断原则：底层数据结构类型是否稳定和一致 类型 说明 map 宕机错误，不可比较 切片（[]T） 宕机错误，不可比较 通道（channel） 可比较，必须由同一个 make 生成，也就是同一个通道才会是 true，否则为 false 数组（[容量]T） 可比较，编译期知道两个数组是否一致 结构体 可比较，可以逐个比较结构体的值 函数 可比较","link":"/49c8ae5b.html"},{"title":"JavaScript map function grammatical sugar trap","text":"Don’t pursue techniques that seem too fancy, or they may backfire(不要追求看似过于花哨的技巧，否则可能适得其反) 12let m = [10, 10, 10].map(parseInt);document.write(m);","link":"/ad4a4750.html"},{"title":"LinuxCentos7-Systemd-Service自定义编写Service应用服务配置说明整理","text":"Centos7-Systemd-Service自定义编写Service应用服务配置说明整理系统基本service服务配置目录（此目录勿动，一般情况下只放系统核心基础服务配置，否存放应用注册类服务配置）：/etc/systemd/system 自定义服务配置管理目录（存放自定义应用注册类服务和第三方服务类配置）：/usr/lib/systemd/system/ 自定义.service配置文件 (权限：754) 格式（以应用app-run.service为例, 执行文件作好超时处理！）：12345678910111213141516171819202122232425[Unit]Description=&quot;app-run@Author Jaco Liu Process Daemon&quot; # 服务描述After=rc-local.service # 服务类别： # 例启动顺序(默认在rc-local.service之后调用执行) [Service]Type=forking # 优先使用forking方式: # (遵循传统Unix做法,设置PIDFile=选项 # 帮助systemd准确定位该服务的主进程)PIDFile=/var/run/app-run.pid # 设置应用进程的PID（缺省）Environment=&quot;GOPATH=/usr/local/go&quot; # 环境变量设置，可设置多个Environment=项 # 备注：Environment= 或 EnvironmentFile= # 引用文件, 两种方式皆可ExecStart=/data/auto_run.sh start # 调用启动可执行文件： # （Service配置全部使用绝对路径， # 可执行文件内命令用绝对的路径格式） ExecReload=/data/auto_run.sh reload # 重新加载（缺省）ExecStop=/data/auto_run.sh stop # 停止服务（缺省）DefaultTimeoutStartSec=30 # 服务启动允许的最大时长，超时时间（默认无单位:秒） # 单位：&quot;ms&quot;(毫秒), &quot;s&quot;(秒), &quot;min&quot;(分钟), # &quot;h&quot;(小时), &quot;d&quot;(天), &quot;w&quot;(周) PrivateTmp=True # 是否分配独立的临时空间（缺省） [Install]WantedBy=multi-user.target EnvironmentFile默认约定引用存放目录一般为：/usr/lib/systemd/system/app-run.service.d/environment.conf(格式：Key=Value) Service服务管理常用操作命令12345678在开机时启用一个服务：systemctl enable app-run.service 在开机时禁用一个服务：systemctl disable app-run.service启动一个服务：systemctl start app-run.service 关闭一个服务：systemctl stop app-run.service 重启一个服务：systemctl restart app-run.service 显示一个服务的状态：systemctl status app-run.service 查看服务是否开机启动：systemctl is-enabled app-run.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled 注意：服务无法执行检查SElinux是否开启，自行关闭SElinux。","link":"/27eb580e.html"},{"title":"Centos7-chattr权限问题导致锁定文件无法解锁且root用户无法编辑","text":"chattrchattr 命令，专门用来修改文件或目录的隐藏属性。在部分linux发行版中，部分存在chattr本身执行权限移除的默认设置，导致root用户无法编辑相关文件且chattr命令无法修改文件属性。解决的思路是先解决chattr本身的文件属性，确保chattr可用。 解决方案如下： 解决方案1234567891011cp /usr/bin/chattr /usr/bin/chattr_bakchmod 755 /usr/bin/chattr_bakchattr_bak -i /usr/bin/chattrchmod 755 /usr/bin/chattrls -la /usr/bin/chattr","link":"/e7a4c7e2.html"},{"title":"OpenSSH 配置文件体系","text":"全局配置文件12345678910111213141516171819202122232425262728293031323334/etc/ssh/# 保存Diffie-Hellman组通过密钥交换构建安全的网络传输层/etc/ssh/moduli# 缺省的SSH客户端配置文件/etc/ssh/ssh_config# sshd守护进程的配置文件/etc/ssh/sshd _config# sshd守护进程的DSA私钥/etc/ssh/ssh_host_dsa_key# sshd守护进程的DSA公钥/etc/ssh/ssh_host_dsa_key.pub# sshd守护进程的SSH协议版本1的RAS私钥/etc/ssh/ssh_host_key# sshd守护进程的SSH协议版本1的RAS公钥/etc/ssh/ssh_host_key.pub# sshd守护进程的SSH协议版本2的RAS私钥/etc/ssh/ssh_host_rsa_key# sshd守护进程的SSH协议版本2的RAS公钥/etc/ssh/ssh_ho st_rsa_key.pub# sshd守护进程的PAM配置文件/etc/pam.d/sshd # sshd服务的配置文件/etc/sysconfig/sshd 用户1234567891011121314151617181920212223242526~/.ssh/# 服务器用来验证SSH客户端的客户公钥~/.ssh/authorized_keys# 用户的DSA私钥~/.ssh/id_dsa # 用户的DSA公钥~/.ssh/id_dsa. pub# 用户的SSH协议版本2的RSA私钥~/.ssh/id_rsa # 用户的SSH协议版本2的RSA公钥~/.ssh/id_rsa.pub# 用户的SSH协议版本1的RSA私钥 ~/.ssh/identity# 用户的SSH协议版本的RSA公钥~/.ssh/identity.pub# 用户连接的SSH服务器公钥~/.ssh/known_hosts SSH Tunnel 安全隧道","link":"/fc526729.html"},{"title":"firewalld services 防火墙内嵌服务","text":"firewalld services 防火墙内嵌服务Configuration file path: /usr/lib/firewalld/services按字母顺序: 12345678910amanda-client.xml amanda-k5-client.xml bacula-client.xml bacula.xml bitcoin-rpc.xml bitcoin-testnet-rpc.xml bitcoin-testnet.xml bitcoin.xml ceph-mon.xml ceph.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697cfengine.xml condor-collector.xml ctdb.xml dhcpv6-client.xml dhcpv6.xml dhcp.xml dns.xml docker-registry.xml dropbox-lansync.xml elasticsearch.xml freeipa-ldaps.xml freeipa-ldap.xml freeipa-replication.xml freeipa-trust.xml ftp.xml ganglia-client.xml ganglia-master.xml high-availability.xml https.xmlhttp.xmlimaps.xml imap.xml ipp-client.xml ipp.xml ipsec.xml iscsi-target.xml kadmin.xml kerberos.xml kibana.xml klogin.xml kpasswd.xml kshell.xml ldaps.xml ldap.xml libvirt-tls.xml libvirt.xml managesieve.xml mdns.xml mosh.xml mountd.xml mssql.xml ms-wbt.xml mysql.xml nfs.xml nrpe.xml ntp.xml openvpn.xml ovirt-imageio.xml ovirt-storageconsole.xml ovirt-vmconsole.xml pmcd.xml pmproxy.xml pmwebapis.xml pmwebapi.xml pop3s.xml pop3.xml postgresql.xml privoxy.xml proxy-dhcp.xml ptp.xml pulseaudio.xml puppetmaster.xml quassel.xml radius.xml RH-Satellite-6.xml rpc-bind.xml rsh.xml rsyncd.xml samba-client.xml samba.xml sane.xml sips.xml sip.xml smtp-submission.xml smtps.xml smtp.xml snmptrap.xml snmp.xml spideroak-lansync.xml squid.xml ssh.xmlsynergy.xml syslog-tls.xml syslog.xml telnet.xml tftp-client.xml tftp.xml tinc.xml tor-socks.xml transmission-client.xml vdsm.xml vnc-server.xml wbem-https.xml xmpp-bosh.xml xmpp-client.xml xmpp-local.xml xmpp-server.xml ssh.xml:1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;service&gt; &lt;short&gt;SSH&lt;/short&gt; &lt;description&gt;Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.&lt;/description&gt; &lt;port protocol=&quot;tcp&quot; port=&quot;22&quot;/&gt;&lt;/service&gt;","link":"/147227b8.html"},{"title":"Linux login shell信息展示类（neofetch、motd等banner类提示信息展示）导致的rsync服务不可用问题注意事项","text":"终端报错信息(以Debian 11 系统为例)：protocol version mismatch — is your shell clean?系统环境 OS: Debian GNU/Linux 11 (bullseye) x86_64 Host: KVM RHEL 7.6.0 PC (i440FX + PIIX, 1996) Kernel: 5.10.0-22-amd64 问题描述 【问题】：导致rsync服务同步失败，报错信息: &quot;protocol version mismatch — is your shell clean?&quot;。 【原因】：rsync等工具非常依赖于shell执行时没有任何输出。 【建议】：不建议在.bashrc中输出neofetch、banner类和motd类提示信息，在~/.profile中source ~/.bashrc可以避免此问题，但需注意.profile循环引用执行问题。 login shell载入文件信息相关文件：12/etc/profile~/.profile .profile 引用 .bashrc: 12345if [ &quot;$BASH&quot; ]; then if [ -f ~/.bashrc ]; then . ~/.bashrc fifi 输出展示信息放在~/.bashrc文件内引发的问题（rsync为例）： 12345678910# ~/.bashrc: executed by bash(1) for non-login shells.# Note: PS1 and umask are already set in /etc/profile. You should not# need this unless you want different defaults for root.# PS1='${debian_chroot:+($debian_chroot)}\\h:\\w\\$ '# umask 022# problem（rsync）：protocol version mismatch — is your shell clean?neofetch 【问题】：导致rsync服务同步失败，报错信息: &quot;protocol version mismatch — is your shell clean?&quot;。【原因】：rsync等工具非常依赖于shell执行时没有任何输出。 【建议】：不建议在.bashrc中输出neofetch、banner类和motd类提示信息，在~/.profile中source ~/.bashrc可以避免此问题，但需注意.profile循环引用执行问题。 例如：~/.profile 1234567if [ &quot;$BASH&quot; ]; then if [ -f ~/.bashrc ]; then . ~/.bashrc fifineofetch 总结：在Linux发行版系统中，一些高度依赖.bashrc的系统工具或者命令(例如rsync)，会引发不可执行或者执行有误等问题，要留意Linux文件加载的顺序以及执行规则。","link":"/954c81e2.html"},{"title":"Rocky Linux系统初始化常用基础命令和工具包的便捷安装脚本（ljq@GitHub）","text":"Description: A script to check system version and installed tools on Rocky Linux.（脚本描述：一个用于检查系统版本和Rocky Linux系统初始化工具的便捷脚本,安装系统常用命令和工具包。）Author: Jacoliu (ljq@GitHub)Usage: ./rocky-linux-init.shVersion: 1.0Date: 2023-07-04License: MITPage Site: https://github.com/ljqrelease-version/rocky-linux/rocky-linux-init.sh Rocky Linux 发行版本默认检查安装基础工具包含： 123456789101112131415# Define tools list in lowercasetools=( &quot;vim&quot; # 0 &quot;ping&quot; # 1 &quot;net-tools&quot; # 2 &quot;firewalld&quot; # 3 &quot;tar&quot; # 4 &quot;gzip&quot; # 5 &quot;bzip2&quot; # 6 &quot;wget&quot; # 7 &quot;curl&quot; # 8 &quot;python 3&quot; # 9 &quot;git&quot; # 10 &quot;ncurses&quot; # 11) 备注：脚本简单灵活，可根据需要自行配置相关常用命令，方便系统管理员快速初始化系统基础环境。","link":"/96f1067a.html"},{"title":"nanochat-中文翻译版本（含代码注释和文档翻译，方便中文语境快速阅读和查看）","text":"🔗 nanochat-中文翻译版本(含文档和代码注释) nanochat项目源码地址 感谢原作者：Andrej karpathy这个仓库是一个完整的类ChatGPT大语言模型（LLM）的全栈实现，采用单一、简洁、最小化、可定制、依赖轻量的代码库。nanochat设计为通过像speedrun.sh这样的脚本在单个8XH100节点上运行，从开始到结束运行整个流程。这包括分词、预训练、微调、评估、推理以及通过简单UI提供Web服务，让你可以像使用ChatGPT一样与你自己的LLM对话。nanochat将成为Eureka Labs正在开发的LLM101n课程的顶点项目。 文件结构说明nanochat项目的主要文件及其用途： 核心模块 (nanochat/) nanochat/gpt.py - GPT模型架构实现，包含Transformer层、注意力机制等 nanochat/adamw.py - AdamW优化器实现 nanochat/muon.py - Muon优化器实现，用于线性层训练 nanochat/checkpoint_manager.py - 模型检查点保存和加载管理 nanochat/common.py - 通用工具函数，包括分布式训练初始化 nanochat/configurator.py - 配置参数管理，支持命令行覆盖 nanochat/core_eval.py - 核心评估指标计算 nanochat/dataloader.py - 数据加载器实现，支持分布式训练 nanochat/dataset.py - 数据集处理和下载 nanochat/engine.py - 模型推理引擎，支持批量生成 nanochat/execution.py - 执行上下文管理 nanochat/loss_eval.py - 损失评估函数 nanochat/report.py - 训练报告生成 nanochat/tokenizer.py - 分词器接口和实现 nanochat/ui.html - Web聊天界面 训练脚本 (scripts/) scripts/base_train.py - 基础模型预训练脚本 scripts/mid_train.py - 中期训练脚本，在预训练基础上继续训练 scripts/chat_sft.py - 监督微调训练脚本 scripts/chat_rl.py - 强化学习训练脚本 scripts/tok_train.py - 分词器训练脚本 scripts/base_eval.py - 基础模型评估脚本 scripts/base_loss.py - 基础损失评估脚本 scripts/chat_eval.py - 聊天模型评估脚本 scripts/tok_eval.py - 分词器评估脚本 scripts/chat_cli.py - 命令行聊天界面 scripts/chat_web.py - Web聊天服务器 任务模块 (tasks/) tasks/common.py - 任务混合和数据加载 tasks/arc.py - ARC问答任务实现 tasks/gsm8k.py - GSM8K数学推理任务实现 tasks/humaneval.py - HumanEval代码生成任务实现 tasks/mmlu.py - MMLU多任务语言理解任务实现 tasks/smoltalk.py - SmolTalk对话数据集处理 分词器 (rustbpe/) rustbpe/src/lib.rs - Rust实现的BPE分词器核心逻辑 rustbpe/Cargo.toml - Rust项目配置 rustbpe/README.md - 分词器文档 开发工具 (dev/) dev/generate_logo.html - 项目logo生成工具 dev/nanochat.png - 项目logo图片 dev/repackage_data_reference.py - 数据重新打包参考脚本 运行脚本 speedrun.sh - 快速运行脚本（约4小时训练） run1000.sh - 1000美元级别训练脚本 uv.lock - Python依赖锁定文件 pyproject.toml - Python项目配置 与它对话为了了解这个仓库的最终目标，你目前可以在nanochat.karpathy.ai上找到托管的nanochat d32。”d32”表示这个模型在Transformer神经网络中有32层。这个模型有19亿参数，通过简单地运行单个脚本run1000.sh在380亿token上训练，总训练成本约为800美元（在8XH100 GPU节点上约33小时训练时间）。虽然今天这足以超越2019年的GPT-2，但它与现代大语言模型如GPT-5相比仍有巨大差距。与这些微型模型对话时，你会看到它们犯很多错误，有点天真和愚蠢，会产生大量幻觉，有点像孩子。这有点有趣。但nanochat的独特之处在于它完全属于你 - 完全可配置、可调整、可定制，并由你从头到尾训练。要训练并与你自己的模型对话，我们转向… 快速开始感受魔力的最快方式是运行speedrun脚本speedrun.sh，它训练并推理100美元级别的nanochat。在8XH100节点上每小时24美元，总运行时间约为4小时。从你喜欢的提供商启动一个新的8XH100 GPU盒子（例如我使用并喜欢Lambda），然后启动训练脚本： 1bash speedrun.sh 或者，由于脚本运行4小时，我喜欢在一个新的screen会话speedrun中这样启动（并将输出记录到speedrun.log）： 1screen -L -Logfile speedrun.log -S speedrun bash speedrun.sh 如果你不太熟悉，请查看screen速查表。你可以在screen会话中观看进度，或者用Ctrl-a d分离并用tail speedrun.log查看进度。现在等待4小时。完成后，你可以通过类似ChatGPT的Web UI与你的LLM对话。确保你的本地uv虚拟环境已激活（运行source .venv/bin/activate），然后启动服务： 1python -m scripts.chat_web 然后访问显示的URL。确保正确访问，例如在Lambda上使用你所在节点的公共IP，后跟端口，例如http://209.20.xxx.xxx:8000/等。然后像通常与ChatGPT对话一样与你的LLM对话！让它写故事或诗歌。问它你是谁以看到幻觉。问它为什么天空是蓝色的。或者为什么是绿色的。speedrun是一个4e19 FLOPs能力的模型，所以有点像与幼儿园小朋友对话:)。 你也可以cat report.md文件，它出现在项目目录中，包含运行的”成绩单”，即一堆评估和指标。在最后，你会看到一个汇总表格，例如： 字符数: 333,989 行数: 8,304 文件数: 44 Token数（约）: 83,497 依赖项（uv.lock行数）: 2,004 指标 BASE MID SFT RL CORE 0.2219 - - - ARC-Challenge - 0.2875 0.2807 - ARC-Easy - 0.3561 0.3876 - GSM8K - 0.0250 0.0455 0.0758 HumanEval - 0.0671 0.0854 - MMLU - 0.3111 0.3151 - ChatCORE - 0.0730 0.0884 - 总挂钟时间: 3h51m （你的表格可能默认缺少RL数字）。关于speedrun脚本以及要寻找和期望的更多信息，请参考我在仓库讨论区发布的演练：“介绍nanochat：100美元能买到的最好的ChatGPT”。 更大的模型不出所料，100美元不足以训练一个高性能的ChatGPT克隆。事实上，LLM以其数百万美元的资本支出而闻名。对于我们的目的，我认为还有两个更有趣的规模。首先是约300美元的d26模型（即深度=26），训练约12小时，略微超越GPT-2 CORE分数。其次是1000美元级别（约41.6小时），只是因为这是一个不错的整数。但这两者尚未完全支持，因此尚未附加到主分支中。 也就是说，为了给出一个概念，训练GPT-2级别模型d26所需的speedrun.sh文件示例更改仅涉及三个更改： 1234567891011...# 你需要下载更多用于预训练的数据分片# 获取参数数量，乘以20得到token数，乘以4.8得到字符数，# 除以2.5亿得到分片数量。待办：需要改进这个...python -m nanochat.dataset -n 450 &amp;...# 使用--depth增加模型大小。为了避免内存不足，将设备批大小减半32 -&gt; 16：torchrun --standalone --nproc_per_node=8 -m scripts.base_train -- --depth=26 --device_batch_size=16...# 确保在中期训练期间使用相同的设置：torchrun --standalone --nproc_per_node=8 -m scripts.mid_train -- --device_batch_size=16 就是这样！最需要注意的事情是确保你有足够的数据分片进行训练（否则代码将循环并在相同的训练集上做更多轮次，稍微降低学习速度），以及管理你的内存/VRAM，主要通过减少device_batch_size直到适合（脚本通过增加梯度累积循环次数自动补偿，简单地将并行计算转换为顺序计算）。 关于运行nanochat的计算环境的更多信息： 代码在Ampere 8XA100 GPU节点上也能正常运行，但会慢一些。 所有代码甚至可以在单个GPU上通过省略torchrun正常运行，并产生几乎相同的结果（代码将自动切换到梯度累积），但你必须等待8倍时间。 如果你的GPU(s)少于80GB，你必须调整一些超参数，否则会出现OOM / VRAM不足。在脚本中查找--device_batch_size并减少它直到适合。例如从32（默认）到16、8、4、2，甚至1。少于这个你需要更了解你在做什么并更有创意。 大部分代码是相当标准的PyTorch，所以它应该在任何支持PyTorch的环境中运行 - xpu、mps等，但我没有开箱即用地实现这个，所以可能需要一些调整。 在CPU / MPS上运行如果你想在Macbook或CPU机器上调整nanochat，这里有一个进行中的CPU|MPS PR。如果你在Macbook上，在运行base_train.py时使用--device_type=mps。有关更多信息，请参阅PR及其差异。没有GPU节点你不会走得太远，但至少你将能够运行代码，并可能通过一些耐心训练一个非常小的LLM。 问题nanochat设计为简短而甜美。这样做的一个大优势是我们可以将所有文件打包在一起，并复制粘贴到你喜欢的LLM中询问任意问题。例如，我喜欢使用files-to-prompt实用程序像这样打包仓库： 1files-to-prompt . -e py -e md -e rs -e html -e toml -e sh --ignore &quot;*target*&quot; --cxml &gt; packaged.txt 这包括所有py、rs、html、toml、sh文件，排除rustbpe/target文件夹，并选择cxml输出格式。所有内容都写入packaged.txt文件，目前测量约330KB（即远低于最先进LLM的约10万token），以及约8K行代码在45个文件中。 或者，我推荐使用DeepWiki来自Devin/Cognition来询问这个仓库的问题。在这个仓库的URL中，只需将github.com更改为deepwiki.com，你就可以开始了。 测试我在这里投入不多，但存在一些测试，特别是对于分词器。运行例如： 1python -m pytest tests/test_rustbpe.py -v -s 贡献nanochat远未完成。目标是改进在&lt;1000美元预算下可端到端工作的微型模型的最新技术水平。可访问性是关于总体成本，也是关于认知复杂性 - nanochat不是一个详尽可配置的LLM”框架”；代码库中不会有巨大的配置对象、模型工厂或if-then-else怪物。它是一个单一、连贯、最小化、可读、可定制、最大可复制的”强基线”代码库，设计为从头到尾运行并产生具体的ChatGPT克隆及其成绩单。 致谢 名称（nanochat）源自我的早期项目nanoGPT，它只涵盖预训练。 nanochat也受到modded-nanoGPT的启发，它通过清晰的指标和排行榜将nanoGPT仓库游戏化，并借用了它的许多想法和一些预训练实现。 感谢HuggingFace提供fineweb和smoltalk。 感谢Lambda提供用于开发此项目的计算资源。 感谢首席LLM专家🧙‍♂️ Alec Radford的建议/指导。 引用如果你发现nanochat对你的研究有帮助，请引用为： 1234567@misc{nanochat, author = {Andrej Karpathy}, title = {nanochat: The best ChatGPT that $100 can buy}, year = {2025}, publisher = {GitHub}, url = {https://github.com/karpathy/nanochat}} 许可证MIT","link":"/24988dad.html"},{"title":"LUA Syntax","text":"LUA Notes注释 单行注释-- 多行注释 123--[[ 注释--]] 或 123--[[ 注释 ]] 多行注释遇到用[[和]]表示的字符串就会提前结束，可以用—-[=[ 注释内容 ]=]来解决 123--[=[ 注释 ]=] 程序块chunklua语法-程序块（chunk） lua解释器以程序块的方式处理lua代码 每一段可执行的lua代码都可以成为程序块 lua程序块指一条或多条合法的可执行语句 一个程序块由一条或多条lua语句构成 简单的程序块：一条语句 复杂的程序块：多条不同语句及函数定义构成语句结尾的分号缺省，如一行多哥语句，建议分号隔开 数据类型table （创建不同的数据类型：数组、字典等） table 数据结构本身支持多态，定义灵活,是数组和集合的混合物 table 使用关联数组，可以使用人艺类型值作索引，但值不能为nil table 是不固定大小的，你可以哥怒自己需要进行扩展 lua的模块（mobule）、包（package）、和对象（Object）本身也是基于table的 12345678t = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, [4] = &quot;d&quot;, [5] = &quot;f&quot;， [6] = function(){}} Table 操作 操作 方法 用途 连接 table.concat (table [, sep [, start [, end]]]) concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。 新增 table.insert (table, [pos,] value) 在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾. maxn table.maxn (table) 指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(Lua5.2之后该方法已经不存在了) 移除 table.remove (table [, pos]) 返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。 排序 table.sort (table [, comp]) 对给定的table进行升序排序。 变量 默认变量为全局变量，包含方法内变量，如果设置局部变量，则添加修饰符local(此处极易导致异常和Bug，谨慎使用，尽可能使用局部变量)，使用局部变量的好处： 避免命名冲突和和变量误覆盖 访问局部变量的速度更快 避免逻辑错误缺陷 全局变量删除：只需要将变量赋值为nil。 运算符运算符号 关系运算符: &lt; 、&gt;、&lt;= 、&gt;= 、 == 、 ~=(不等于) 逻辑运算符: and or not 连接运算符: .. (两个点) 运算注意事项 “0” 和 0 (false,不相等) nil只等于nil本身 逻辑运算符false和nil是假(false),其他为true（包括0也是true） and和or的运算结果不是true和false，而和两个操作数相关： a and b – 如果a为false，则返回a，否则返回b a or b – 如果a为true，则返回a，否则返回b lua比较数字按传统的数字大小进行，比较字符串按字母的顺序进行（但字母顺序依赖于本地环境(字符编码或其他顺序等不同)） 函数 () 括号仅用于函数中使用，其他地方可缺省忽略 循环while1234while(condition)do statementsend for123for var=exp1,exp2,exp3 do --end repeat123repeat statementsuntil( condition ) break 和 gotogoto语法格式：goto Label; Label 的格式为:: Label :: 12345678local a = 1::label:: print(&quot;--- goto label ---&quot;)a = a+1if a &lt; 3 then goto label -- a 小于 3 的时候跳转到标签 labelend continue官方未内置，可通过其他方式实现不提供continue的原因：Lua-FAQ：This is a common complaint. The Lua authors felt that continue was only one of a number of possible new control flow mechanisms (the fact that it cannot work with the scope rules of repeat/until was a secondary factor.)Lua作者认为continue非必要特性且只是许多新控制流机制中的一种，未加入此特性，continue关键字在repeat/until结构中会引发出现一些问题。 lua中模拟“continue”的几种方法： 使用repeat循环包住需要要continue跳过的代码，使用break跳出循环, 需要注意的是，lua中的repeat语句，在循环条件为真的时候退出 123456789for i = 1, 10 do repeat if i%2 == 0 then break end print(i) break until trueend 使用while循环包住需要continue跳过的代码， 使用break跳出循环 123456789for i = 1, 10 do while true do if i%2 == 0 then break end print(i) break endend 在lua5.2版本之后，可以使用goto语句来模拟 1234567for i = 1, 10 do if i%2 == 0 then goto continue end print(i) ::continue::end 模块与包 local 对象，外部模块无法访问 环境变量自定义设置 文件路径以 “;” 号分隔，最后的 2 个 “;;” 表示新加的路径后面加上原来的默认路径。 注意事项：Mac OS 系统下，export LUA_PATH=&quot;~/lua/?.lua;;&quot;在.zshrc中如果在用户home路径下自定义模块路径，会被当成～字符，不会解析用户的home路径no file '~/lua/modules/module.lua'，故建议应该写为绝对路径。 1234#LUA_PATH#export LUA_PATH=&quot;~/lua/?.lua;;&quot;export LUA_PATH=&quot;/Users/iotd/lua/?.lua;;&quot; 12345678910111213141516171819202122-- 文件名为 module.lua-- 定义一个名为 module 的模块module = {} -- 定义一个常量module.constant = &quot;这是一个常量&quot; -- 定义一个函数function module.func1() io.write(&quot;这是一个公有函数！\\n&quot;)end -- 外部无法访问到local function func2() print(&quot;这是一个私有函数！&quot;)end function module.func3() func2()end return module 元表","link":"/a1a26b3d.html"},{"title":"macOS Ghostty Terminal Ddefault binding keyboard shortcut key list（Ghostty.org Ghostty 终端默认快捷键列表）","text":"macOS Ghostty 终端默认快捷键列表 基本常用快捷键 12345678910111213141516171819command + t: 新建标签页command + n: 新建窗口command + w: 关闭当前终端界面（标签页或分割窗口）command + shift + w: 关闭当前窗口command + shift + enter: 切换分割窗口缩放command + alt + shift + w: 关闭所有窗口command + page_up: 向上滚动页面command + page_down: 向下滚动页面command + home: 滚动到顶部command + end: 滚动到底部command + q: 退出 Ghosttycommand + enter: 切换全屏模式command + ctrl + f: 切换全屏模式command + c: 复制到剪贴板command + v: 从剪贴板粘贴command + a: 全选command + k: 清空屏幕command + comma: 打开配置文件command + alt + i: 切换检查器 1234command + shift + [: 切换到上一个标签页command + shift + ]: 切换到下一个标签页ctrl + tab: 切换到下一个标签页ctrl + shift + tab: 切换到上一个标签页 分屏操作快捷键 12345678910111213command + d: 在右侧新建分割窗口command + shift + d: 在下方新建分割窗口command + alt + right: 切换到右侧分割窗口command + alt + left: 切换到左侧分割窗口command + alt + up: 切换到上方分割窗口command + alt + down: 切换到下方分割窗口command + [: 切换到上一个分割窗口command + ]: 切换到下一个分割窗口command + ctrl + left: 向左调整分割窗口大小command + ctrl + right: 向右调整分割窗口大小command + ctrl + up: 向上调整分割窗口大小command + ctrl + down: 向下调整分割窗口大小command + ctrl + equal: 使分割窗口大小相等 光标和选择快捷键 123456789101112command + up: 跳到上一个提示符位置command + down: 跳到下一个提示符位置command + shift + 跳到上一个提示符位置command + shift + down: 跳到下一个提示符位置shift + up: 向上调整选择范围shift + down: 向下调整选择范围shift + left: 向左调整选择范围shift + right: 向右调整选择范围shift + page_up: 向上调整选择范围（翻页）shift + page_down: 向下调整选择范围（翻页）shift + home: 调整选择范围到行首shift + end: 调整选择范围到行尾 光标操作快捷键 1234command + left: 通常是移动到行首command + right: 通常是移动到行尾alt + left: 通常是向左移动一个单词alt + right: 通常是向右移动一个单词 终端标签快捷键 1command + [Number]: 跳转到标签页Number","link":"/d89a2229.html"},{"title":"HomeBrew Mirror to accelerate Settings （HomeBrew 镜像加速解决源下载缓慢卡顿问题和超大软件包等待问题）","text":"HomeBrew 环境配置以及卡顿问题处理关键环境变量配置推荐使用清华源镜像替换：https://mirrors.ustc.edu.cn/ 1234567# 文件列表(对应以下镜像仓库地址)homebrew Folder-------------------------------homebrew-bottleshomebrew-cask-versions.githomebrew-cask.githomebrew-core.git 环境变量替换配置项：.bash_profile 或 .zshrc 12345678export HOMEBREW_BREW_GIT_REMOTE=&quot;https://mirrors.ustc.edu.cn/brew.git&quot;export HOMEBREW_CORE_GIT_REMOTE=&quot;https://mirrors.ustc.edu.cn/homebrew-core.git&quot;export HOMEBREW_BOTTLE_DOMAIN=&quot;https://mirrors.ustc.edu.cn/homebrew-bottles/bottles&quot;# close brew auto update （是否关闭自动更新，开发环境推荐设置为true，手动更新）export HOMEBREW_NO_AUTO_UPDATE=true 软件镜像地址替换： 1234567891011替换核心软件仓库cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git替换 cask 软件仓库cd &quot;$(brew --repo)&quot;/Library/Taps/caskroom/homebrew-caskgit remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git替换 cask-versions 软件仓库cd &quot;$(brew --repo)&quot;/Library/Taps/homebrew/homebrew-cask-versionsgit remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask-versions.git 针对部分官方软件包的下载处理(需要开发经验)关键目录12345# HomeBrew 安装源缓存目录：～/Library/Caches/Homebrew# 软件配置目录：/usr/local/etc 针对较大低速软件包的处理 软件安装原理：homebrew-tap源配置的.rb软件源有两个关键字段配置： 12url &quot;&quot;sha256 &quot;&quot; brew install [软件名]命令通过sha256校验值在Cache生成对应的类似临时文件(不同软件包有所不同)[sha256]--[软件]-[版本].[文件格式].incomplete，部分软件会在./downloads目录下载完成后文件变成类似[sha256]--[软件名]-[版本].[文件格式]，在上层目录生成软链,执行软件包解压或者转移到应用目录下。 如果既想使用homebrew管理软件包同时又忍受不了软件长时间的低速下载，可使 以上可以通过下方式完成软件包的替换（建议有开发经验人员是用，否则缓存目录可能产生冗余文件）：1.下载指定版本软件包（注意软件版本和对应的sha256值）；2.执行brew install [软件]，记录下临时文件的sha256值和文件名以及版本好；3.将已下载的软件包命名成[sha256]–[软件]-[版本].[文件格式]方式；4.再次执行brew install [软件]，此时成功的话会提示软件已下载完成，直接执行安装操作（如果仍提示下载软件，检查sha256文件名是否符合对应版本的软件包值要求）。","link":"/2dc6af80.html"},{"title":"MacOS English terminal Chinese garbled characters solution （MacOS英文环境终端中文内容乱码问题解决）","text":"Problem presentation123456LANGUAGE = &quot;en_US:en&quot;,LC_ALL = (unset),LC_CTYPE = &quot;UTF-8&quot;,LANG = &quot;en_US.UTF-8&quot;warning: Falling back to a fallback locale (&quot;en_US.UTF-8&quot;). 此问题常见于MacOS系统升级、OpenSSL升级后，terminal终端ssh远程链接时发出警告。 Solution在MacOS本地终端: 1sudo vi /etc/ssh/ssh_config 注释默认配置： 1SendEnv LANG LC_* 重启终端即可。 References参考","link":"/bb19ba9f.html"},{"title":"Efficiency optimization practice of oh-my-zsh (omz) configuration parameters（macOS下oh-my-zsh omz配置参数效率优化实践，对开发人员用户高频使用zsh场景建议）","text":"⚠️以下 oh-my-zsh 终端配置优化（仅针对macOS环境开发人员用户高频使用zsh终端配置建议，小白用户不建议尝试！） oh-my-zsh版本信息： OMZ版本：master (f1934d2) 更新时间：2025-10-20 配置默认: ~/.zshrc 目录大纲： oh-my-zsh 终端配置基础优化（仅建议，可避免配置文件和数据散落用户目录） ZSH 历史记录设置（omz:高性能模式） oh-my-zsh 终端配置基础优化（仅建议，可避免配置文件和数据散落用户目录）⚠️ 用户目录按实际用户名配置（例如:/Users/ljq） 1234567891011# zshexport ZDOTDIR=&quot;/Users/ljq/.zsh-custom&quot;# zsh sessions custom pathexport ZSH_SESSION_DIR=&quot;/Users/ljq/.zsh-custom/.zsh_sessions&quot;# z plugin custom pathexport _Z_DATA=&quot;/Users/ljq/.zsh-custom/.zdata&quot;# .zsh_history set pathexport HISTFILE=&quot;/Users/ljq/.zsh-custom/.zsh_history&quot;# Path to your oh-my-zsh installation.export ZSH=&quot;$HOME/.oh-my-zsh&quot; ZSH 历史记录设置（omz:高性能模式）~/.zshrc 123456789101112131415161718192021# ========== ZSH 历史记录设置（omz:高性能模式） ==========# .zsh_history: macOS(omz内存保留默认值50000)HISTSIZE=50000 # 内存中保留最多 50000 条（当前会话）SAVEHIST=50000 # 退出时仅将最近 50000 条写入文件（自动丢弃旧的）# .zsh_history:历史行为优化setopt HIST_IGNORE_DUPS # 忽略连续重复命令setopt HIST_SAVE_NO_DUPS # 保存时全局去重setopt HIST_EXPIRE_DUPS_FIRST # 达到上限时优先丢弃重复项（推荐）# .zsh_history:仅忽略“无参数”的简单命令（注意：没有 *，所以 'ls -l' 仍会被记录）setopt EXTENDED_GLOB # 启用扩展 glob 语法(解析格式)HISTORY_IGNORE=&quot;(&amp;\\|ls|ll|la|l|pwd|df|du|du\\ -sh\\ .|tree\\|ps|ps\\ aux|top|htop|jobs|bg|fg|uptime|free|free\\ -h\\|git|git\\ status|git\\ add\\ .|git\\ push*|git\\ pull|git\\ branch\\|docker\\ ps|docker\\ images|docker\\ volume\\ ls|docker\\ network\\ ls|docker-compose\\ ps\\|npm\\ ls|yarn\\ list|npm\\ outdated|yarn\\ outdated\\|python\\ --version|pip\\ list|pip\\ freeze|which\\ python\\|clear|history|man*|which*)&quot; 补充说明HISTORY_IGNORE一般开发场景下，建议忽略一些简单的系统命令，避免重复记录和影响磁盘IO以及无意义的数据记录，仅保留有效命令加快检索响应，实际上是多种策略的选择机制的权衡，建议根据实际使用的场景进行选择。如需开发交流可访问GitHub主页 获取联系信息: github.com/ljq。","link":"/fa8418d.html"},{"title":"Hexo cdn.jsdelivr.net A low cost solution for CDN invalidation（Hexo cdn.jsdelivr.net 等部分CDN引用无效的一种低成本解决方案）","text":"原因：cdn.jsdelivr.net在2021年12月20号国内已经无法使用，导致部分引用此引用此cdn资源的hexo生成站点js依赖和错误页面功能异常。 临时低成本解决方案： 考虑到不同的hexo站点使用的插件各有不同，且引用的第三方js库存在差异，故考虑采用低成本的方式解决。大概思路是在生成的部分文件里，替换相应的站点域名，实现在deploy之前完成文件路径的转换。 举例来说，也是本人遇到的问题，常用的js库jsdelivr CDNhttps://[CDN地址]/npm/js-base64/base64.min.js： 准备工作(主题icarus为例): 1.下载对应的无效js文件到本地； 2.文件放置在(对应创建CDN路径文件夹)themes/icarus/source/npm/js-base64/base64.min.js; 站点根路径生成常用命令封装了一个简单的操作命令脚本(hexo-deploy.sh)： 12345678910111213141516171819#!/usr/bin/env sh# author: Jaco Liu# Description: (debug | deploy git) scriptif [ &quot;$1&quot; == &quot;debug&quot; ]; then echo &quot;---------------- Debug Mode ----------------&quot; hexo clean &amp;&amp; hexo s exitfihexo clean &amp;&amp; hexo gecho &quot;---------------- Invalid CDN switch local path file ----------------&quot;# MacOS下sed和Linux发行版之间的区别，MacOS包含备份保护机制，注意sed -i ''find ./public -name &quot;*.html&quot; -type f -exec sed -i '' 's/\\/\\/cdn\\.jsdelivr\\.net\\//\\//g' '{}' \\;hexo decho 'hexo deploy run is ok !' 警告： 脚本包含替换操作！执行脚本前请严格检查命令可行性，防止误操作。 MacOS下sed和Linux发行版之间的区别，MacOS包含备份保护机制，注意sed -i ‘’ 执行成功后./public下路径替换会为/npm/js-base64/base64.min.js 备注：其他无效CDN域名引用，参考类似方法，注意sed命令转义。","link":"/bafde551.html"},{"title":"macOS系统升级导致brew发行包Nginx服务Service无法启动或启动失败问题解决（MacOS Ventura 13.3）","text":"macOS系统升级导致brew发行包Nginx服务Service无法启动或启动失败问题解决（MacOS Ventura 13.3）系统版本：MacOS Ventura 13.3Nginx服务启动失败问题描述：MacOS系统升级导致brew发行包Nginx服务Service无法启动或启动失败，提示隐私或权限问题，系统限制root用户运行。 解决方案：此脚本用于解决MacOS升级新版后，基于Homebrew发行的Nginx包守护服务无法启动运行问题。此问题一般由MacOS更新的权限隐私策略与nginx守护服务权限冲突导致服务无法启动。该脚本通过直接操作nginx服务进程实现服务的快捷管理，增加常用进程基础检查操作，封装快捷操作脚本。 ljq@GitHub Homebrew安装nginx: 1brew install nginx macos_nginx_brew_service.sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#!/usr/bin/env bash# Author: Jaco Liu# Date Time: 2023-04-07 20:06# Site: https://github.com/ljq# Blog: https://www.wdft.com# Email: ljqlab@163.com# Description: 🍎 The nginx distribution provided by hombrew daemon service shortcut script.# help infoUSEAGE=&quot;[usage]: [-s | s | status] [start | restart | reload | stop] [-h | -help | --help] [-v | -V | --version]&quot;HELP_INFO=$(cat &lt;&lt;EOF[help information]Description: 🍎 This script is used to resolve the problem that the Homebrew-based Nginx package daemon service cannot be started after the new version of MacOS is updated. This problem is usually caused by the conflict between the permission privacy policy updated by MacOS and the permission of the nginx daemon service. This script manages the service by directly manipulating the nginx service process.Command usage: -v|-V|version: Show current nginx version information. -h|-help|--help: Show help info. -s|s|status: Nginx process status. start|restart|reload|stop: Service operation.EOF)# set variablessh_file=$0argv1=$1nginx_conf_file=$(brew --prefix)/etc/nginx/nginx.confnginx_bin=$(brew --prefix nginx)/bin/nginx# main# descriptionif [ &quot;$argv1&quot; = &quot;&quot; ]; then echo -e &quot;[brew's nginx service shortcut script]\\n&quot;fi# initialization checkif [ ! -x &quot;$(command -v brew)&quot; ]; then echo -e &quot;[WARNING] Homebrew is not installed.&quot; exitfiif [ ! -f &quot;$nginx_bin&quot; ]; then echo -e &quot;[WARNING] The version of nignx provided by homebrew is not installed.&quot; exitfiif [ ! -f &quot;$nginx_conf_file&quot; ]; then echo -e &quot;[WARNING] The nignx.conf file provided by homebrew is not exist.&quot; exitfi# nginx config checkchk_status=$(${nginx_bin} -t 2&gt;&amp;1)if [[ $chk_status =~ &quot;syntax is ok&quot; ]] &amp;&amp; [[ $chk_status =~ &quot;test is successful&quot; ]]; then #echo -e &quot;[INFO] The nginx.conf syntax is ok.\\n&quot; echo &quot;&quot;else echo -e &quot;[ERROR] The nginx.conf syntax is incorrect.&quot; exitfi# execcase &quot;$argv1&quot; in &quot;-v&quot;|&quot;-version&quot;|&quot;--version&quot;|&quot;-V&quot;) ${nginx_bin} -V ;; &quot;-s&quot;|&quot;s&quot;|&quot;status&quot;) serv_process=$(ps -ef | grep nginx | grep -v &quot;grep\\|${sh_file}&quot;) if [ &quot;$serv_process&quot; = &quot;&quot; ]; then echo -e &quot;[NOTICE] Nginx service status is stoped.\\n&quot; else echo -e &quot;[NOTICE] Nginx service status is running.\\n&quot; fi ;; &quot;start&quot;) serv_process=$(ps -ef | grep nginx | grep -v &quot;grep\\|${sh_file}&quot;) if [ &quot;$serv_process&quot; = &quot;&quot; ]; then echo -e &quot;[NOTICE] Nginx service is starting ...\\n&quot; ${nginx_bin} -c $nginx_conf_file else echo -e &quot;[WARNING] Nginx service is already running. Do not repeat operation.\\n&quot; fi ;; &quot;restart&quot;) echo -e &quot;[NOTICE] Nginx service is restarting ...\\n&quot; ${nginx_bin} -s stop ${nginx_bin} -c $nginx_conf_file ;; &quot;reload&quot;) echo -e &quot;[NOTICE] Nginx service is reloading ...\\n&quot; ${nginx_bin} -s reload ;; &quot;stop&quot;) ${nginx_bin} -s stop echo -e &quot;[NOTICE] Nginx service has stoped.\\n&quot; ;; &quot;-t&quot;) ${nginx_bin} -t ;; &quot;-h&quot;|&quot;-help&quot;|&quot;--help&quot;) echo -e &quot;${HELP_INFO}\\n&quot; ;; *) echo -e &quot;[WARNING] Parameter is invalid or missing. Please run help command: ${sh_file} -h\\n&quot; ;;esacexit 脚本使用案例脚本增加可执行权限：1chmod +x macos_nginx_brew_service.sh 查看帮助：1./macos_nginx_brew_service.sh -h 常用操作1234567891011121314# 启动./macos_nginx_brew_service.sh start# 重启./macos_nginx_brew_service.sh restart# 状态./macos_nginx_brew_service.sh status# 重载./macos_nginx_brew_service.sh reload# 停止./macos_nginx_brew_service.sh stop# nginx 版本./macos_nginx_brew_service.sh -V 参数说明:1234567-v|-V|version: Show current nginx version information.-h|-help|--help: Show help info.-s|s|status: Nginx process status.start|restart|reload|stop: Service operation. macos_nginx_brew_service.sh ljq@GitHub","link":"/8c6562df.html"},{"title":"php laravel artisan 基础命令","text":"php artisan 常用命令php artisan 常用命令,注意一些版本差异。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465命令 说明 备注php artisan make:resource [parameter] 创建api返回格式化资源 &gt;=5.4版本可用php artisan make:rule [parameter] 创建validate规则 &gt;=5.4版本可用php artisan make:exception [parameter] 创建异常类 &gt;=5.4版本可用php artisan make:factory [parameter] 创建工厂类 &gt;=5.4版本可用php artisan package:discover 重置包的缓存信息 &gt;=5.4版本可用php artisan storage:link [parameter] Create a symbolic link from &quot;public/storage&quot; to &quot;storage/app/public&quot; &gt;=5.4版本可用php artisan view:clear 清楚所有已编译的视图文件 &gt;=5.4版本可用 命令 说明 备注php artisan clear-compiled 清除编译后的类文件 php artisan down 使应用程序进入维修模式 php artisan up 退出应用程序的维护模式 php artisan env 显示当前框架环境 php artisan fresh 清除包含框架外的支架 php artisan help 显示命令行的帮助 php artisan list 列出命令 php artisan migrate 运行数据库迁移 php artisan env 显示当前框架环境 php artisan optimize 为了更好的框架去优化性能 php artisan serve 在php开发服务器中服务这个应用 --port 8080，--host 0.0.0.0php artisan tinker 在应用中交互 php artisan app:name [parameter] 设置应用程序命名空间php artisan auth:clear-resets 清除过期的密码重置密钥 未使用过php artisan cache:clear 清除应用程序缓存 php artisan cache:table 创建一个缓存数据库表的迁移 php artisan config:cache 创建一个加载配置的缓存文件 php artisan config:clear 删除配置的缓存文件 php artisan db:seed 数据库生成模拟数据 php artisan event:generate 生成event和listen 需要实现配置eventserviceprivoderphp artisan make:command [parameter] 创建一个新的命令处理程序类 php artisan make:console [parameter] 生成一个Artisan命令 php artisan key:generate 设置程序密钥 php artisan make:controller [parameter] 生成一个资源控制类 php artisan make:middleware [parameter] 生成一个中间件 php artisan make:migration [parameter] 生成一个迁移文件 php artisan make:model [parameter] 生成一个Eloquent 模型类 php artisan make:provider [parameter] 生成一个服务提供商的类 php artisan make:request [parameter] 生成一个表单消息类 php artisan migrate:install [parameter] 创建一个迁移库文件 php artisan make:migration [parameter] 生成一个迁移文件 php artisan migrate:refresh [parameter] 复位并重新运行所有的迁移 php artisan migrate:reset [parameter] 回滚全部数据库迁移 php artisan migrate:rollback [parameter] 回滚最后一个数据库迁移 php artisan migrate:status 显示列表的迁移 php artisan queue:failed 列出全部失败的队列工作 php artisan queue:failed-table [parameter] 创建一个迁移的失败的队列数据库工作表 php artisan queue:flush 清除全部失败的队列工作 php artisan queue:forget [parameter] 删除一个失败的队列工作 php artisan queue:listen [parameter] 监听一个确定的队列工作php artisan queue:restart 重启现在正在运行的所有队列工作 php artisan queue:retry 重试一个失败的队列工作 php artisan queue:subscribe 订阅URL,放到队列上 php artisan queue:table 创建一个迁移的队列数据库工作表 php artisan queue:work 进行下一个队列任务php artisan route:cache 为了更快的路由登记，创建一个路由缓存文件 php artisan route:clear 清除路由缓存文件 php artisan route:list 列出全部的注册路由 php artisan schedule:run 运行预定命令 php artisan session:table 创建一个迁移的SESSION数据库工作表 php artisan vendor:publish 发表一些可以发布的有用的资源来自提供商的插件包 baum包命令命令 说明 备注php artisan baum Get Baum version notice. php artisan baum:install [parameter] Scaffolds a new migration and model suitable for Baum","link":"/4b985e6d.html"},{"title":"《如何创建一家像谷歌一样的公司》（How to start Google）- paulgraham - 转载","text":"文章原文地址：https://paulgraham.com/google.html （作者：保罗格雷厄姆）《如何创建一家像谷歌一样的公司》（How to start Google）2024 年 3 月 （这是我给14岁和15岁的孩子们做的演讲，内容是如果他们以后想要创业的话现在该怎么做。很多学校认为他们应该告诉学生一些关于创业的事情。这就是我认为他们应该告诉他们的。 ）你们中的大多数人可能认为，当您被释放到所谓的现实世界中时，您最终将不得不找到某种工作。 这不是真的，今天我要谈谈一个可以用来避免找工作的技巧。 诀窍是创办自己的公司。 所以这并不是逃避工作的伎俩，因为如果你创办自己的公司，你会比从事普通工作时更加努力。 但你会避免工作带来的许多烦人的事情，包括老板告诉你该做什么。 从事自己的项目比从事别人的项目更令人兴奋。 而且你还可以变得更加富有。 事实上，这是真正致富的标准方式。 如果你看一下偶尔在媒体上公布的最富有的人名单，你会发现几乎所有人都是通过创办自己的公司来实现这一目标的。 创办自己的公司可以意味着任何事情，从创办理发店到创办谷歌。 我来这里是要谈谈这个连续体的一个极端。 我将告诉您如何启动 Google。 位于谷歌连续体末端的公司在年轻时被称为初创公司。 我之所以了解他们，是因为我和妻子杰西卡创办了一家名为 Y Combinator 的公司，它基本上是一家初创工厂。 自 2005 年以来，Y Combinator 已资助了 4000 多家初创公司。 因此，我们确切地知道您创办一家初创公司需要什么，因为我们在过去 19 年里一直在帮助人们做到这一点。 当我说我要告诉你如何启动 Google 时，你可能认为我在开玩笑。 您可能会想“我们怎样才能启动 Google？” 但这实际上就是那些创建谷歌的人在创建之前所想的。 如果你告诉谷歌创始人拉里·佩奇和谢尔盖·布林，他们即将创办的公司有一天将价值超过一万亿美元，他们的脑袋一定会爆炸。 当你开始创业时，你所能知道的就是它似乎值得追求。 你不知道它会变成一家价值数十亿的公司还是一家倒闭的公司。 因此，当我说我要告诉你如何创办谷歌时，我的意思是我要告诉你如何才能创办一家像谷歌一样有机会成为谷歌的公司。 谷歌。 [1] 你如何从现在的状态发展到可以成功创业的地步？ 你需要三件事。 你需要擅长某种技术，你需要对你要构建的东西有一个想法，你需要联合创始人来创办公司。 如何才能擅长技术？ 您如何选择擅长哪种技术？ 这两个问题都有相同的答案：致力于自己的项目。 不要试图猜测基因编辑、法学硕士或火箭是否会成为最有价值的技术。 没有人能预测这一点。 只做你最感兴趣的事情。 你会在你感兴趣的事情上比你正在做的事情更加努力，因为你认为你应该这样做。 如果您不确定要擅长什么技术，那就擅长编程。 这一直是过去 30 年初创企业中位数的来源，而且在未来 10 年可能不会改变。 那些在学校上计算机科学课程的人此时可能会想，好吧，我们已经解决了这个问题。 我们已经被教授了所有关于编程的知识。 但抱歉，这还不够。 你必须致力于自己的项目，而不仅仅是在课堂上学习东西。 您可以在计算机科学课程上取得好成绩，而无需真正学习编程。 事实上，你可以从顶尖大学获得计算机科学学位，但仍然不擅长编程。 这就是为什么科技公司在雇用你之前都会让你参加编码测试，无论你在哪里上的大学或者你在那里表现得如何。 他们知道成绩和考试结果不能证明什么。 如果你真的想学习编程，你就必须从事自己的项目。 这样你学得更快。 想象一下，您正在编写一款游戏，并且您想要在其中执行某些操作，但您不知道如何执行。 你会发现比在课堂上学习任何东西要快得多。 不过，您不必学习编程。 如果您想知道什么才算技术，它几乎包括您可以使用“制造”或“构建”一词描述的所有内容。 所以焊接、制作衣服、制作视频都算数。 无论你对什么最感兴趣。关键的区别在于你是在生产还是只是在消费。 您是在编写电脑游戏，还是只是玩游戏？ 这就是截止点。 苹果公司的创始人史蒂夫·乔布斯（Steve Jobs）在青少年时期就花时间学习书法——那种美丽的书法。 文章原文地址：https://paulgraham.com/google.html （作者：保罗格雷厄姆）","link":"/de20129e.html"},{"title":"Tribute to the great legendary philanthropist and programmer Bram Moolenaar, the original author and software maintainer of VIM（致敬伟大传奇的慈善家和程序员Bram Moolenaar，VIM最初作者和软件维护者）","text":"Tribute to the great legendary philanthropist and programmer Bram Moolenaar, the original author and software maintainer of VIM（致敬伟大传奇的慈善家和程序员Bram Moolenaar，VIM最初作者和软件维护者）Bram Moolenaar is a Dutch computer programmer and the creator of the famous text editor Vim. Bram Moolenaar was born in 1961 in The Hague, Netherlands. In his career, he has worked in multiple fields such as software development and system management. However, his most well-known contribution was the creation of Vim, a popular text editor. In 1991, the standard editor Vi for Unix at that time had very limited versions on the MS-DOS platform, and Bram Moolenaar decided to develop a more powerful and scalable editor. He released the first version of Vim (Vi IMimproved) in 1991 and continued to drive its subsequent development and improvement. Vim is a free and open source text editor with powerful features and high customizability. It supports multiple operating systems, including Unix/Linux, Microsoft Windows, Mac OS, and has become one of the preferred tools for programmers and developers. In addition to Vim, Bram Moolenaar has also actively participated in the development and maintenance of multiple open source projects, making significant contributions to the software industry. As an excellent programmer and creator, Bram Moolenaar is widely praised and respected for his dedication to Vim and contributions to the open source community. His work and achievements have had a great impact on the global programmer community and continue to inspire a new generation of software developers. 致敬伟大传奇的慈善家和程序员Bram Moolenaar，VIM最初作者和软件维护者Bram Moolenaar是一位荷兰的计算机程序员，他是著名的文本编辑器Vim的创作者。 Bram Moolenaar于1961年出生在荷兰的海牙。在他的职业生涯中，他曾经从事过软件开发和系统管理等多个领域的工作。然而，他最为人所知的贡献是他创造了Vim这一广受欢迎的文本编辑器。 在1991年，当时的Unix的标准编辑器Vi在MS-DOS平台上的版本非常有限，Bram Moolenaar决定开发一个更加强大和可扩展的编辑器。他于1991年发布了第一个版本的Vim（Vi IMproved），并继续推动其后续的发展和改进。 Vim是一个自由、开源的文本编辑器，具有强大的功能和高度的可定制性。它支持多种操作系统，包括Unix/Linux、Microsoft Windows、Mac OS等，并且成为程序员和开发者们的首选工具之一。 除了Vim，Bram Moolenaar还积极参与了多个开源项目的开发与维护，为软件界做出了重要的贡献。 作为一名优秀的程序员和创造者，Bram Moolenaar因其对Vim的奉献和对开源社区的贡献而受到广泛的赞誉和尊重。他的工作和成就为全球的程序员社区带来了极大的影响，并且持续地激励着新一代的软件开发者们。 R.I.P 🕯️🙏","link":"/aa470947.html"},{"title":"人是怎样废掉的？","text":"一、懒 二、谗 三、拖延 四、爱熬夜！：继续睡觉做梦； 五、自控力差 六、整天精神内耗 七、停止思考不学习 八、假装努力，持续幻想 九、言语上的巨人，行动上的矮子 同样是睡8时，你为什么不选22:00-6:00？而是4:00-12:00？记住：自律的本质，就是亲手杀死另一个颓废的自己。 How do people become useless? 1、 Lazy 2、 Slander 3、 Procrastination 4、 Love staying up late Continue sleeping and dreaming; 5、 Poor self-control 6、 Mental exhaustion throughout the day 7、 Stop thinking and not learning 8、 Pretend to work hard and keep fantasizing 9、 A giant in words, a dwarf in action Why don’t you choose 22:00-6:00 when you sleep at 8 o’clock?But instead of 4:00-12:00? Remember: the essence of self-discipline is to personally kill another decadent version of oneself.","link":"/187f82a.html"},{"title":"The Legend of 1900","text":"1、All that city you just couldn’t see an end to it.城市那么大，看不到尽头。 2、The end? Please? Can you please just show me where it ends?尽头在哪里？可以给我看看尽头么？ 3、It was all very final on that gangway and I was grant too in my over coat. I cut quite a figure, and I was getting off, guaranteed. That wasn’t the problem.当年，我踏上跳板，不觉得困难。我穿上大衣，很神气，自觉一表人才，有决心，有把握，有信心。 4、It wasn’t what I saw that stopped me, Max, it was what I didn’t see. Do you understand that? What I didn’t see.我停下来，不是因为所见，是因为所不见。你明不明白？是因为看不见的东西。 5、In all that sprawling city, there was everything except an end. There was no end.连绵不绝的城市，什么都有，除了尽头，没有尽头。 6、What I did not see was where the whole thing came to an end, the end of the world.我看不见城市的尽头，我需要看见世界尽头。 7、Take a piano, hmm? The keys begin, the keys end. You know there are 88 of them. Nobody can tell you different. They are not infinite拿钢琴来说，键盘有始也有终。有88个键，错不了，并不是无限的。 8、You are infinite. And on those keys, the music that you can make is infinite.音乐是无限的。在琴键上，奏出无限的音乐 9、I like that. That I can live by.我喜欢那样，我应付得来。 10、You get me up on that gangway and you rill out in front of me a keyboard of millions of keys, Millions and billions of keys that never end.走过跳板，前面的键盘有无数的琴键。 11、That’s the truth, Max, they never end. That keyboard is infinite.事实如此，无穷无尽，键盘无限大。 12、And if that keyboard is infinite, then on that keyboard there is no music you can play.无限大的键盘，怎奏得出音乐？ 13、You are sitting on the wrong bench. That’s God’s piano.不是给凡人奏得，是给上帝奏得。 14、Christ! Did you see the streets? Just the street—–there were thousands of them.唉！只是街道，已经好几千条。 15、How do you do it down there? How do you choose just one?上了岸，何去何从？ 16、One woman, one house, one piece of land to call your own, one landscape to look at, one way to die. All that world just weighing down on you. You don’t even know where it comes to an end.爱一个女人，住一间屋子，买一块地，望一个景，走一条死路。太多选择，我无所适从，漫无止境，茫茫无际。 17、Aren’t you ever just scared of breaking apart at the thought of it? The enormity of it.思前想后，你不怕精神崩溃？那样的日子怎么过？ 18、I was born on this ship, and the world passed me by.我生于船，长与船，世界千变万化 19、But 2000 people at a time, and there were wishes here.这艘船每次只载客两千，既载人，有载梦想。 20、But never more than fit between prow and stern.但范围离不开船头与船尾之间。 21、You played put your happiness, but on a piano that was not infinite! I learned to live that way.在有限的钢琴上，我自得其乐，我过惯那样的日子。 22、Land?Land is a ship too big for me. It’s a woman too beautiful, it’s avoyage too long, a perfume too strong, it’s music I don’t know how tomake.陆地？对我来说，陆地是艘太大的船，是位太美的美女。是条太长的航程，是瓶太香的香水，是篇无从弹奏得乐章。 23、I can never get off this ship. I’m blessed I can step off my life.我没法舍弃这艘船，我宁可舍弃自己的生命。 24、After all, I don’t exist for anyone.反正，世间每人记得我。 25、You are the exception, Max. You are the only one who knows I’m here. You are a minority, and you’d better get used of it.除了你，Max,只有你知道我在这里，你属于少数，你最好习惯一下。 26、Forgive me, my friend, but I’m not getting off.朋友，原谅我。我不下船了。 27、Hey,Max! Imagine the music I could play with two right arms. Hope I can find a piano up there.两条右臂能谈出什么音乐？ 希望天堂有钢琴。 28、“陆上的人喜欢寻根问底，虚度了大好光阴。冬天忧虑夏天的姗姗来迟，夏天则担心冬天的将至。所以他们不停四处游走，追求一个遥不可及、四季如夏的地方—我并不羡慕。” Why why why why why… I think land people waste a lot of time wondering why. Winter comes they can’t wait for summer; summer comes they’re living dread of winter. That’s why you’re never tired of travelling, with chasing some place far away, where there’s always summer. That doesn’t sound like a good bet to me. 29、“所有那些城市，你就是无法看见尽头。尽头？拜托！拜托你给我看它的尽头在哪？当时，站在舷梯向外看还好。我那时穿着大衣，感觉也很棒，觉得自己前途无量，然后我就要下船去。放心！完全没问题！可是，阻止了我的脚步的，并不是我所看见的东西，而是我所无法看见的那些东西。你明白么？我看不见的那些。在那个无限蔓延的城市里，什么东西都有，可惟独没有尽头。根本就没有尽头。我看不见的是这一切的尽头，世界的尽头。”“All that city. You just couldn’t see the end to it. The end? Please? You please just show me where it ends? It was all very fine on that gangway. And I was grand too, in my overcoat. I cut quite a figure. And I was getting off. Guaranteed. There was no problem. It wasn’t what I saw that stopped me, Max. It was what I didn’t see. You understand that? What I didn’t see. In all that sprawling city there was everything except an end. There was no end. What I did not see was where the whole thing came to an end. The end of the world… ” 30、“键盘有始有终，你确切知道 88 个键就在那儿，错不了。它并不是无限的，而音乐，才是无限的。你能在键盘上表现的音乐是无限的，我喜欢这样，我能轻松应对。 ! ”“Take a piano. The keys begin, the keys end. You know there are eightyeight of them, nobody can tell you any different. They are not infinite. You are infinite. And on these keys the music that you can make is infinite. I like that. That I can live by. ” 31、“你把我推到舷梯上然后扔给我一架有百万琴键的钢琴，百万千万的没有尽头的琴键，那是事实，max，它们没有尽头。那键盘是无限延伸的。然而如果琴键是无限的，那么在那架琴上就没有你能弹奏的音乐，你坐错了地方，那是上帝的钢琴。”“You get me up on that gangway and you’re rolling out in front of me a keyboard of millions of keys, millions and billions of keys that never end, and that’s the truth, Max. That they never end. That keyboard is infinite. And if that keyboard is infinite, then on that keyboard there is nomusic you can play. You’re sitting on the wrong bench. That’s God’s piano. ” 32、“天啊！你……你看过那些街道吗？仅仅是街道，就有上千条！你下去该怎么办？你怎么选择其中一条来走？怎么选择“属于你自己的”一个女人，一栋房子，一块地，或者选择一道风景欣赏，选择一种方法死去。 ”“Christ! Did, did you see the streets? Just the streets… There were thousands of them! And how do you do it down there？How do you choose just one? One woman, one house, one piece of land to call your own, one landscape to look at, one way to die… ” 33、“那个世界好重，压在我身上。你甚至不知道它在哪里结束，你难道从来不为自己生活在无穷选择里而害怕得快崩溃掉吗？”“All that world is weighing down on me, you don’t even know where it comes to an end, and aren’t you ever just scared of breaking apart at the thought of it? The enormity of living it? ” 34、“我是在这艘船上出生的，整个世界跟我并肩而行，但是，行走一次只携带两千人。这里也有欲望，但不会虚妄到超出船头和船尾。你用钢琴表达你的快乐，但音符不是无限的。我已经习惯这么生活。”“I was born on this ship, and the world passed me by, but two thousand people at a time. And there were wishes here,but never more than fit between prow and stern. You played out your happiness, but on a piano that was not infinite. I learned to live that way. ” 35、“陆地？陆地对我来说是一艘太大的船，一个太漂亮的女人，一段太长的旅行，一瓶太刺鼻的香水，一种我不会创作的音乐。我永远无法放弃这艘船，不过幸好，我可以放弃我的生命。反正没人记得我存在过，而你是例外，max，你是唯一一个知道我在这里的人。你是唯一一个，而且你最好习惯如此。原谅我，朋友，我不会下船的。”“Land? Land is a ship too big for me. It’s a woman too beautiful; it’s a voyage too long, a perfume too strong. It’s a music I don’t know how to make. I could never get off this ship. At best, I can step off my life. After all, I don’t exist for anyone. You’re an exception, Max, you’re the only one who knows I’m here. You’re a minority, and you better get used to it. Forgive me, my friend, but I’m not getting off.”","link":"/6c9bcc36.html"},{"title":"travel hanghzou 2019.05.19","text":"杭城自旅小记 — 秋 Jaco Liu2019.05.19己亥夏初余足行，时节竹帘壁岭顷。 雾引青峦过龙井，偶有惊雀嬉零星。 曲径邻岩苔缕兴，十里山茶步履轻。 云栖闻泉鸟争鸣，竹径临溪沥雨惊。 少时暂驻净思省，沐风携雨心亦明。 拍摄图片分享","link":"/aeef277b.html"}],"tags":[{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"stable-diffusion-webui","slug":"stable-diffusion-webui","link":"/tags/stable-diffusion-webui/"},{"name":"Agent","slug":"Agent","link":"/tags/Agent/"},{"name":"clang","slug":"clang","link":"/tags/clang/"},{"name":"type","slug":"type","link":"/tags/type/"},{"name":"Cloud-Native","slug":"Cloud-Native","link":"/tags/Cloud-Native/"},{"name":"K8S","slug":"K8S","link":"/tags/K8S/"},{"name":"kebernetes","slug":"kebernetes","link":"/tags/kebernetes/"},{"name":"Cloud-Native-Framework","slug":"Cloud-Native-Framework","link":"/tags/Cloud-Native-Framework/"},{"name":"Cloud-Distributed","slug":"Cloud-Distributed","link":"/tags/Cloud-Distributed/"},{"name":"Distributed-Systems","slug":"Distributed-Systems","link":"/tags/Distributed-Systems/"},{"name":"K8S-Build","slug":"K8S-Build","link":"/tags/K8S-Build/"},{"name":"GUI","slug":"GUI","link":"/tags/GUI/"},{"name":"macro","slug":"macro","link":"/tags/macro/"},{"name":"io","slug":"io","link":"/tags/io/"},{"name":"format","slug":"format","link":"/tags/format/"},{"name":"ansi-lib","slug":"ansi-lib","link":"/tags/ansi-lib/"},{"name":"mysql8.x","slug":"mysql8-x","link":"/tags/mysql8-x/"},{"name":"mysql8.0","slug":"mysql8-0","link":"/tags/mysql8-0/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"utf8mb4","slug":"utf8mb4","link":"/tags/utf8mb4/"},{"name":"utf8mb4_0900_ai_ci","slug":"utf8mb4-0900-ai-ci","link":"/tags/utf8mb4-0900-ai-ci/"},{"name":"utf8mb4_general_ci","slug":"utf8mb4-general-ci","link":"/tags/utf8mb4-general-ci/"},{"name":"GIT","slug":"GIT","link":"/tags/GIT/"},{"name":"GPG","slug":"GPG","link":"/tags/GPG/"},{"name":"GPG2","slug":"GPG2","link":"/tags/GPG2/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"go-pprof","slug":"go-pprof","link":"/tags/go-pprof/"},{"name":"changelog","slug":"changelog","link":"/tags/changelog/"},{"name":"History","slug":"History","link":"/tags/History/"},{"name":"Go-chain-operation","slug":"Go-chain-operation","link":"/tags/Go-chain-operation/"},{"name":"GO方法值","slug":"GO方法值","link":"/tags/GO%E6%96%B9%E6%B3%95%E5%80%BC/"},{"name":"func","slug":"func","link":"/tags/func/"},{"name":"Go Summary notes","slug":"Go-Summary-notes","link":"/tags/Go-Summary-notes/"},{"name":"goroutine","slug":"goroutine","link":"/tags/goroutine/"},{"name":"Go-init()","slug":"Go-init","link":"/tags/Go-init/"},{"name":"interface","slug":"interface","link":"/tags/interface/"},{"name":"Go(new,make,struct{})","slug":"Go-new-make-struct","link":"/tags/Go-new-make-struct/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"Go null judge","slug":"Go-null-judge","link":"/tags/Go-null-judge/"},{"name":"Go(map)","slug":"Go-map","link":"/tags/Go-map/"},{"name":"Go-Polymorphism","slug":"Go-Polymorphism","link":"/tags/Go-Polymorphism/"},{"name":"Go-Printf","slug":"Go-Printf","link":"/tags/Go-Printf/"},{"name":"pointer","slug":"pointer","link":"/tags/pointer/"},{"name":"reflect反射","slug":"reflect反射","link":"/tags/reflect%E5%8F%8D%E5%B0%84/"},{"name":"slice切片本质","slug":"slice切片本质","link":"/tags/slice%E5%88%87%E7%89%87%E6%9C%AC%E8%B4%A8/"},{"name":"Go(string)","slug":"Go-string","link":"/tags/Go-string/"},{"name":"Go(Struct|Method|Receiver)","slug":"Go-Struct-Method-Receiver","link":"/tags/Go-Struct-Method-Receiver/"},{"name":"struct","slug":"struct","link":"/tags/struct/"},{"name":"switch","slug":"switch","link":"/tags/switch/"},{"name":"package time","slug":"package-time","link":"/tags/package-time/"},{"name":"type关键词总结","slug":"type关键词总结","link":"/tags/type%E5%85%B3%E9%94%AE%E8%AF%8D%E6%80%BB%E7%BB%93/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"centos7","slug":"centos7","link":"/tags/centos7/"},{"name":"systemd-service","slug":"systemd-service","link":"/tags/systemd-service/"},{"name":"chattr","slug":"chattr","link":"/tags/chattr/"},{"name":"OpenSSH","slug":"OpenSSH","link":"/tags/OpenSSH/"},{"name":"配置文件体系","slug":"配置文件体系","link":"/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"name":"firewalld","slug":"firewalld","link":"/tags/firewalld/"},{"name":"services","slug":"services","link":"/tags/services/"},{"name":"防火墙","slug":"防火墙","link":"/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"debian","slug":"debian","link":"/tags/debian/"},{"name":"neofetch","slug":"neofetch","link":"/tags/neofetch/"},{"name":"rsync","slug":"rsync","link":"/tags/rsync/"},{"name":"banner","slug":"banner","link":"/tags/banner/"},{"name":"motd","slug":"motd","link":"/tags/motd/"},{"name":"rocky-linux","slug":"rocky-linux","link":"/tags/rocky-linux/"},{"name":"rocky-linux-tools","slug":"rocky-linux-tools","link":"/tags/rocky-linux-tools/"},{"name":"rocky","slug":"rocky","link":"/tags/rocky/"},{"name":"nanochat","slug":"nanochat","link":"/tags/nanochat/"},{"name":"nanochat-zh_CN","slug":"nanochat-zh-CN","link":"/tags/nanochat-zh-CN/"},{"name":"lua","slug":"lua","link":"/tags/lua/"},{"name":"Ghostty","slug":"Ghostty","link":"/tags/Ghostty/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"homebrew","slug":"homebrew","link":"/tags/homebrew/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","link":"/tags/oh-my-zsh/"},{"name":"omz","slug":"omz","link":"/tags/omz/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"CDN","slug":"CDN","link":"/tags/CDN/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"laravel","slug":"laravel","link":"/tags/laravel/"},{"name":"laravel-artisan","slug":"laravel-artisan","link":"/tags/laravel-artisan/"},{"name":"cli","slug":"cli","link":"/tags/cli/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"VIM","slug":"VIM","link":"/tags/VIM/"},{"name":"VIM Author","slug":"VIM-Author","link":"/tags/VIM-Author/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"人生","slug":"人生","link":"/tags/%E4%BA%BA%E7%94%9F/"},{"name":"转载","slug":"转载","link":"/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"Movie","slug":"Movie","link":"/tags/Movie/"},{"name":"Note The Legend of 1900","slug":"Note-The-Legend-of-1900","link":"/tags/Note-The-Legend-of-1900/"},{"name":"travel","slug":"travel","link":"/tags/travel/"},{"name":"daily","slug":"daily","link":"/tags/daily/"}],"categories":[{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"cloud-native","slug":"cloud-native","link":"/categories/cloud-native/"},{"name":"painting","slug":"AI/painting","link":"/categories/AI/painting/"},{"name":"distributed","slug":"distributed","link":"/categories/distributed/"},{"name":"Agent","slug":"AI/Agent","link":"/categories/AI/Agent/"},{"name":"clang","slug":"clang","link":"/categories/clang/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Controlnet","slug":"AI/painting/Controlnet","link":"/categories/AI/painting/Controlnet/"},{"name":"GIT","slug":"GIT","link":"/categories/GIT/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"Drawing","slug":"AI/painting/Controlnet/Drawing","link":"/categories/AI/painting/Controlnet/Drawing/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"lua","slug":"lua","link":"/categories/lua/"},{"name":"macOS","slug":"macOS","link":"/categories/macOS/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"reprinted-articles","slug":"reprinted-articles","link":"/categories/reprinted-articles/"},{"name":"history-of-programing","slug":"history-of-programing","link":"/categories/history-of-programing/"},{"name":"daily","slug":"daily","link":"/categories/daily/"},{"name":"centos","slug":"linux/centos","link":"/categories/linux/centos/"},{"name":"openssl","slug":"linux/openssl","link":"/categories/linux/openssl/"},{"name":"firewalld","slug":"linux/firewalld","link":"/categories/linux/firewalld/"},{"name":"debian","slug":"linux/debian","link":"/categories/linux/debian/"},{"name":"oh-my-zsh","slug":"macOS/oh-my-zsh","link":"/categories/macOS/oh-my-zsh/"},{"name":"daily","slug":"history-of-programing/daily","link":"/categories/history-of-programing/daily/"},{"name":"note","slug":"daily/note","link":"/categories/daily/note/"},{"name":"zsh","slug":"macOS/oh-my-zsh/zsh","link":"/categories/macOS/oh-my-zsh/zsh/"},{"name":"zshrc","slug":"macOS/oh-my-zsh/zsh/zshrc","link":"/categories/macOS/oh-my-zsh/zsh/zshrc/"},{"name":"Optimization","slug":"macOS/oh-my-zsh/zsh/zshrc/Optimization","link":"/categories/macOS/oh-my-zsh/zsh/zshrc/Optimization/"}]}